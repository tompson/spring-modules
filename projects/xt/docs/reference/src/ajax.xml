<sect1 id="ajax"><title>XT Ajax Framework</title>
    <sect2 id='ajax-intro'><title id='ajax-intro-title'>Introduction</title>
        <para>XT Ajax Framework is based on the following fundamental concepts:
        </para>
        <itemizedlist>
            <listitem>
                <para>Events
                </para>
            </listitem>
            <listitem>
                <para>Handlers
                </para>
            </listitem>
            <listitem>
                <para>Actions
                </para>
            </listitem>
            <listitem>
                <para>Components
                </para>
            </listitem>
            <listitem>
                <para>Responses
                </para>
            </listitem>
        </itemizedlist>
        <para>They work together in a simple processing flow:
        </para>
        <orderedlist>
            <listitem>
                <para>Web pages fire <emphasis role='bold'>events</emphasis> using standard <ulink url='http://www.w3schools.com/js/js_events.asp'><citetitle>JavaScript events</citetitle></ulink>.
                </para>
            </listitem>
            <listitem>
                <para>Each event causes an Ajax request that is processed by simple Java objects acting as server side <emphasis role='bold'>handlers</emphasis>.
                </para>
            </listitem>
            <listitem>
                <para>The handler processes events creating <emphasis role='bold'>actions</emphasis>.
                </para>
            </listitem>
            <listitem>
                <para>Each action may render one or more HTML <emphasis role='bold'>components</emphasis> in the page.
                </para>
            </listitem>
            <listitem>
                <para>At the end, actions are canalised into an Ajax <emphasis role='bold'>response</emphasis> sent back to the web page.
                </para>
            </listitem>
        </orderedlist>
        <para>We'll take a more detailed look to each of the concepts above in the next section.
        </para>
    </sect2>
    <sect2 id='ajax-base'><title id='ajax-base-title'>Base Concepts</title>
        <sect3 id='ajax-events'><title id='ajax-events-title'>Ajax Events</title>
            <para>In XT Ajax Framework you can raise events from your web pages as standard <ulink url='http://www.w3schools.com/js/js_events.asp'><citetitle>JavaScript events</citetitle></ulink>, and handle them by the server side, 
                <emphasis role='bold'>without having to write any javascript code</emphasis>.
                There are actually the following types of Ajax events: 
            </para>
            <itemizedlist>
                <listitem>
                    <para><emphasis role='bold'>Action events</emphasis>, a generic event type directly handled by configured <link linkend="ajax-handlers">handlers</link> <emphasis role='bold'>without</emphasis> calling any Spring MVC controller: 
                        this is most used for updating the web page with data from the server.
                    </para>
                </listitem>
                <listitem>
                    <para><emphasis role='bold'>Submit events</emphasis>, a special type of event handled by configured <link linkend="ajax-handlers">handlers</link> <emphasis role='bold'>after</emphasis> executing the Spring MVC controller 
                        associated with the page: this event causes the submit of the page and so the handling of the submit by the controller, and can be used for
                        further processing the submit for properly updating the view.
                    </para>
                </listitem>
            </itemizedlist>
            <para>Ajax <emphasis role='bold'>action events</emphasis> are fired in web pages as follows:
            </para>
            <programlisting><![CDATA[
                <input type="button" value="Go" onclick="doAjaxAction('eventId', this, {'param1' : 'value1', 'param2' : 'value2'});"> 
            ]]></programlisting>
            <para>You have to simply call the (pre-implemented) <emphasis role='bold'>doAjaxAction</emphasis> JavaScript function, 
                passing:
            </para>
            <itemizedlist>
                <listitem>
                    <para>The <emphasis role='bold'>name (or id) of the event</emphasis> you want to fire ('eventId').
                    </para>
                </listitem>
                <listitem>
                    <para>The html element which fired the event, through the <emphasis role='bold'>this</emphasis> objects.
                    </para>
                </listitem>
                <listitem>
                    <para>A <ulink url='http://www.json.org/'><citetitle>JSON</citetitle></ulink> string containing
                        extra parameters you want to pass to the server.
                    </para>
                </listitem>
            </itemizedlist>
            <para>Once you receive the event in your server side handler, you can access the following information (see XT javadocs for more information):
            </para>
            <itemizedlist>
                <listitem>
                    <para>The event id (corresponding to the event name above).
                    </para>
                </listitem>
                <listitem>
                    <para>The Java <ulink url='http://java.sun.com/j2ee/1.4/docs/api/javax/servlet/ServletRequest.html'><citetitle>HttpServletRequest</citetitle></ulink> object.
                    </para>
                </listitem>
                <listitem>
                    <para>The name and id of the html element firing the event.
                    </para>
                </listitem>
                <listitem>
                    <para>A map of string key/value pairs, containing the extra parameters defined above using the JSON string.
                    </para>
                </listitem>
                <listitem>
                    <para>The command object created by the Spring MVC controller, if this is a <ulink url='http://static.springframework.org/spring/docs/1.2.x/api/org/springframework/web/servlet/mvc/BaseCommandController.html'><citetitle>BaseCommandController</citetitle></ulink>.
                    </para>
                </listitem>
            </itemizedlist>
            <para>For firing Ajax <emphasis role='bold'>submit events</emphasis>, you have to write:
            </para>
            <programlisting><![CDATA[
                <input type="button" value="Press" onclick="doAjaxSubmit('eventId', this {'param1' : 'value1', 'param2' : 'value2'});"> 
            ]]></programlisting>
            <para>You have to simply call the (pre-implemented) <emphasis role='bold'>doAjaxSubmit</emphasis> JavaScript function, passing it the same information
                defined above.
            </para>
            <para>Once you receive the event in your server side handler, you can access the following information in addition to those defined above (see XT javadocs for more information):
            </para>
            <itemizedlist>
                <listitem>
                    <para>A container of <ulink url='http://static.springframework.org/spring/docs/1.2.x/api/org/springframework/validation/Errors.html'><citetitle>validation errors</citetitle></ulink>, for managing form submission errors.
                    </para>
                </listitem>
                <listitem>
                    <para>The model map returned by the controller submit method, if any.
                    </para>
                </listitem>
            </itemizedlist>
            <para>Given that submit events are handled after calling the configured Spring MVC controller, the command object, model map, and validation errors contained 
                in the submit event are <emphasis role='bold'>the same</emphasis> objects you manage in the controller.
            </para>
        </sect3>
        <sect3 id='ajax-handlers'><title id='ajax-handlers-title'>Ajax Handlers</title>
            <para>The Ajax handler is the server side component to be implemented for managing Ajax events.
                This is the interface of an Ajax handler, followed by a description of its methods: 
            </para>
            <programlisting><![CDATA[
                public interface AjaxHandler { 

                public boolean supports(AjaxEvent event); 

                public AjaxResponse handle(AjaxEvent event); 
                } 
            ]]></programlisting>
            <itemizedlist>
                <listitem><para><emphasis>public boolean supports(AjaxEvent event)</emphasis> : Check if <emphasis>this</emphasis> handler supports (can handle) the given, generic, <emphasis role='bold'>AjaxEvent</emphasis></para></listitem>
                <listitem><para><emphasis>public AjaxResponse handle(AjaxEvent event)</emphasis> : Handle the given, generic, <emphasis role='bold'>AjaxEvent</emphasis> (if supported) and returns an appropriate <emphasis role='bold'>AjaxResponse</emphasis> (see <link linkend="ajax-response">Ajax Response</link>).</para></listitem>
            </itemizedlist>
            <para>Out of the box, XT Ajax Framework provides an AjaxHandler abstract implementation which provides a straightforward way of implementing Ajax handlers: the <emphasis role='bold'>AbstractAjaxHandler</emphasis>.
                AbstractAjaxHandler is an event dispatcher based on Java reflection and Ajax events name (<emphasis>id</emphasis>): it implements the two methods above dispatching events to methods named after the event id. 
                So, for handling different events, you have to simply implement a method named after the event id you want to handle, with the following signature: 
            </para>
            <programlisting><![CDATA[public AjaxResponse eventId(AjaxEvent )]]></programlisting>
            <para>Given an ajax event with id <emphasis>countrySelection</emphasis>, the handling method will be:
            </para>
            <programlisting><![CDATA[public AjaxResponse countrySelection(AjaxEvent )]]></programlisting>
            <para>Doing so you handle generic <emphasis>AjaxEvent</emphasis>s.
                If you want to handle <emphasis>AjaxActionEvent</emphasis>s or <emphasis>AjaxSubmitEvent</emphasis>s, simply write methods with the following signatures: 
            </para>
            <programlisting><![CDATA[public AjaxResponse eventId(AjaxActionEvent )]]></programlisting>
            <programlisting><![CDATA[public AjaxResponse eventId(AjaxSubmitEvent )]]></programlisting>
            <para>However, you are free to implement a different handling strategy, directly implementing the interface above.
            </para>
            <para>You've seen how to fire events from web pages, and how to handle them through AjaxHandlers.
                The next step is <emphasis role='bold'>how to associate events with handlers</emphasis>. 
            </para>
        </sect3>
        <sect3 id='associating-events-with-handlers'><title id='associating-events-with-handlers-title'>Associating events with handlers: the AjaxInterceptor</title>
            <para>Once defined your events and implemented your handlers, you need to <emphasis role='bold'>associate</emphasis> them.
            </para>
            <para>For <emphasis role='bold'>security reason</emphasis>, web pages events and ajax handlers are not automatically associated, nor can be globally associated.
                If it were so, malicious users could hack your JavaScript events and execute unwanted events. 
            </para>
            <para>So, events and handlers are associated <emphasis role='bold'>per page path</emphasis>, that is, you have to configure every handler to manage events fired by a pre-determined, restricted, set of pages.
                Specifically, you can configure an handler to manage events fired by a specific, single, web page, or by web pages defined with <ulink url='http://ant.apache.org'><citetitle>Ant</citetitle></ulink> style pattern matching.  
            </para>
            <para>
                This is done in two simple steps.
            </para>
            <para>
                First, you have to define in your Spring application context an <emphasis role='bold'>AjaxInterceptor</emphasis>: it is the bean which associates web pages and Ajax handlers,
                making under the cover the actual event dispatching.
                Here is an example of AjaxInterceptor configuration:
            </para>
            <programlisting><![CDATA[
                <bean id="ajaxInterceptor" class="org.springmodules.xt.ajax.AjaxInterceptor">

                <property name="handlerMappings">
                <props
                <prop key="/ajax/ex*">genericAjaxHandler</prop>
                <prop key="/ajax/ex1.page">ajaxHandler1</prop>
                <prop key="/ajax/ex2.page">ajaxHandler2</prop>
                </props>
                </property>

                </bean>
            ]]></programlisting>
            <para>The <emphasis>handlerMappings</emphasis> property is a list of key/value entries associating a web path (the key) with an handler (the value), which
                must be an AjaxHandler declared as a bean in the Spring applicationContext. 
                As you can notice, the first entry associates the handler with an Ant style pattern, while others associate handlers with single pages. 
                Doing so, you can also apply more handlers to the same group of pages. When more handlers apply for the same event, the one configured for matching the longest web path wins. 
            </para>
            <para>
                Finally, the second step requires you to associate the AjaxInterceptor with the interceptors chain of your Spring MVC <ulink url='http://static.springframework.org/spring/docs/1.2.x/api/org/springframework/web/servlet/HandlerMapping.html'><citetitle>URL handler mapping</citetitle></ulink>.
                Here is how:
            </para>
            <programlisting><![CDATA[
                <bean id="urlHandlerMapping" class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">

                <property name="interceptors">
                <list>
                <ref bean="ajaxInterceptor"/>
                </list>
                </property>

                <property name="mappings">
                <props>
                <!-- ... -->
                </props>
                </property>

                </bean>
            ]]></programlisting>
            <para>
                Now, we are ready to go with <link linkend="ajax-actions">actions</link>!
            </para>
        </sect3>
        <sect3 id='ajax-actions'><title id='ajax-actions-title'>Ajax Actions</title>
            <para>Ajax actions are created by handlers and act on the client. XT Ajax Framework provides many useful actions ready to be used (see the <emphasis>org.springmodules.xt.ajax.action</emphasis> package for details); 
                however, creating custom actions is just a matter of implementing the following simple interface:
            </para>
            <programlisting><![CDATA[
                public interface AjaxAction { 

                public String execute(); 

                } 
            ]]></programlisting> 
            <para>The <emphasis>execute()</emphasis> method is the one you call for producing the action result.</para>
            <para>Actions can do various things, depending on the concrete implementation: most of the time they render <link linkend="components">components</link>.
            </para>
        </sect3>
        <sect3 id='components'><title id='components-title'>Components</title>
            <para>Generally speaking, <emphasis role='bold'>component</emphasis>s represent web page parts; however, most of the time they represent html elements, like
                input fields, tables and so. XT Ajax Framework provides many useful components ready to be used (see the <emphasis>org.springmodules.xt.ajax.component</emphasis> package for details), 
                but creating custom components is just a matter of implementing the following simple interface:
            </para>
            <programlisting><![CDATA[
                    public interface Component { 

                    public String render(); 

                    } 
                ]]></programlisting>
            <para>Each component renders itself through the <emphasis role='bold'>render()</emphasis> method, returning a string representation of its rendering.</para>
            <para>But how do actions render components?</para>
            <para>
                Components are added to actions in a way that depends on the concrete action implementation, and then rendered through the action <emphasis>execute()</emphasis> method.
            </para>
            <para>
                Now that you have your ajax actions and components, the only thing left to do is filling your <link linkend="ajax-response">ajax response</link>.
            </para>
        </sect3>
        <sect3 id='ajax-response'><title id='ajax-response-title'>Ajax Response</title>
            <para><emphasis role='bold'>AjaxResponse</emphasis> objects are filled with actions whose result is carried to clients, that is, to web pages.
                This is the interface of the AjaxResponse, followed by a description of its methods: 
            </para>
            <programlisting><![CDATA[
                public interface AjaxResponse { 

                public void addAction(AjaxAction action); 

                public String getResponse(); 
                } 
            ]]></programlisting>
            <itemizedlist>
                <listitem><para><emphasis>public void addAction(AjaxAction action)</emphasis> : This method is used for adding actions that will be executed and whose result will be sent to the client.</para></listitem>
                <listitem><para><emphasis>public String getResponse()</emphasis> : This method executes the added actions and returns their result.</para></listitem>
            </itemizedlist>
            <para>
                In the context of one ajax response, actions are executed <emphasis role='bold'>following their order of adding</emphasis>.
            </para>
        </sect3>
        <sect3 id='integration'><title id='integration-title'>XT Ajax Framework, Taconite and integration with other JavaScript libraries</title>
            <para>
                The way XT Ajax Framework interacts with client web pages is based on the wonderful <ulink url='http://taconite.sourceforge.net'><citetitle>Taconite</citetitle></ulink> JavaScript library.
                So, for using the XT Ajax Framework you need to include in your web pages Taconite, plus some other JavaScript library you can find under the <emphasis>js</emphasis> directory. 
                However, all these core JavaScript libraries are put, at compile time, in the <emphasis>springxt.js</emphasis> file under the <emphasis>js/lib/core</emphasis> directory.
                This is the only file you need to include in your web page:
            </para>
            <programlisting><![CDATA[
                <script type="text/javascript" src='springxt.js'></script> 
            ]]></programlisting> 
            <para>
                However, XT Ajax Framework integrates with other JavaScript libraries for providing additional capabilities, like new kind of actions: take a look at javadocs for more details.
                All these additional libraries can be found under the <emphasis>js/lib/opt</emphasis> directory.
            </para>
            <tip>
                <para>
                    Under the <emphasis>js/lib/core</emphasis> you'll find also a <emphasis>springxt-min.js</emphasis> file: it is a minified version 
                    of <emphasis>springxt.js</emphasis> you can include in your pages for reducing the download size.
                </para>
            </tip>
        </sect3>
    </sect2>
</sect1>
