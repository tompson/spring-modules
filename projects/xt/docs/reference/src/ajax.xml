<?xml version="1.0" encoding="UTF-8"?>
<sect1 id="ajax">
  <title>XT Ajax Framework</title>

  <sect2 id="ajax-intro">
    <title id="ajax-intro-title">Introduction</title>

    <para>XT Ajax Framework is based on the following fundamental
    concepts:</para>

    <itemizedlist>
      <listitem>
        <para>Events</para>
      </listitem>

      <listitem>
        <para>Handlers</para>
      </listitem>

      <listitem>
        <para>Actions</para>
      </listitem>

      <listitem>
        <para>Components</para>
      </listitem>

      <listitem>
        <para>Responses</para>
      </listitem>
    </itemizedlist>

    <para>They work together in a simple processing flow:</para>

    <orderedlist>
      <listitem>
        <para>Web pages fire <emphasis role="bold">events</emphasis> using
        standard <ulink
        url="http://www.w3schools.com/js/js_events.asp"><citetitle>JavaScript
        events</citetitle></ulink>.</para>
      </listitem>

      <listitem>
        <para>Each event causes an Ajax request that is processed by simple
        Java objects acting as server side <emphasis
        role="bold">handlers</emphasis>.</para>
      </listitem>

      <listitem>
        <para>The handler processes events creating <emphasis
        role="bold">actions</emphasis>.</para>
      </listitem>

      <listitem>
        <para>Each action may render one or more HTML <emphasis
        role="bold">components</emphasis> in the page.</para>
      </listitem>

      <listitem>
        <para>At the end, actions are canalised into an Ajax <emphasis
        role="bold">response</emphasis> sent back to the web page.</para>
      </listitem>
    </orderedlist>

    <para>We'll take a more detailed look at each of the concepts above in the
    next section.</para>
  </sect2>

  <sect2 id="ajax-base">
    <title id="ajax-base-title">Base Concepts</title>

    <sect3 id="ajax-events">
      <title id="ajax-events-title">Ajax Events</title>

      <para>In XT Ajax Framework you can raise events from your web pages as
      standard <ulink
      url="http://www.w3schools.com/js/js_events.asp"><citetitle>JavaScript
      events</citetitle></ulink>, and handle them by the server side,
      <emphasis role="bold">without having to write any javascript
      code</emphasis>. There are actually two types of Ajax events:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Action events</emphasis>, a generic
          event type directly handled by configured <link
          linkend="ajax-handlers">handlers</link> <emphasis
          role="bold">without</emphasis> passing control to any Spring MVC
          controller: this is most used for updating the web page with data
          from the server.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Submit events</emphasis>, a special type
          of event handled by configured <link
          linkend="ajax-handlers">handlers</link> <emphasis
          role="bold">after</emphasis> having executed the on submit method of
          the Spring MVC controller associated with the page: this event
          causes the submit of the page and so the handling of the submit by
          the controller, and can be used for further processing the submit in
          order to properly updating the view.</para>
        </listitem>
      </itemizedlist>

      <para>Ajax <emphasis role="bold">action events</emphasis> are basically
      fired in web pages as follows:</para>

      <programlisting>
&lt;input type="button" value="Go" 
    onclick="<emphasis role="bold">XT.doAjaxAction</emphasis>(event-id, source-element, server-parameters, client-parameters);"&gt; 
</programlisting>

      <para>You have to simply call the <emphasis
      role="bold">XT.doAjaxAction</emphasis> JavaScript function,
      passing:</para>

      <itemizedlist>
        <listitem>
          <para>The <emphasis role="bold">name</emphasis> (also called
          <emphasis role="bold">id</emphasis>) of the event you want to fire
          (<emphasis>event-id</emphasis>, required).</para>
        </listitem>

        <listitem>
          <para>The HTML element which fired the event, most of the time
          through the <emphasis role="bold">this</emphasis> objects
          (<emphasis>source-element</emphasis>, optional).</para>
        </listitem>

        <listitem>
          <para>A <ulink
          url="http://www.json.org/"><citetitle>JSON</citetitle></ulink>
          object containing extra parameters to pass to the server
          (<emphasis>server-parameters</emphasis>, optional).</para>
        </listitem>

        <listitem>
          <para>A <ulink
          url="http://www.json.org/"><citetitle>JSON</citetitle></ulink>
          object containing extra parameters for configuring the client side
          Ajax call (c<emphasis>lient-parameters</emphasis>, optional).</para>
        </listitem>
      </itemizedlist>

      <warning>
        <para>The old way of executing an Ajax action, through the <emphasis
        role="bold">doAjaxAction</emphasis> JavaScript function, is since
        version 0.8 <emphasis role="bold">no more supported</emphasis>.</para>
      </warning>

      <para>Once you receive the event in your server side handler, you can
      access the following information (see XT javadocs for more
      information):</para>

      <itemizedlist>
        <listitem>
          <para>The event id (corresponding to the event name above).</para>
        </listitem>

        <listitem>
          <para>The Java <ulink
          url="http://java.sun.com/j2ee/1.4/docs/api/javax/servlet/ServletRequest.html"><citetitle>HttpServletRequest</citetitle></ulink>
          object.</para>
        </listitem>

        <listitem>
          <para>The name and id of the HTML element firing the event.</para>
        </listitem>

        <listitem>
          <para>A map of string key/value pairs, containing the extra
          parameters defined above as
          <emphasis>server-parameters</emphasis>.</para>
        </listitem>

        <listitem>
          <para>The command object created by the Spring MVC
          controller.</para>
        </listitem>
      </itemizedlist>

      <para>Here are the Java interfaces:</para>

      <programlisting>
public interface AjaxEvent {

    public String getEventId();

    public HttpServletRequest getHttpRequest();

    public String getElementName();

    public void setElementName(String elementName);

    public String getElementId();

    public void setElementId(String elementName);

    public Map&lt;String, String&gt; getParameters();

    public void setParameters(Map&lt;String, String&gt; parameters);
}
</programlisting>

      <programlisting>
public interface AjaxActionEvent extends AjaxEvent {

    public Object getCommandObject();

    public void setCommandObject(Object command);
}
</programlisting>

      <para>For firing Ajax <emphasis role="bold">submit events</emphasis>,
      you have to basically write:</para>

      <programlisting>
&lt;input type="button" value="Press" 
    onclick="<emphasis role="bold">XT.doAjaxSubmit</emphasis>(event-id, source-element, server-parameters, client-parameters);"&gt; 
</programlisting>

      <para>You have to simply call the <emphasis
      role="bold">XT.doAjaxSubmit</emphasis> JavaScript function, passing it
      the same information defined above.</para>

      <warning>
        <para>The old way of executing an Ajax submit, through the <emphasis
        role="bold">doAjaxSubmit</emphasis> JavaScript function, is since
        version 0.8 <emphasis role="bold">no more supported</emphasis>.</para>
      </warning>

      <para>Once you receive the event in your server side handler, you can
      access the following information in addition to those defined above (see
      XT javadocs for more information):</para>

      <itemizedlist>
        <listitem>
          <para>The <ulink
          url="http://static.springframework.org/spring/docs/1.2.x/api/org/springframework/validation/Errors.html"><citetitle>validation
          errors</citetitle></ulink>, for managing form submission errors (if
          any).</para>
        </listitem>

        <listitem>
          <para>The model map returned by the controller submit method (if
          any).</para>
        </listitem>
      </itemizedlist>

      <para>Here are the Java interfaces:</para>

      <programlisting>
public interface AjaxSubmitEvent extends AjaxEvent {

    public Errors getValidationErrors();

    public void setValidationErrors(Errors errors);

    public Object getCommandObject();

    public void setCommandObject(Object command);

    public Map getModel();

    public void setModel(Map model);
}
</programlisting>

      <note>
        <para>Given that submit events are handled after calling the
        configured Spring MVC controller, the command object, model map, and
        validation errors contained in the submit event are <emphasis
        role="bold">the same</emphasis> objects you manage in the
        controller.</para>
      </note>

      <important>
        <para><emphasis>How to access the command object and validation errors
        outside of Spring MVC environments?</emphasis></para>

        <para>The XT Ajax Framework is by default configured for working with
        Spring MVC, so in order to access the command object and validation
        errors the MVC controller must adhere to the requirements provided by
        the <emphasis>org.springmodules.xt.ajax.MVCFormDataAccessor</emphasis>
        class (see related javadocs for details). If you want to use our
        framework in other environments, like Spring Web Flow, you have to
        implement a proper
        <emphasis>org.springmodules.xt.ajax.FormDataAccessor</emphasis> and
        set it into the
        <emphasis>org.springmodules.xt.ajax.AjaxInterceptor</emphasis> (again,
        see related javadocs for details).</para>
      </important>

      <important>
        <para><emphasis>Why are the command object and model map contained
        into the AjaxSubmitEvent null?</emphasis></para>

        <para>This is probably because your Spring MVC Controller submit
        method missed to return a proper ModelAndView object containing the
        BindException model; for helping that, you are strongly encouraged to
        construct and return an <emphasis
        role="bold">AjaxModelAndView</emphasis> object (see
        <emphasis>org.springmodules.xt.ajax.web.servlet.AjaxModelAndView</emphasis>
        javadoc).</para>
      </important>

      <para>Under the hood, Ajax action events are nothing more than
      asynchronous GET requests, while Ajax submit events are asynchronous PUT
      requests.</para>

      <para>If there are some web forms in the page, the Ajax request sends by
      default all values belonging to the first form in the page. If you have
      just one form in your page, all form values will be automatically sent
      with the Ajax event, so you have nothing special to do. If you have more
      than one form, and you want to send values belonging to a specifically
      named form, you have to specify the form name between client
      parameters:</para>

      <programlisting>XT.doAjaxAction(event-id, source-element, server-parameters, <emphasis
          role="bold">{'formName' : 'form_name'}</emphasis>);
XT.doAjaxSubmit(event-id, source-element, server-parameters, <emphasis
          role="bold"><emphasis role="bold">{'formName' : 'form_name'}</emphasis></emphasis>); </programlisting>

      <para>Moreover, in order to be XHTML strict compatible, you can use the
      form id instead:</para>

      <programlisting>XT.doAjaxAction(event-id, source-element, server-parameters, <emphasis
          role="bold">{'formId' : 'form_id'}</emphasis>);
XT.doAjaxSubmit(event-id, source-element, server-parameters, <emphasis
          role="bold"><emphasis role="bold">{'formId' : 'form_id'}</emphasis></emphasis>); </programlisting>

      <para>Now you have enough information about how to fire events by the
      client side, and how they are represented by the server side. Let's talk
      about how to <emphasis role="bold">handle</emphasis> them.</para>
    </sect3>

    <sect3 id="ajax-handlers">
      <title id="ajax-handlers-title">Ajax Handlers</title>

      <para>The Ajax handler is the server side component to implement for
      processing Ajax events. Here is its interface, followed by a description
      of its methods:</para>

      <programlisting>
public interface AjaxHandler { 

    public boolean supports(AjaxEvent event); 

    public AjaxResponse handle(AjaxEvent event); 
} 
</programlisting>

      <itemizedlist>
        <listitem>
          <para><emphasis>public boolean supports(AjaxEvent event)</emphasis>
          : Check if <emphasis>this</emphasis> handler supports (can handle)
          the given <emphasis role="bold">AjaxEvent</emphasis></para>
        </listitem>

        <listitem>
          <para><emphasis>public AjaxResponse handle(AjaxEvent
          event)</emphasis> : Handle the given <emphasis
          role="bold">AjaxEvent</emphasis> (if supported) and return an
          appropriate <emphasis role="bold">AjaxResponse</emphasis> (see <link
          linkend="ajax-response">Ajax Response</link>).</para>
        </listitem>
      </itemizedlist>

      <para>Out of the box, XT Ajax Framework provides an AjaxHandler abstract
      implementation which provides a straightforward way of implementing Ajax
      handlers: the <emphasis
      role="bold">org.springmodules.xt.ajax.AbstractAjaxHandler</emphasis>.</para>

      <para>AbstractAjaxHandler is an event dispatcher based on Java
      reflection and Ajax events name (<emphasis>id</emphasis>): it implements
      the two methods above by dispatching events to methods named after the
      event id. So, for handling different events, you have to simply
      implement a method named after the event id you want to handle, with the
      following signature:</para>

      <programlisting>
public AjaxResponse eventId(AjaxEvent )
</programlisting>

      <para>Given an Ajax event with id <emphasis>countrySelection</emphasis>,
      the handling method will be:</para>

      <programlisting>
public AjaxResponse countrySelection(AjaxEvent )
</programlisting>

      <para>Doing so, you handle generic <emphasis>AjaxEvent</emphasis>s. If
      you want to handle <emphasis>AjaxActionEvent</emphasis>s or
      <emphasis>AjaxSubmitEvent</emphasis>s, simply write methods with the
      following signatures:</para>

      <programlisting>
public AjaxResponse eventId(AjaxActionEvent )
</programlisting>

      <programlisting>
public AjaxResponse eventId(AjaxSubmitEvent )
</programlisting>

      <para>However, you are free to implement a different handling strategy,
      directly implementing the interface above.</para>

      <note>
        <para>When returning from an handler, if you don't want to send any
        response you can safely return a null AjaxResponse. What happens after
        that depends on the kind of event you are handling; see the section:
        <link linkend="ajax-flow">More about the Ajax request processing
        flow</link></para>
      </note>
    </sect3>

    <sect3 id="associating-events-with-handlers">
      <title id="associating-events-with-handlers-title">Associating events
      with handlers: the AjaxInterceptor</title>

      <para>Once defined your events and implemented your handlers, you need
      to <emphasis role="bold">associate</emphasis> them.</para>

      <para>For <emphasis role="bold">security reasons</emphasis>, web page
      events and Ajax handlers are not automatically associated, nor can be
      globally associated. If it were so, malicious users could hack your
      JavaScript and execute unwanted events.</para>

      <para>So, events and handlers are associated <emphasis role="bold">per
      page path</emphasis>, that is, you have to configure every handler to
      manage events fired by a pre-determined, restricted, set of pages.
      Specifically, you can configure an handler to manage events fired by a
      specific, single, web page, or by a set of web pages defined with <ulink
      url="http://ant.apache.org"><citetitle>Ant</citetitle></ulink> style
      pattern matching.</para>

      <para>This is done in two simple steps.</para>

      <para>First, you have to define in your Spring application context an
      <emphasis role="bold">AjaxInterceptor</emphasis>: it is the bean which
      associates web pages and Ajax handlers, making under the cover the
      actual event dispatching. Here is an example of AjaxInterceptor
      configuration:</para>

      <programlisting>
&lt;bean id="ajaxInterceptor" class="org.springmodules.xt.ajax.AjaxInterceptor"&gt;

    <emphasis role="bold">&lt;property name="handlerMappings"&gt;
        &lt;props&gt;
            &lt;prop key="/ajax/ex*"&gt;genericAjaxHandler&lt;/prop&gt;
            &lt;prop key="/ajax/ex1.page"&gt;ajaxHandler1&lt;/prop&gt;
            &lt;prop key="/ajax/ex2.page"&gt;ajaxHandler2, ajaxHandler3&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;</emphasis>

&lt;/bean&gt;
</programlisting>

      <para>The <emphasis>handlerMappings</emphasis> property is a list of
      key/value entries associating <emphasis role="bold">a web
      path</emphasis> (the key) <emphasis role="bold">with a comma separated
      list of handlers</emphasis> (the value), which must be declared as beans
      in the Spring application context.As you can notice, the first entry
      associates an handler with an Ant style pattern, the second associates a
      single page with a single handler, the third associates a single page
      with two handlers. So, you can also apply more handlers to the same
      group of pages (or page). When more handlers apply to the same event,
      the one configured for matching the longest web path wins.</para>

      <para>Finally, the second step requires you to associate the
      AjaxInterceptor with the interceptors chain of your Spring MVC <ulink
      url="http://static.springframework.org/spring/docs/1.2.x/api/org/springframework/web/servlet/HandlerMapping.html"><citetitle>URL
      handler mapping</citetitle></ulink>. Here is how:</para>

      <programlisting>
&lt;bean id="urlHandlerMapping" class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;

    <emphasis role="bold">&lt;property name="interceptors"&gt;
        &lt;list&gt;
            &lt;ref bean="ajaxInterceptor"/&gt;
        &lt;/list&gt;
    &lt;/property&gt;</emphasis>

    &lt;property name="mappings"&gt;
        &lt;props&gt;
        &lt;!-- ... --&gt;
        &lt;/props&gt;
    &lt;/property&gt;

&lt;/bean&gt;
</programlisting>
    </sect3>

    <sect3 id="ajax-actions">
      <title id="ajax-actions-title">Ajax Actions</title>

      <para>Ajax actions are created by handlers and act on client web
      pages.</para>

      <para>XT Ajax Framework provides many useful actions ready to be used:
      see the <emphasis>org.springmodules.xt.ajax.action</emphasis> package
      for details; however, creating custom actions is just a matter of
      implementing the following simple interface:</para>

      <programlisting>
public interface AjaxAction { 

    public String render(); 
} 
</programlisting>

      <para>The <emphasis>render()</emphasis> method is the one you call for
      producing the action result.</para>

      <para>However, all actions that render data into the web page implement
      the following interface:</para>

      <programlisting>
public interface AjaxRenderingAction extends AjaxAction {

    public ElementMatcher getElementMatcher();
}</programlisting>

      <para>So, there are actions that render data into the web page,
      modifying page parts, but ... <emphasis role="bold">how can actions
      identify page parts to modify</emphasis>?</para>
    </sect3>

    <sect3 id="identifying-page-parts">
      <title id="identifying-page-parts-title">Identifying page parts:
      ElementMatchers.</title>

      <para>Ajax actions that render data into the web page are all
      implementations of the
      <emphasis>org.springmodules.xt.ajax.AjaxRenderingAction</emphasis>
      interface.</para>

      <para>By default, Ajax actions that need to identify page parts to
      modify use the HTML <emphasis role="bold"><emphasis
      role="bold">id</emphasis> </emphasis>attribute. So, assigning an
      identifier to your HTML elements is a way to make Ajax actions identify
      them:</para>

      <programlisting>
&lt;select id="toFill"&gt;
&lt;/select&gt;
</programlisting>

      <para>However, Ajax actions are not limited to HTML identifiers.</para>

      <para>More specifically, <emphasis role="bold">all actions that modify
      page contents must use either</emphasis>:</para>

      <itemizedlist>
        <listitem>
          <para>The element identifier (as previously stated).</para>
        </listitem>

        <listitem>
          <para>An
          <emphasis>org.springmodules.xt.ajax.ElementMatcher</emphasis>
          implementation.</para>
        </listitem>
      </itemizedlist>

      <para>ElementMatchers are a flexible way of identifying page parts by
      matching elements with different strategies. There are several
      ElementMatchers:</para>

      <variablelist>
        <varlistentry>
          <term>org.springmodules.xt.ajax.action.matcher.DefaultMatcher</term>

          <listitem>
            <para>The DefaultMatcher matches a single element by its
            identifier. It is the default matcher used by actions that
            directly use element identifiers (as stated above).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>org.springmodules.xt.ajax.action.matcher.ListMatcher</term>

          <listitem>
            <para>The ListMatcher matches multiple elements against a list of
            identifiers.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>org.springmodules.xt.ajax.action.matcher.WildcardMatcher</term>

          <listitem>
            <para>The WildcardMatcher matches multiple elements whose
            identifier starts with a substring of a given source identifier
            and ends with the "_"<emphasis role="bold">
            (underscore)</emphasis> wildcard; for instance, a WildcardMatcher
            with the "foo.bar" id to match, will match an element with a
            "foo.bar" id, and an element with the "foo_" id too.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>org.springmodules.xt.ajax.action.matcher.SelectorMatcher</term>

          <listitem>
            <para>The SelectorMatcher matches multiple elements identified by
            a list of <ulink
            url="http://www.w3.org/TR/REC-CSS2/selector.html">CSS2</ulink>/<ulink
            url="http://www.w3.org/TR/css3-selectors/">CSS3</ulink> Selectors
            (see the org.springmodules.xt.ajax.action.matcher.SelectorMatcher
            javadoc for supported selectors).</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>See javadocs of the classes above for additional details.</para>
    </sect3>

    <sect3 id="components">
      <title id="components-title">Components</title>

      <para>Generally speaking, <emphasis role="bold">components</emphasis>
      represent web page parts; more specifically, most of the time they
      represent HTML elements, like input fields, tables and so.</para>

      <para>XT Ajax Framework provides many useful components ready to be
      used:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Static components</emphasis>,
          representing simple, static, HTML elements (see the
          <emphasis>org.springmodules.xt.ajax.component</emphasis> package for
          details).</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Dynamic components</emphasis>, capable
          of dynamically rendering page parts (see the
          <emphasis>org.springmodules.xt.ajax.component.dynamic</emphasis>
          package for details).</para>
        </listitem>
      </itemizedlist>

      <para>However, creating custom components is just a matter of
      implementing the following simple interface:</para>

      <programlisting>
public interface Component { 

    public String render(); 
} 
</programlisting>

      <para>Each component renders itself through the <emphasis
      role="bold">render()</emphasis> method, returning a string
      representation of its rendering.</para>

      <para>But how do actions render components?</para>

      <para>Components are added to actions in a way that depends on the
      concrete action implementation, and then rendered through the action
      <emphasis>execute()</emphasis> method.</para>

      <para>Now that you have your Ajax actions and components, the only thing
      left to do is filling your <link linkend="ajax-response">Ajax
      response</link>.</para>
    </sect3>

    <sect3 id="ajax-response">
      <title id="ajax-response-title">Ajax Response</title>

      <para><emphasis role="bold">AjaxResponse</emphasis> objects are filled
      with actions whose result is carried to clients, that is, to web pages.
      This is the interface of the AjaxResponse, followed by a description of
      its methods:</para>

      <programlisting>
public interface AjaxResponse { 

    public void addAction(AjaxAction action); 

    public String render(); 

    public String getEncoding();

    public boolean isEmpty();
} 
</programlisting>

      <itemizedlist>
        <listitem>
          <para><emphasis>public void addAction(AjaxAction action)</emphasis>
          : This method is used for adding actions that will be executed and
          whose result will be sent to the client.</para>
        </listitem>

        <listitem>
          <para><emphasis>public String render()</emphasis> : This method
          renders the added actions and returns the result.</para>
        </listitem>

        <listitem>
          <para><emphasis>public String getEncoding()</emphasis> : This method
          returns the charset name of the encoding to use for the
          response.</para>
        </listitem>

        <listitem>
          <para><emphasis>public boolean isEmpty()</emphasis> : This method
          tells if the response has no actions to return.</para>
        </listitem>
      </itemizedlist>

      <note>
        <para>The default encoding of the Ajax response is ISO-8859-1. Just
        use a proper
        <emphasis>org.springmodules.xt.ajax.AjaxResponseImpl</emphasis>
        constructor for changing it.</para>
      </note>

      <note>
        <para>In the context of an Ajax response, actions are rendered (and
        executed client side) <emphasis role="bold">following their order of
        adding</emphasis>.</para>
      </note>
    </sect3>

    <sect3 id="ajax-flow">
      <title id="ajax-flow-title">More about the Ajax request processing
      flow</title>

      <para>As seen above, Ajax handlers process events, dispatched by the
      AjaxInterceptor, and return an appropriate AjaxResponse.</para>

      <para>Here is a more schematic, detailed look at the Ajax request
      processing flow.</para>

      <para><emphasis role="bold">On Ajax Action Events :</emphasis></para>

      <orderedlist>
        <listitem>
          <para>The web page fires an Ajax action event.</para>
        </listitem>

        <listitem>
          <para>The event is directly dispatched by the AjaxInterceptor toward
          a configured AjaxHandler.</para>
        </listitem>

        <listitem>
          <para>If no handler supporting the event is found, an exception is
          thrown, else if the event is supported by a proper handler, it is
          handled.</para>
        </listitem>

        <listitem>
          <para>After handling, if the handler returns a not null and not
          empty AjaxResponse, it is actually rendered. Anyway, <emphasis
          role="bold">since version 0.9</emphasis>, the AjaxInterceptor
          <emphasis role="bold">stops</emphasis> the execution chain after
          processing any Ajax request.</para>
        </listitem>
      </orderedlist>

      <important>
        <para>Since 0.9 version, the AjaxInterceptor stops the execution chain
        <emphasis role="bold">even after</emphasis> an empty or null
        AjaxResponse.</para>
      </important>

      <para><emphasis role="bold">On Ajax Submit Events :</emphasis></para>

      <orderedlist>
        <listitem>
          <para>The web page fires an Ajax submit event, causing a form
          submit.</para>
        </listitem>

        <listitem>
          <para>The (eventually) configured Spring MVC Controller is
          called.</para>
        </listitem>

        <listitem>
          <para>The Spring MVC Controller handles the form submit, eventually
          calling Validators and making other actions. At the end, it must
          return a ModelAndView with the model contained into the
          BindException object; otherwise, the model and command objects into
          the Ajax event object will be null. You can use the <emphasis
          role="bold">AjaxModelAndView</emphasis> object here (see
          <emphasis>org.springmodules.xt.ajax.web.servlet.AjaxModelAndView</emphasis>
          javadoc).</para>
        </listitem>

        <listitem>
          <para>After the Controller handling, the event is dispatched by the
          AjaxInterceptor toward a configured AjaxHandler.</para>
        </listitem>

        <listitem>
          <para>If no handler supporting the event is found, an exception is
          thrown, else if the event is supported by a proper handler, it is
          handled.</para>
        </listitem>

        <listitem>
          <para>After handling, if the handler returns a not null and not
          empty AjaxResponse, it is rendered; otherwise the AjaxInterceptor
          automatically tries to redirect to the view configured in your
          ModelAndView object. The view must contain the <emphasis
          role="bold">ajax-redirect</emphasis> prefix (i.e. :
          <emphasis>ajax-redirect:/start.page</emphasis>) or the standard
          <emphasis role="bold">redirect</emphasis> prefix (i.e. :
          <emphasis>redirect:/start.page</emphasis>); if the view doesn't
          contain such prefixes, an exception is thrown.</para>
        </listitem>
      </orderedlist>
    </sect3>

    <sect3 id="handling-exceptions">
      <title id="handling-exceptions-title">Handling exceptions</title>

      <para>Spring MVC deals with exceptions occurred during request
      processing by using <ulink
      url="http://static.springframework.org/spring/docs/2.0.x/api/org/springframework/web/servlet/HandlerExceptionResolver.html">HandlerExceptionResolver</ulink>s.</para>

      <para>The XT Ajax Framework deals with exceptions occurred during Ajax
      requests in the same way, by using a special HandlerExceptionResolver:
      the <emphasis
      role="bold">org.springmodules.xt.ajax.AjaxExceptionHandlerResolver.
      </emphasis></para>

      <para>It works by mapping exception classes to instances of <emphasis
      role="bold">AjaxExceptionHandler</emphasis> beans (see
      <emphasis>org.springmodules.xt.ajax.AjaxExceptionHandler</emphasis>
      javadoc) configured in the Spring context.</para>

      <para>Here is a sample AjaxExceptionHandlerResolver configuration
      snippet:</para>

      <programlisting>
&lt;bean id="ajaxExceptionResolver" class="<emphasis role="bold">org.springmodules.xt.ajax.AjaxExceptionHandlerResolver</emphasis>"&gt;
    &lt;property name="exceptionMappings"&gt;
        &lt;map&gt;
            <emphasis role="bold">&lt;entry key="java.lang.Exception" value-ref="exceptionHandler"/&gt;</emphasis>
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</programlisting>

      <para>The AjaxExceptionHandler bean then takes care of resolving the
      exception to an AjaxResponse to send to clients. Here is its
      interface:</para>

      <programlisting>
public interface AjaxExceptionHandler {

    public AjaxResponse handle(HttpServletRequest request, Exception ex);
}
</programlisting>

      <para>Out of the box, XT Ajax Framework provides the <emphasis
      role="bold">RedirectExceptionHandler</emphasis> (see
      <emphasis>org.springmodules.xt.ajax.support.RedirectExceptionHandler</emphasis>
      javadoc), an AjaxExceptionHandler implementation for redirecting to a
      given error page. Here is a sample configuration snippet:</para>

      <programlisting>
&lt;bean id="exceptionHandler" class="<emphasis role="bold">org.springmodules.xt.ajax.support.RedirectExceptionHandler</emphasis>"&gt;
    &lt;property name="redirectUrl" value="/error.page"/&gt;
    &lt;property name="exceptionMessageAttribute" value="exceptionMessage"/&gt;
&lt;/bean&gt;
</programlisting>

      <warning>
        <para>Since 0.9 version, the old
        <emphasis>org.springmodules.xt.ajax.AjaxExceptionHandler</emphasis> is
        now called
        <emphasis>org.springmodules.xt.ajax.AjaxExceptionHandlerResolver</emphasis>,
        while the old
        <emphasis>org.springmodules.xt.ajax.AjaxExceptionResolver
        </emphasis>and
        <emphasis>org.springmodules.xt.ajax.support.RedirectExceptionResolver</emphasis>
        are respectively called
        <emphasis>org.springmodules.xt.ajax.AjaxExceptionHandler</emphasis>
        and
        <emphasis>org.springmodules.xt.ajax.support.RedirectExceptionHandler</emphasis>.</para>
      </warning>
    </sect3>

    <sect3 id="loading-sign">
      <title id="loading-sign-title">Showing feedback to users : loading sign
      management</title>

      <para>Ajax requests are asynchronous, and while they're processed users
      are free to continue interacting with the web page.</para>

      <para>It's often important to give users a feedback about the Ajax
      request loading time: XT Ajax let you easily configure a
      <emphasis>loading sign</emphasis>, that is, <emphasis role="bold">an
      image that will be automatically shown during Ajax request
      processing</emphasis>.</para>

      <para>The loading sign is configured by simply choosing the identifier
      of the element where the loading sign will be shown, and the URL of the
      image to show. You have two different configuration option:</para>

      <variablelist>
        <varlistentry>
          <term>Per Page configuration</term>

          <listitem>
            <para>By using the per page configuration, every Ajax request will
            show the same image in the same element into the page.</para>

            <para>The identifier of the element where to show the loading sign
            must be assigned to the following Javascript variable:</para>

            <programlisting>XT.defaultLoadingElementId</programlisting>

            <para>While the image URL must be assigned to the following
            Javascript variable:</para>

            <programlisting>XT.defaultLoadingImage</programlisting>

            <para>So, just load a Javascript file with the following
            assignments:</para>

            <programlisting>XT.defaultLoadingElementId = "..."
XT.defaultLoadingImage = "..."</programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Per Request Configuration</term>

          <listitem>
            <para>By using the per request configuration, every Ajax request
            will be able to show a different image in a different element into
            the page.</para>

            <para>Every Ajax request must specify its own loading element and
            image by putting the following information between
            <emphasis>client parameters</emphasis>:</para>

            <programlisting>XT.doAjaxAction(event-id, source-element, server-parameters, <emphasis
                role="bold">{'loadingElementId' : '...', 'loadingImage' : '...'}</emphasis>);
XT.doAjaxSubmit(event-id, source-element, server-parameters, <emphasis
                role="bold">{'loadingElementId' : '...', 'loadingImage' : '...'}</emphasis>); </programlisting>

            <para>As you can see, you have to specify the following
            parameters:</para>

            <itemizedlist>
              <listitem>
                <para><emphasis>loadingElementId</emphasis> : The id of the
                element where the image will be shown during the processing of
                the Ajax request related to <emphasis>this</emphasis>
                event.</para>
              </listitem>

              <listitem>
                <para><emphasis>loadingImage</emphasis> : The URL of the image
                to show during the processing of the Ajax request related to
                <emphasis>this</emphasis> event.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>You can use both per page and per request configuration options:
      the latter will prevail on the former.</para>

      <tip>
        <para>For awesome effects, we strongly suggest to use gif images; you
        can find great loading gif images <ulink
        url="http://www.ajaxload.info/"><citetitle>here.</citetitle></ulink></para>
      </tip>
    </sect3>

    <sect3 id="handling-js-errors">
      <title id="handling-js-errors-title">Handling Javascript errors</title>

      <para>By default, Javascript errors occurring during client-side Ajax
      request processing doesn't get handled.</para>

      <para>However, you can handle them by configuring a proper <emphasis
      role="bold">error handler function. </emphasis></para>

      <para>As with the loading sign configuration described in the previous
      section, you have two different configuration option:</para>

      <variablelist>
        <varlistentry>
          <term>Per Page configuration</term>

          <listitem>
            <para>By using the per page configuration, every Ajax request will
            use the same error handler function.</para>

            <para>You have to simply configure the following property of the
            <emphasis>XT</emphasis> javascript object:</para>

            <programlisting>XT.defaultErrorHandler = <emphasis>your_function_name</emphasis></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Per Request Configuration</term>

          <listitem>
            <para>By using the per request configuration, every Ajax request
            will use a different error handler function.</para>

            <para>Every Ajax request must specify its own function by putting
            the following information between <emphasis>client
            parameters</emphasis>:</para>

            <programlisting>XT.doAjaxAction(event-id, source-element, server-parameters, <emphasis
                role="bold">{'errorHandler' : your_function_name}</emphasis>);
XT.doAjaxSubmit(event-id, source-element, server-parameters, <emphasis
                role="bold"><emphasis role="bold">{'errorHandler' : your_function_name}</emphasis></emphasis>); </programlisting>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>You can use both per page and per request configuration options:
      the latter will prevail on the former.</para>

      <para>Finally, the error handler function should look like the
      following:</para>

      <programlisting>function yourFunction(ajaxRequest, exception) {
    // ...
}</programlisting>

      <para>As you can see, your function will have to accept two parameters:
      the ajax request object and the exception object.</para>
    </sect3>

    <sect3 id="file-uploading">
      <title id="file-uploading-title">Uploading files</title>

      <para>XT Ajax transparently supports file uploading in Ajax enabled
      forms.</para>

      <para>Uploading a file through Ajax is just a matter of sending an Ajax
      submit request configured as follows:</para>

      <programlisting>XT.doAjaxSubmit(event-id, source-element, server-parameters, <emphasis
          role="bold">{'enableUpload' : true}</emphasis>)</programlisting>

      <para>You have to set the <emphasis>enableUpload</emphasis> Ajax client
      parameter to <emphasis>true</emphasis>: that's all. XT Ajax will
      transparently do the rest.</para>
    </sect3>
  </sect2>

  <sect2>
    <title>Advanced Concepts</title>

    <sect3>
      <title>Core Javascript libraries</title>

      <para>The client side API of the XT Ajax Framework is based on the
      <ulink
      url="http://taconite.sourceforge.net"><citetitle>Taconite</citetitle></ulink>
      and <ulink
      url="http://www.json.org/js.html"><citetitle>JSON</citetitle></ulink>
      JavaScript libraries, plus some other JavaScript stuff.</para>

      <para>These are the core XT Ajax Javascript libraries: you can find them
      under the <emphasis>js</emphasis> directory.</para>

      <para>They are put, at compile time, in the <emphasis
      role="bold">springxt.js</emphasis> file under the
      <emphasis>js/lib/core</emphasis> directory. This is the only <emphasis
      role="bold">mandatory</emphasis> file you need to include in your web
      page:</para>

      <programlisting>
&lt;script type="text/javascript" src='springxt.js'&gt;&lt;/script&gt; 
</programlisting>

      <tip>
        <para>Under the <emphasis>js/lib/core</emphasis> you'll find also a
        <emphasis role="bold">springxt-min.js</emphasis> file: it is a
        minified version of <emphasis>springxt.js</emphasis> you can include
        in your pages for reducing the download size.</para>
      </tip>
    </sect3>

    <sect3>
      <title>Optional Javascript libraries</title>

      <para>XT Ajax Framework integrates with a number of other Javascript
      libraries, in order to provide additional Ajax functionalities:</para>

      <itemizedlist>
        <listitem>
          <para><ulink
          url="http://prototype.conio.net/"><citetitle>Prototype</citetitle></ulink>
          (version 1.5.0 rc1 or higher) : see javadocs for the
          <emphasis>org.springmodules.xt.ajax.action.prototype</emphasis>
          classes.</para>
        </listitem>

        <listitem>
          <para><ulink
          url="http://script.aculo.us/"><citetitle>Script.aculo.us</citetitle></ulink>
          (version 1.6.4 or higher) : see javadocs for the
          <emphasis>org.springmodules.xt.ajax.action.prototype.scriptaculous</emphasis>
          classes.</para>
        </listitem>

        <listitem>
          <para><ulink
          url="http://www.bennolan.com/behaviour/"><emphasis>Behaviour</emphasis></ulink>
          (version 1.1 or higher) : see javadocs for the
          <emphasis>org.springmodules.xt.ajax.action.behaviour</emphasis>
          classes.</para>
        </listitem>
      </itemizedlist>
    </sect3>
  </sect2>

  <sect2 id="ajax-tutorials">
    <title id="ajax-tutorials-title">Tutorials</title>

    <para>In this section we'll show you, by practical, step-by-step
    tutorials, how to work with XT Ajax Framework. All tutorials are based on
    XT Ajax samples: take a look at the samples provided with the main
    distribution or <ulink
    url="https://springmodules.dev.java.net/source/browse/springmodules/samples/xt/"><citetitle>check
    out them</citetitle></ulink> if you want to take a look at the full source
    code.</para>

    <sect3 id="ajax-tutorial-1">
      <title id="ajax-tutorial-1-title">Working with Ajax action
      events</title>

      <para>Ajax action events are used for updating pages without submitting
      data to (eventually configured) Spring MVC controllers: so, <emphasis
      role="bold">the execution of an Ajax action event doesn't call
      controllers</emphasis>.</para>

      <para>In this tutorial we'll implement a simple Ajax sample that let you
      <emphasis role="bold">fill a selection box with a list of Office names
      after clicking a button</emphasis>, showing you how to:</para>

      <itemizedlist>
        <listitem>
          <para>Write the web page.</para>
        </listitem>

        <listitem>
          <para>Write the Ajax handler.</para>
        </listitem>

        <listitem>
          <para>Map the Ajax handler to the web page URL.</para>
        </listitem>
      </itemizedlist>

      <sect4 id="ajax-tutorial-1-step-1">
        <title>Step 1 : Writing the web page</title>

        <para>Writing a web page that fires an Ajax action event is not
        different than writing a normal JSP based web page as you'd usually
        do.</para>

        <para>First, import the core XT Ajax javascript library:</para>

        <programlisting>
&lt;script type="text/javascript" src='<emphasis role="bold">springxt.js</emphasis>'&gt;&lt;/script&gt;
</programlisting>

        <para>Our web page must fill the selection list after clicking a
        button. So, write a button input field that fires an Ajax action event
        with <emphasis>loadOffices</emphasis> as event id:</para>

        <programlisting>
&lt;input type="button" value="Press" onclick="<emphasis role="bold">XT.doAjaxAction('loadOffices', this);</emphasis>"&gt; 
</programlisting>

        <para>Then, write the <emphasis>select</emphasis> HTML element to
        update and give it an id:</para>

        <programlisting>
&lt;select id="<emphasis role="bold">offices</emphasis>"&gt;
    &lt;option&gt;--- ---&lt;/option&gt;
&lt;/select&gt;
</programlisting>

        <para>Recall that the <emphasis>id</emphasis> attribute is used for
        identifying the page part to update, that is, the element to fill with
        new content.</para>

        <para>That's all ... let's write our Ajax handler!</para>
      </sect4>

      <sect4 id="ajax-tutorial-1-step-2">
        <title>Step 2 : Writing the Ajax handler</title>

        <para>Our Ajax handler will extend the
        <emphasis>org.springmodules.xt.ajax.AbstractAjaxHandler</emphasis>, so
        it will have a method called after the Ajax event to handle, that will
        accept an
        <emphasis>org.springmodules.xt.ajax.AjaxActionEvent</emphasis>:</para>

        <programlisting>
public AjaxResponse <emphasis role="bold">loadOffices</emphasis>(AjaxActionEvent event)
</programlisting>

        <para>Now, let us analyze how to handle the event, by implementing the
        <emphasis>loadOffices</emphasis> method above.</para>

        <para>First, we have to retrieve a list of offices from some kind of
        data access object:</para>

        <programlisting>
Collection&lt;IOffice&gt; offices = store.getOffices();
</programlisting>

        <para>Then, we have to create the components to render: a list of
        <emphasis>org.springmodules.xt.ajax.component.Option</emphasis>
        components, representing the <emphasis>option</emphasis> HTML elements
        and containing the office id as value and the office name as
        content.</para>

        <programlisting>
// <emphasis role="bold">Create the options list:</emphasis>
List options = new LinkedList();
// <emphasis role="bold">The first option is just a dummy one:</emphasis>
Option first = new Option("-1", "Select one ...");
options.add(first);
// <emphasis role="bold">Create options representing offices:</emphasis>
for(IOffice office : offices) {
    Option option = new Option(office, "officeId", "name");
    options.add(option);
}
</programlisting>

        <para>Now, we have to replace the HTML content of the
        <emphasis>select</emphasis> element showed above, so we have to create
        an
        <emphasis>org.springmodules.xt.ajax.action.ReplaceContentAction</emphasis>,
        adding it the components to render (the list of options):</para>

        <programlisting>
ReplaceContentAction <emphasis role="bold">action</emphasis> = new ReplaceContentAction("<emphasis
            role="bold">offices</emphasis>", options);
</programlisting>

        <para>Note that the <emphasis>ReplaceContentAction</emphasis> updates
        the HTML element with <emphasis>offices</emphasis> as id.</para>

        <para>Finally, we create an
        <emphasis>org.springmodules.xt.ajax.AjaxResponse</emphasis>, add the
        action and return it!</para>

        <programlisting>
AjaxResponse response = new AjaxResponseImpl();
response.addAction(<emphasis role="bold">action</emphasis>);
return response;
</programlisting>

        <para>That's the simple implementation of the
        <emphasis>loadOffices</emphasis> method!</para>
      </sect4>

      <sect4 id="ajax-tutorial-1-step-3">
        <title>Step 3 : Mapping the Ajax handler to the web page URL</title>

        <para>Say the web page URL is:
        <emphasis>www.example.org/xt/ajax/tutorial1.page</emphasis>. Mapping
        the Ajax handler is simply a matter of configuring the Ajax handler
        bean (<emphasis>LoadOfficesHandler</emphasis> in the snippet below) in
        the Spring application context and mapping it in the
        <emphasis>AjaxInterceptor</emphasis>:</para>

        <programlisting>
&lt;bean id="<emphasis role="bold">ajaxLoadOfficesHandler</emphasis>" class="org.springmodules.xt.examples.ajax.LoadOfficesHandler"&gt;
    &lt;property name="store" ref="store"/&gt;
&lt;/bean&gt;
</programlisting>

        <programlisting>
&lt;bean id="ajaxInterceptor" class="org.springmodules.xt.ajax.AjaxInterceptor"&gt;
    &lt;property name="handlerMappings"&gt;
        &lt;props&gt;
            <emphasis role="bold">&lt;prop key="/ajax/tutorial1.page"&gt;ajaxLoadOfficesHandler&lt;/prop&gt;</emphasis>
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</programlisting>
      </sect4>
    </sect3>

    <sect3 id="ajax-tutorial-2">
      <title id="ajax-tutorial-2-title">Working with Ajax submit
      events</title>

      <para>Ajax submit events are used for updating pages <emphasis
      role="bold">after</emphasis> submitting data to your Spring MVC
      controllers.</para>

      <para>In this tutorial we'll implement a simple Ajax sample that let you
      <emphasis role="bold">choose an office and list its employees in a table
      after submitting the form by clicking a button</emphasis>. We'll see how
      to:</para>

      <itemizedlist>
        <listitem>
          <para>Write the web page.</para>
        </listitem>

        <listitem>
          <para>Write the Spring MVC controller.</para>
        </listitem>

        <listitem>
          <para>Write the Ajax handler.</para>
        </listitem>

        <listitem>
          <para>Map the Ajax handler to the web page URL.</para>
        </listitem>
      </itemizedlist>

      <sect4 id="ajax-tutorial-2-step-1">
        <title>Step 1 : Writing the web page</title>

        <para>Writing a web page that fires a submit event is not different
        than writing a normal JSP based web page as you'd usually do.</para>

        <para>First, import the core XT Ajax javascript library:</para>

        <programlisting>
&lt;script type="text/javascript" src='<emphasis role="bold">springxt.js</emphasis>'&gt;&lt;/script&gt;
</programlisting>

        <para>Employees are listed in an HTML table after clicking a button.
        So, you have to write a button input field that fires an Ajax submit
        event with <emphasis>listEmployees</emphasis> as event id:</para>

        <programlisting>
&lt;input type="button" value="List" onclick="<emphasis role="bold">XT.doAjaxSubmit('listEmployees', this);</emphasis>"&gt; 
</programlisting>

        <para>Then, write the HTML <emphasis>table</emphasis> element to use
        for listing the employees:</para>

        <programlisting>
&lt;table border="1"&gt;

    &lt;thead&gt;
       &lt;tr&gt;
           &lt;th&gt;Firstname&lt;/th&gt;
           &lt;th&gt;Surname&lt;/th&gt;
           &lt;th&gt;Matriculation Code&lt;/th&gt;
       &lt;/tr&gt;
    &lt;/thead&gt;

   &lt;tbody id="<emphasis role="bold">employees</emphasis>"&gt;
   &lt;/tbody&gt;

&lt;/table&gt;
</programlisting>

        <para>Please note the table body, with an
        <emphasis>employees</emphasis> id attribute: this is the page part
        that will be updated with the employees list.</para>

        <para>That's all ... let's take a look at our Spring MVC
        controller!</para>
      </sect4>

      <sect4 id="ajax-tutorial-2-step-2">
        <title>Step 2 : Writing the Spring MVC controller</title>

        <para>XT Ajax Framework requires only little changes to the way you
        write Spring MVC controllers.</para>

        <para>For the purposes of our example, the most interesting part of
        our Spring MVC controller is the <emphasis>onSubmit</emphasis>
        method:</para>

        <programlisting>
protected ModelAndView onSubmit(Object command, BindException errors) 
throws Exception {
    // <emphasis role="bold">Take the command object and the office contained in it:</emphasis>
    EmployeesListForm form = (EmployeesListForm) command;
    Office office = form.getOffice();

    // <emphasis role="bold">Take a list of employees by office:</emphasis>
    Collection&lt;IEmployee&gt; employees = store.getEmployeesByOffice(office);

    // <emphasis role="bold">Construct and return the ModelAndView:</emphasis>
    Map model = new HashMap(1);
    model.put("employees", employees);
    return new AjaxModelAndView(this.getSuccessView(), errors, model);
    // <emphasis role="bold">The model map contains the employee list that will be rendered using ajax!</emphasis>
}
</programlisting>

        <para>The only difference is the use of the <emphasis
        role="bold">AjaxModelAndView</emphasis> (see
        <emphasis>org.springmodules.xt.ajax.web.servlet.AjaxModelAndView</emphasis>
        javadoc), carrying the BindException errors object required by the
        Ajax framework.</para>

        <note>
          <para>The AjaxModelAndView object behaves exactly the same as a
          standard ModelAndView object.</para>
        </note>

        <para>Let's go with our Ajax handler!</para>
      </sect4>

      <sect4 id="ajax-tutorial-2-step-3">
        <title>Step 3 : Writing the Ajax handler</title>

        <para>Our Ajax handler will extend the
        <emphasis>org.springmodules.xt.ajax.AbstractAjaxHandler</emphasis>, so
        it will have a method called after the Ajax event to handle, that will
        accept an
        <emphasis>org.springmodules.xt.ajax.AjaxSubmitEvent</emphasis>:</para>

        <programlisting>
public AjaxResponse <emphasis role="bold">listEmployees</emphasis>(AjaxSubmitEvent event)
</programlisting>

        <para>Let's talk about the <emphasis>listEmployees</emphasis> method
        implementation.</para>

        <para>We want to show the employees belonging to the selcted office,
        so we have to retrieve the model map from the event object, and the
        employee list contained in it:</para>

        <programlisting>
Map model = event.getModel();
Collection&lt;IEmployee&gt; employees = (Collection) model.get("employees");
</programlisting>

        <para>Then, we have to create the components to render: a list of
        <emphasis>org.springmodules.xt.ajax.component.TableRow</emphasis>
        components, containing the employees:</para>

        <programlisting>
// <emphasis role="bold">Create the rows list:</emphasis>
List rows = new LinkedList();
for(IEmployee emp : employees) {
    // <emphasis role="bold">Every row is an employee:</emphasis>
    TableRow row = new TableRow(emp, new String[]{"firstname", "surname", "matriculationCode"}, null);
    rows.add(row);
}
</programlisting>

        <para>Now we have to replace all the rows in the HTML table, so we
        have to create an
        <emphasis>org.springmodules.xt.ajax.action.ReplaceContentAction</emphasis>,
        adding it the components to render:</para>

        <programlisting>
ReplaceContentAction <emphasis role="bold">action</emphasis> = new ReplaceContentAction("<emphasis
            role="bold">employees</emphasis>", rows);
</programlisting>

        <para>Note that the <emphasis>ReplaceContentAction</emphasis> updates
        the HTML element with <emphasis>employees</emphasis> as id.</para>

        <para>Finally, we have to create an
        <emphasis>org.springmodules.xt.ajax.AjaxResponse</emphasis> and return
        it!</para>

        <programlisting>
AjaxResponse response = new AjaxResponseImpl();
response.addAction(<emphasis role="bold">action</emphasis>);
return response;
</programlisting>

        <para>That's the <emphasis>listEmployees</emphasis> method
        implementation!</para>
      </sect4>

      <sect4 id="ajax-tutorial-2-step-4">
        <title>Step 4 : Mapping the Ajax handler to the web page URL</title>

        <para>Say the web page URL is:
        <emphasis>www.example.org/xt/ajax/tutorial2.page</emphasis>. Mapping
        the Ajax handler is simply a matter of configuring the Ajax handler
        bean (<emphasis>ajaxListEmployeesHandler</emphasis> in the snippet
        below) in the Spring application context and mapping it in the
        <emphasis>AjaxInterceptor</emphasis>:</para>

        <programlisting>
&lt;bean id="<emphasis role="bold">ajaxListEmployeesHandler</emphasis>" class="org.springmodules.xt.examples.ajax.ListEmployeesHandler"&gt;
    &lt;property name="store" ref="store"/&gt;
&lt;/bean&gt;
</programlisting>

        <programlisting>
&lt;bean id="ajaxInterceptor" class="org.springmodules.xt.ajax.AjaxInterceptor"&gt;
    &lt;property name="handlerMappings"&gt;
        &lt;props&gt;
            <emphasis role="bold">&lt;prop key="/ajax/tutorial2.page"&gt;ajaxListEmployeesHandler&lt;/prop&gt;</emphasis>
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</programlisting>
      </sect4>
    </sect3>

    <sect3 id="ajax-tutorial-3">
      <title id="ajax-tutorial-3-title">Working with Ajax validation</title>

      <para>Ajax validation is a common use case, so the XT Ajax Framework
      provides the <emphasis
      role="bold">org.springmodules.xt.ajax.validation.DefaultValidationHandler</emphasis>
      for doing Ajax based validation in a very simple way.</para>

      <para>In this tutorial we'll implement a simple Ajax validation use
      case: <emphasis role="bold">validating an employee matriculation
      code</emphasis>. We'll see how to:</para>

      <itemizedlist>
        <listitem>
          <para>Configure the DefaultValidationHandler.</para>
        </listitem>

        <listitem>
          <para>Write the Spring MVC validator.</para>
        </listitem>

        <listitem>
          <para>Write the web page.</para>
        </listitem>
      </itemizedlist>

      <sect4 id="ajax-tutorial-3-step-1">
        <title>Step 1 : Configuring the DefaultValidationHandler</title>

        <para>If you want to use the DefaultValidationHandler without any
        customization, you must simply configure and map it into the Spring
        application context as you'd usually do with any other handler:</para>

        <para><programlisting>
&lt;bean id="<emphasis role="bold">ajaxValidationHandler</emphasis>" class="org.springmodules.xt.ajax.validation.DefaultValidationHandler"&gt;</programlisting><programlisting>
&lt;bean id="ajaxInterceptor" class="org.springmodules.xt.ajax.AjaxInterceptor"&gt;
    &lt;property name="handlerMappings"&gt;
        &lt;props&gt;
            <emphasis role="bold">&lt;prop key="/ajax/tutorial3.page"&gt;ajaxValidationHandler&lt;/prop&gt;</emphasis>
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</programlisting></para>

        <para>By default, the DefaultValidationHandler displays and highlights
        error messages in the submitted web page, and redirects to the success
        page on successfull. However, you can <emphasis role="bold">customize
        how error messages are rendered</emphasis>, by providing a custom
        implementation of the
        <emphasis>org.springmodules.xt.ajax.validation.ErrorRenderingCallback</emphasis>
        class, and <emphasis role="bold">how successfull validation is
        handled</emphasis>, by providing a custom implementation of the
        <emphasis>org.springmodules.xt.ajax.validation.SuccessRenderingCallback</emphasis>
        class.</para>
      </sect4>

      <sect4 id="ajax-tutorial-3-step-2">
        <title>Step 2 : Writing the Spring MVC validator</title>

        <para>XT Ajax Framework doesn't require to change the validator code:
        it is completely independent.</para>

        <para>So here is the validator:</para>

        <programlisting>
public class EmployeeValidator implements Validator {

    public boolean supports(Class aClass) {
        return IEmployee.class.isAssignableFrom(aClass);
    }

    public void validate(Object object, Errors errors) {
        if (this.supports(object.getClass())) {
            IEmployee emp = (IEmployee) object;
            if (emp.getMatriculationCode() == null || emp.getMatriculationCode().equals("")) {
                errors.rejectValue("matriculationCode", 
                "<emphasis role="bold">employee.null.code</emphasis>", "No Matriculation Code!");
            }
        }
    }
}</programlisting>

        <para>Please note the <emphasis>employee.null.code</emphasis> error
        code: as we are going to see in the next section, it is the message
        that will be rendered in the web page by the
        DefaultValidationHandler.</para>
      </sect4>

      <sect4 id="ajax-tutorial-3-step-3">
        <title>Step 3 : Writing the web page</title>

        <para>First, import the core XT Ajax javascript library, plus the
        Prototype and Script.aculo.us libraries:</para>

        <programlisting>
&lt;script type="text/javascript" src='<emphasis role="bold">springxt.js</emphasis>'&gt;&lt;/script&gt;
&lt;script type="text/javascript" src='<emphasis role="bold">prototype.js</emphasis>'&gt;&lt;/script&gt;
&lt;script type="text/javascript" src='<emphasis role="bold">scriptaculous.js?load=effects</emphasis>'&gt;&lt;/script&gt;
</programlisting>

        <para>Then, you have to mark the HTML elements where to show the
        errors sent by the validator: this requires only to <emphasis
        role="bold">write HTML elements whose id is the same as the error
        codes you want to show</emphasis>.</para>

        <para>In our sample, we have an
        <emphasis>employee.null.code</emphasis> error code, and we want to
        have a <emphasis>div</emphasis> element containing just the
        <emphasis>employee.null.code</emphasis> error; here is what we have to
        write:</para>

        <programlisting>
&lt;div id="<emphasis role="bold">employee.null.code</emphasis>"/&gt;
</programlisting>

        <para>The DefaultValidationHandler will fill the element above with
        the proper error message.</para>

        <note>
          <para>Error messages filled by the DefaultValidationHandler are
          <emphasis role="bold">internationalized</emphasis>.</para>
        </note>

        <para>Finally, you have to simply call the DefaultValidationHandler by
        firing an Ajax submit event in the following way:</para>

        <programlisting>
&lt;input type="button" value="Fire" onclick="<emphasis role="bold">XT.doAjaxSubmit('validate', this);</emphasis>"&gt;
</programlisting>

        <note>
          <para><emphasis>validate</emphasis> is the mandatory event name
          associated with the DefaultValidationHandler.</para>
        </note>
      </sect4>

      <sect4 id="ajax-tutorial-3-step-4">
        <title>Step 4 : Organizing error messages</title>

        <para>The DefaultValidationHandler puts your error messages in HTML
        elements whose identifier is equal to the validator error code.</para>

        <para>In the previous section, the handler used the following
        element:</para>

        <programlisting>
&lt;div id="<emphasis role="bold">employee.null.code</emphasis>"/&gt;
</programlisting>

        <para>to render the <emphasis>employee.null.code</emphasis>
        error.</para>

        <para>What if you want to group error messages, i.e. all errors with
        the error code starting with the "employee" substring?</para>

        <para>The DefaultValidationHandler automatically uses wildcard
        matching; by doing so, it let you organize your error messages in HTML
        elements whose identifier either:</para>

        <itemizedlist>
          <listitem>
            <para>Is exactly equal to the error code whose message has to be
            displayed.</para>
          </listitem>

          <listitem>
            <para>Starts with a substring of the error code whose message has
            to be displayed, and ends with the "_" wildcard.</para>
          </listitem>
        </itemizedlist>

        <para>Error messages will be displayed into all elements with matching
        identifier.</para>

        <para>An example will help clarifying.</para>

        <para>Say you have two error codes (with related messages):
        <emphasis>employee.null.code</emphasis> and
        <emphasis>employee.null.username</emphasis>. If you want to display a
        different HTML element for each error message, plus an HTML element
        containing all error messages whose code starts with "employee", just
        put the following elements in your web page:</para>

        <programlisting>
&lt;div id="<emphasis role="bold">employee_</emphasis>"/&gt;
......
&lt;div id="<emphasis role="bold">employee.null.code</emphasis>"/&gt;
&lt;div id="<emphasis role="bold">employee.null.username</emphasis>"/&gt;
</programlisting>

        <para>The first div element will display all error messages starting
        with the "employee" substring, while the other two will display each
        one the proper message.</para>
      </sect4>
    </sect3>
  </sect2>
</sect1>