<sect1 id="modeling"><title>XT Modeling Framework</title>
    <sect2 id='modeling-intro'><title id='modeling-intro-title'>Introduction</title>
        <para>XT Modeling Framework provides several facilities for constructing rich domain models which gracefully collaborate and interact with other layers and components in your application.
            It comprises different parts we'll illustrate in the section below. 
        </para>
    </sect2>
    <sect2 id='modeling-base'><title id='modeling-base-title'>Base Concepts</title>
        <sect3 id='introductor'><title id='introductor-title'>Introductor</title>
            <para>The XT <emphasis>Introductor</emphasis> permits you to make existent objects implementing additional interfaces defined at runtime, that is, it <emphasis>introduces</emphasis> new interfaces into already existent plain old java objects.
                This is achieved through the use of <ulink url='http://www.springframework.org/documentation'><citetitle>Spring AOP</citetitle></ulink> <emphasis>Introduction</emphasis>, for creating proxy objects that behave like the original one but also implement new interfaces. 
            </para>
            <sect4 id='dynamicintroductor'><title id='dynamicintroductor-title'>DynamicIntroductor</title>
                <para>The core interface is the <emphasis role='bold'>DynamicIntroductor</emphasis>:
                </para>
                <programlisting><![CDATA[
                    public interface DynamicIntroductor {
      
                    public Object introduceInterfaces(Object target, Class[] introducedInterfaces);

                    public Object introduceInterfaces(Object target, Class[] introducedInterfaces, 
                    Class[] targetInterfaces);

                    public Object getTarget(Object proxy);
                    }
                    ]]>
                </programlisting> 
                <itemizedlist>
                <listitem><para><emphasis role='bold'>introduceInterfaces(Object target, Class[] introducedInterfaces)</emphasis></para></listitem>
                    <listitem><para>Introduce to the given target object a set of interfaces defined at runtime. The resulting proxy object <emphasis role='bold'>extends</emphasis> the target object class.</para></listitem>
                    <listitem><para><emphasis role='bold'>public Object introduceInterfaces(Object target, Class[] introducedInterfaces, Class[] targetInterfaces)</emphasis></para></listitem>
                    <listitem><para>Introduce to the given target object a set of interfaces defined at runtime. The resulting proxy object <emphasis role='bold'>implements</emphasis> a set of target interfaces defined at runtime (without extending the target object).</para></listitem> 
                    <listitem><para><emphasis role='bold'>public Object getTarget(Object proxy)</emphasis></para></listitem> 
                    <listitem><para>Get the original target object from the proxied (introduced) one.</para></listitem>
                </itemizedlist>
            </sect4>
            <sect4 id='dynamicbeanintroductor'><title id='dynamicbeanintroductor-title'>DynamicBeanIntroductor</title>
            <para>The <emphasis role='bold'>DynamicBeanIntroductor</emphasis> class is a concrete implementation for introducing <emphasis>JavaBeans-style</emphasis> interfaces with getter/setter methods.
                    You can introduce any interface <emphasis role='bold'>without</emphasis> manually implementing it, because its getter/setter methods will be automatically implemented; the only constraints to follow when using the DynamicBeanIntroducto are to not introduce interfaces with methods different than getter or setters, and to not use primitive types as getter return types, using instead their object wrappers. 
                </para>
                <para>For example, take this domain object:
                </para>
                <programlisting><![CDATA[
                    public class Employee {
    
                    private String matriculationCode;
                    private String firstname;
                    private String surname;

                    public String getFirstname() {
                    return firstname;
                    }

                    public void setFirstname(String firstname) {
                    this.firstname = firstname;
                    }

                    public String getSurname() {
                    return surname;
                    }

                    public void setSurname(String surname) {
                    this.surname = surname;
                    }

                    public String getMatriculationCode() {
                    return matriculationCode;
                    }

                    public void setMatriculationCode(String matriculationCode) {
                    this.matriculationCode = matriculationCode;
                    }
                    }]]>
                </programlisting>
                <para>You can automatically introduce the following interface:
                </para>
                <programlisting><![CDATA[
                    public interface EmployeeView {
    
                    void setOffice(Office office);
    
                    Office getOffice();
    
                    void setSelected(Boolean selected);
    
                    Boolean getSelected();
                    }]]>
                </programlisting>
                <para>Simply doing this:
                </para>
                <programlisting><![CDATA[
                    DynamicBeanIntroductor introductor =  new DynamicBeanIntroductor();
                    Object introducedEmployee = introductor.introduceInterfaces(new Employee(), 
                    new Class[]{EmployeeView.class});]]>
                </programlisting>
                <para>You can now use your introduced object:
                </para>
                <programlisting><![CDATA[
                    ((Employee) introducedEmployee).getMatriculationCode();
                    ((EmployeeView) introducedEmployee).getSelected();]]>
                </programlisting>
            </sect4>
            <sect4 id='introductor-collections'><title id='introductor-collections-title'>Introductor Collections</title>
                <para>Introductor Collections are <ulink url='http://java.sun.com/docs/books/tutorial/collections/index.html'><citetitle>Java Collections</citetitle></ulink> decorators that apply Dynamic Introductors to contained objects.
                    You can decorate a Java <ulink url='http://java.sun.com/docs/books/tutorial/collections/interfaces/index.html'><citetitle>Collection</citetitle></ulink>, <ulink url='http://java.sun.com/docs/books/tutorial/collections/interfaces/index.html'><citetitle>Set</citetitle></ulink>, or <ulink url='http://java.sun.com/docs/books/tutorial/collections/interfaces/index.html'><citetitle>List</citetitle></ulink>. 
                    Here is how you construct an Introductor Collection: 
                </para>
                <programlisting><![CDATA[
                    public IntroductorCollection(Collection target, Class[] introducedInterfaces, 
                    Class[] targetObjectsInterfaces, DynamicIntroductor introductor);

                    public IntroductorCollection(Collection target, Class[] interfaces, 
                    DynamicIntroductor introductor);

                    public IntroductorSet(Collection target, Class[] introducedInterfaces, 
                    Class[] targetObjectsInterfaces, DynamicIntroductor introductor);

                    public IntroductorSet(Collection target, Class[] interfaces, 
                    DynamicIntroductor introductor);

                    public IntroductorList(Collection target, Class[] introducedInterfaces, 
                    Class[] targetObjectsInterfaces, DynamicIntroductor introductor);

                    public IntroductorList(Collection target, Class[] interfaces, 
                    DynamicIntroductor introductor);]]>
                </programlisting>
                <para>You can specify the following constructor parameters:
                </para>
                <itemizedlist>
                    <listitem><para><emphasis>Collection target</emphasis> : The target collection to decorate</para></listitem>
                    <listitem><para><emphasis>Class[] introducedInterfaces</emphasis> : The interfaces to introduce into every contained object.</para></listitem>
                    <listitem><para><emphasis>Class[] targetObjectsInterfaces</emphasis> : The interfaces of the target object that the proxy object must implement. </para></listitem>
                    <listitem><para><emphasis>DynamicIntroductor introductor</emphasis> : The Dynamic Introductor to use. </para></listitem>
                </itemizedlist>
                <para>
                    You can safely add and remove objects to and from Introductor Collections like they were normal collections: all changes are backed by the original non-decorated collection.
                    Every object you get from an Introductor Collection implements a given set of interfaces using a particular, concrete, Dynamic Introductor, 
                    but <emphasis role='bold'>note</emphasis> that objects stored in the original collection <emphasis role='bold'>are not modified</emphasis>. 
                </para>
            </sect4>
        </sect3>
        <sect3 id='notifications'><title id='notifications-title'>Notifications</title>
            <para><ulink url='http://www.martinfowler.com/eaaDev/Notification.html'><citetitle>Notifications</citetitle></ulink> are lightweight objects capable of collecting and carrying messages between different application layers, even if most of the time they will carry messages toward the presentation layer.
            </para>
            <para>XT Notifications implementation is based on a <emphasis>Message</emphasis> interface and a <emphasis>Notification</emphasis> interface.
            </para>
            <sect4 id='the-message-interface'><title id='the-message-interface-title'>The Message Interface</title>
                <para>The Message interface looks like this:</para>
                <programlisting><![CDATA[
                    public interface Message {
    
                    public enum Type { ERROR, WARNING, INFO };
    
                    public String getCode();
    
                    public Message.Type getType();
    
                    public String getPropertyName();
    
                    public String getDefaultMessage();
                    }]]>
                </programlisting>
                <para>A message object can hold the following information:
                </para>
                <itemizedlist>
                    <listitem>
                        <para>A message type: <emphasis>ERROR</emphasis>, <emphasis>WARNING</emphasis> or <emphasis>INFO</emphasis>.
                        </para>
                    </listitem>
                    <listitem>
                        <para>A message code.
                        </para>
                    </listitem>
                    <listitem>
                        <para>A default message text.
                        </para>
                    </listitem>
                    <listitem>
                        <para>The name of an object property this message refers to, used for example when messages refer to validation errors.
                        </para>
                    </listitem>
                </itemizedlist>
            </sect4>
            <sect4 id='the-notification-interface'><title id='the-notification-interface-title'>The Notification Interface</title>
                <para>The Notification interface looks like this:</para>
                <programlisting><![CDATA[
                    public interface Notification {
   
                    public void addMessage(Message message);

                    public boolean removeMessage(Message message);

                    public Message[] getMessages(Message.Type type);

                    public boolean hasMessages(Message.Type type);

                    public Message[] getAllMessages();

                    public boolean hasMessages();

                    public void addAllMessages(Notification notification);
                    }]]>
                </programlisting>
                <para>As you can see, you can add and remove Message objects, and ask for Messages of a given type.
                </para>
            </sect4>
        </sect3>
        <sect3 id='specifications'><title id='specifications-title'>Specifications</title>
            <para>
                <ulink url='http://www.martinfowler.com/apsupp/spec.pdf'><citetitle>Specifications</citetitle></ulink> are predicate-like objects for powerfully expressing all kind of business/validation/selection rules and matching business objects against them.
            </para>
            <para>
                Every Specification implementation must have a boolean method for verifying if a business object satisfies the Specification rules. 
            </para>
            <para>XT Specification implementation is based on the following interface:</para>
            <programlisting><![CDATA[
                public interface Specification<O> {
   
                public boolean evaluate(O object);
    
                public boolean evaluate(O object, Notification notification);
    
                public void addMessage(Message message, boolean whenSatisfied);
    
                public boolean removeMessage(Message message, boolean whenSatisfied);
                }]]>
            </programlisting>
            <para>
                You can specify what <link linkend="the-message-interface">Messages</link> will be thrown when the specification is satisfied or unsatisfied, and evaluate it
                collecting messages into a <link linkend="notifications">Notification</link> object.
            </para>
            <sect4 id='composite-specifications'><title id='composite-specifications-title'>Composite Specifications</title>
                <para>
                    Composite Specifications let you compose your own specification objects through logical operators and define what <link linkend="the-message-interface">Messages</link> 
                    will be issued by what specifications when satisfied or unsatisfied, all using a nice <ulink url='http://www.martinfowler.com/bliki/FluentInterface.html'><citetitle>fluent interface</citetitle></ulink>.
                </para>
                <para>
                    Other than this, the main advantage of using the Composite Specification is that you can combine your own specifications whatever their class is, without modifying one line of your code.
                </para>
                <para>Here is the CompositeSpecification interface:</para>
                <programlisting><![CDATA[
                    public interface CompositeSpecification<S, O> extends Specification<O> {
    
                    public CompositeSpecification and(CompositeSpecification<S, O> specification);

                    public CompositeSpecification and(S specification);

                    public CompositeSpecification andNot(CompositeSpecification<S, O> specification);

                    public CompositeSpecification andNot(S specification);

                    public CompositeSpecification compose(S specification);

                    public CompositeSpecification withMessage(Message message, boolean whenSatisfied);
    
                    public boolean evaluate(O object);

                    public CompositeSpecification or(CompositeSpecification<S, O> specification);

                    public CompositeSpecification or(S specification);

                    public CompositeSpecification orNot(CompositeSpecification<S, O> specification);

                    public CompositeSpecification orNot(S specification);
                    }]]>
                </programlisting>
                <para>
                    The CompositeSpecification has two generic types, <emphasis>S</emphasis> and <emphasis>O</emphasis>: they represent the type of the specification you want to compose,
                    and the type of the object you want to evaluate.
                </para>
                <para>Some code is worth a lot of words, so for taking a glimpse on how powerful a CompositeSpecification can be, say you have implemented these two specifications in your own project (independent form XT code):</para>
                <programlisting><![CDATA[
                    public class OfficeIdSpecification implements BaseSpecification<IOffice> {
    
                    public boolean isSatisfiedBy(IOffice o) {
                    return o.getOfficeId().matches("\\d+") || o.getOfficeId().matches("o\\d+"); 
                    }
                    
                    }]]>
                </programlisting>
                <programlisting><![CDATA[
                    public class FullOfficeSpecification implements BaseSpecification<IOffice> {
    
                    private int limit = 3;
    
                    public boolean isSatisfiedBy(IOffice o) {
                    return o.getEmployees().size() > this.limit; 
                    }
                    
                    }]]>
                </programlisting>
                <para>You can powerfully combine them by simply writing the following:</para>
                <programlisting><![CDATA[
                    OfficeIdSpecification idSpecification = new OfficeIdSpecification();
                    FullOfficeSpecification fullOfficeSpecification = new FullOfficeSpecification();
        
                    CompositeSpecification<BaseSpecification, IOffice> officeSpecification = 
                    new CompositeSpecificationImpl(BaseSpecification.class, "isSatisfiedBy");

                    Message wrongIdMessage = new MessageImpl(OfficeErrorCodes.WRONG_ID, 
                    Message.Type.ERROR,
                    "officeId",
                    "Wrong office id");
                    Message fullOfficeMessage = new MessageImpl(OfficeErrorCodes.FULL,
                    Message.Type.ERROR,
                    "employees", 
                    "Too many employees");

                    officeSpecification.compose(idSpecification).withMessage(wrongIdMessage, false)
                    .andNot(fullOfficeSpecification).withMessage(fullOfficeMessage, true);]]>
                </programlisting>
                <para>
                    This will compose a specification matching an office that has a correct id and is not full.
                </para>
            </sect4>
        </sect3>
    </sect2>
</sect1>