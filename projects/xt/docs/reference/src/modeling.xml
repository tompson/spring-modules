<?xml version="1.0" encoding="UTF-8"?>
<sect1 id="modeling">
  <title>XT Modeling Framework</title>

  <sect2 id="modeling-intro">
    <title id="modeling-intro-title">Introduction</title>

    <para>XT Modeling Framework provides several facilities for constructing
    rich domain models which gracefully collaborate and interact with other
    layers and components in your application. It comprises different parts
    we'll illustrate in the section below.</para>
  </sect2>

  <sect2 id="modeling-base">
    <title id="modeling-base-title">Base Concepts</title>

    <sect3 id="introductor">
      <title id="introductor-title">Introductor</title>

      <para>The XT <emphasis>Introductor</emphasis> permits you to make
      existent objects implementing additional interfaces defined at runtime,
      that is, it <emphasis>introduces</emphasis> new interfaces into already
      existent Plain Old Java Objects. This is achieved through the use of
      <ulink
      url="http://www.springframework.org/documentation"><citetitle>Spring
      AOP</citetitle></ulink> <emphasis>Introduction</emphasis>, for creating
      proxy objects that behave like the original one but also implement new
      interfaces.</para>

      <sect4 id="dynamicintroductor">
        <title id="dynamicintroductor-title">DynamicIntroductor</title>

        <para>The core interface is the <emphasis
        role="bold">DynamicIntroductor</emphasis> (see
        <emphasis>org.springmodules.xt.model.introductor.DynamicIntroductor</emphasis>
        javadoc):</para>

        <programlisting>
public interface DynamicIntroductor {

    public Object introduceInterfaces(Object target, Class[] introducedInterfaces);

    public Object introduceInterfaces(Object target, Class[] introducedInterfaces, 
                                      Class[] targetInterfaces);

    public Object getTarget(Object proxy);
}</programlisting>

        <itemizedlist>
          <listitem>
            <para><emphasis>public Object introduceInterfaces(Object target,
            Class[] introducedInterfaces)</emphasis> : Introduce to the given
            target object a set of interfaces defined at runtime. The
            resulting proxy object <emphasis role="bold">extends</emphasis>
            the target object class.</para>
          </listitem>

          <listitem>
            <para><emphasis>public Object introduceInterfaces(Object target,
            Class[] introducedInterfaces, Class[] targetInterfaces)</emphasis>
            : Introduce to the given target object a set of interfaces defined
            at runtime. The resulting proxy object <emphasis
            role="bold">implements</emphasis> a set of target interfaces
            defined at runtime (without extending the target object).</para>
          </listitem>

          <listitem>
            <para><emphasis>public Object getTarget(Object proxy)</emphasis> :
            Get the original target object from the proxied (introduced)
            one.</para>
          </listitem>
        </itemizedlist>
      </sect4>

      <sect4 id="dynamicbeanintroductor">
        <title
        id="dynamicbeanintroductor-title">DynamicBeanIntroductor</title>

        <para>The <emphasis role="bold">DynamicBeanIntroductor</emphasis> (see
        <emphasis>org.springmodules.xt.model.introductor.bean.DynamicBeanIntroductor</emphasis>
        javadoc) is a concrete implementation for introducing
        <emphasis>JavaBeans-style</emphasis> interfaces with getter/setter
        methods into already existent <emphasis role="bold">target</emphasis>
        objects. You can introduce any interface <emphasis
        role="bold">without</emphasis> manually implementing it, because its
        getter/setter methods will be automatically implemented; the only
        <emphasis role="bold">constraints</emphasis> to follow when using the
        DynamicBeanIntroductor are to not introduce interfaces with methods
        different than getter or setters, and to not use primitive types as
        getter return types, using instead their object wrappers.</para>

        <para>For example, take this Employee object:</para>

        <programlisting>
public class Employee implements IEmployee {

    private String matriculationCode;
    private String firstname;
    private String surname;

    public String getFirstname() {
        return firstname;
    }

    public void setFirstname(String firstname) {
        this.firstname = firstname;
    }

    public String getSurname() {
        return surname;
    }

    public void setSurname(String surname) {
        this.surname = surname;
    }

    public String getMatriculationCode() {
        return matriculationCode;
    }

    public void setMatriculationCode(String matriculationCode) {
        this.matriculationCode = matriculationCode;
    }
}
</programlisting>

        <para>You can automatically introduce the following interface:</para>

        <programlisting>
public interface EmployeeView {

    void setOffice(Office office);

    Office getOffice();

    void setSelected(Boolean selected);

    Boolean isSelected();
}
</programlisting>

        <para>By simply doing:</para>

        <programlisting>
IEmployee employee = new Employee();

DynamicBeanIntroductor introductor =  new DynamicBeanIntroductor();

Object newEmployee = introductor.introduceInterfaces(employee, 
                                                     new Class[]{EmployeeView.class});
</programlisting>

        <para>You can now use your brand new object:</para>

        <programlisting>
IEmployee employee = (IEmployee) newEmployee;
EmployeeView view = (EmployeeView) newEmployee;

employee.setMatriculationCode(...);
view.setSelected(...);</programlisting>

        <para>When calling methods on an object created through the
        DynamicBeanIntroductor, the following happens:</para>

        <itemizedlist>
          <listitem>
            <para>Every call to a getter/setter method declared into the
            introduced interface is delegated to the target object if this
            declares and implements a public method with equal signature,
            otherwise it is automatically implemented by the proxy.</para>
          </listitem>

          <listitem>
            <para>Every call to a non getter/setter method declared into the
            introduced interface throws an exception.</para>
          </listitem>

          <listitem>
            <para>Every call to a method not declared into the introduced
            interface is directly delegated to the target object.</para>
          </listitem>
        </itemizedlist>

        <para>Moreover, the DynamicBeanIntroductor behaviour can be
        customized: see <link
        linkend="DynamicIntroductor-Annotations">DynamicIntroductor
        annotations</link>.</para>
      </sect4>

      <sect4 id="dynamicimplementorintroductor">
        <title
        id="dynamicimplementorintroductor-title">DynamicImplementorIntroductor</title>

        <para>The <emphasis
        role="bold">DynamicImplementorIntroductor</emphasis> (see
        <emphasis>org.springmodules.xt.model.introductor.implementor.DynamicImplementorIntroductor</emphasis>
        javadoc) is a concrete implementation for introducing additional
        interfaces into already existent <emphasis
        role="bold">target</emphasis> objects and delegate the implementation
        of those interfaces to an external Java object called <emphasis
        role="bold">implementor</emphasis>.</para>

        <para>For example, take this Manager object:</para>

        <programlisting>
public class Manager implements IManager {
    
    private List&lt;IEmployee&gt; managedEmployees;
    private String matriculationCode;
    
    public void setManagedEmployees(List&lt;IEmployee&gt; employees) {
        this.managedEmployees = employees;
    }
    
    public List&lt;IEmployee&gt; getManagedEmployees() {
        return this.managedEmployees;
    }
}</programlisting>

        <para>You can introduce the following interface:</para>

        <programlisting>
public interface IEmployee {
    
    String getMatriculationCode();
    
    String getFirstname();

    String getSurname();
    
    void setMatriculationCode(String matriculationCode);

    void setFirstname(String firstname);

    void setSurname(String surname);
}</programlisting>

        <para>With the following implementation:</para>

        <programlisting>
public class Employee implements IEmployee {

    private String matriculationCode;
    private String firstname;
    private String surname;

    public String getFirstname() {
        return firstname;
    }

    public void setFirstname(String firstname) {
        this.firstname = firstname;
    }

    public String getSurname() {
        return surname;
    }

    public void setSurname(String surname) {
        this.surname = surname;
    }

    public String getMatriculationCode() {
        return matriculationCode;
    }

    public void setMatriculationCode(String matriculationCode) {
        this.matriculationCode = matriculationCode;
    }
}
</programlisting>

        <para>By simply doing:</para>

        <programlisting>
IManager manager = new Manager();
IEmployee employee = new Employee();
DynamicImplementorIntroductor introductor  = new DynamicImplementorIntroductor(employee); <emphasis
            role="bold">// (1)</emphasis>

Object newManager = introductor.introduceInterfaces(manager, 
                                                    new Class[]{IEmployee.class}); // <emphasis
            role="bold">(2)</emphasis></programlisting>

        <para>You have to simply construct the
        <emphasis>DynamicImplementorIntroductor</emphasis> object (1) by
        passing it the <emphasis>implementor</emphasis> object, that is, the
        object that will implement the interfaces to introduce. Then, you have
        to actually introduce the interfaces into the
        <emphasis>target</emphasis> object (2).</para>

        <para>You can now use your brand new object:</para>

        <programlisting>
IManager manager = (IManager) newManager;
IEmployee employee = (IEmployee) newManager;

manager.setManagedEmployees(...);
employee.setMatriculationCode(...);</programlisting>

        <para>When calling methods on an object created through the
        DynamicImplementorIntroductor, the following happens:</para>

        <itemizedlist>
          <listitem>
            <para>Every call to a method declared into an introduced interface
            will be delegated to the <emphasis
            role="bold">implementor</emphasis> object if it implements the
            introduced interface; otherwise, an exception occurs.</para>
          </listitem>

          <listitem>
            <para>Every call to a method not declared into the introduced
            interface is as always executed by the <emphasis
            role="bold">target</emphasis> object.</para>
          </listitem>
        </itemizedlist>
      </sect4>

      <sect4 id="introductor-collections">
        <title id="introductor-collections-title">Introductor
        Collections</title>

        <para>Introductor Collections (see
        <emphasis>org.springmodules.xt.model.introductor.collections</emphasis>
        javadocs) are <ulink
        url="http://java.sun.com/docs/books/tutorial/collections/index.html"><citetitle>Java
        Collections</citetitle></ulink> decorators that apply Dynamic
        Introductors to contained objects. You can decorate a Java <ulink
        url="http://java.sun.com/docs/books/tutorial/collections/interfaces/index.html"><citetitle>Collection</citetitle></ulink>,
        <ulink
        url="http://java.sun.com/docs/books/tutorial/collections/interfaces/index.html"><citetitle>Set</citetitle></ulink>,
        or <ulink
        url="http://java.sun.com/docs/books/tutorial/collections/interfaces/index.html"><citetitle>List</citetitle></ulink>.
        Here is how you construct an Introductor Collection:</para>

        <programlisting>
public IntroductorCollection(Collection target, Class[] introducedInterfaces, 
                             Class[] targetObjectsInterfaces, DynamicIntroductor introductor);

public IntroductorCollection(Collection target, Class[] interfaces, 
                             DynamicIntroductor introductor);

public IntroductorSet(Collection target, Class[] introducedInterfaces, 
                      Class[] targetObjectsInterfaces, DynamicIntroductor introductor);

public IntroductorSet(Collection target, Class[] interfaces, 
                      DynamicIntroductor introductor);

public IntroductorList(Collection target, Class[] introducedInterfaces, 
                       Class[] targetObjectsInterfaces, DynamicIntroductor introductor);

public IntroductorList(Collection target, Class[] interfaces, 
                       DynamicIntroductor introductor);
</programlisting>

        <para>You can specify the following constructor parameters:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>Collection target</emphasis> : The target
            collection to decorate</para>
          </listitem>

          <listitem>
            <para><emphasis>Class[] introducedInterfaces</emphasis> : The
            interfaces to introduce into every contained object.</para>
          </listitem>

          <listitem>
            <para><emphasis>Class[] targetObjectsInterfaces</emphasis> : The
            interfaces of the target object that the proxy object must
            implement.</para>
          </listitem>

          <listitem>
            <para><emphasis>DynamicIntroductor introductor</emphasis> : The
            Dynamic Introductor to use.</para>
          </listitem>
        </itemizedlist>

        <para>You can safely add and remove objects to and from Introductor
        Collections like they were normal collections: all changes are backed
        by the original non-decorated collection. Every object you get from an
        Introductor Collection implements a given set of interfaces using a
        particular, concrete, Dynamic Introductor, but <emphasis
        role="bold">note</emphasis> that objects stored in the original
        collection <emphasis role="bold">are not modified</emphasis>.</para>
      </sect4>
    </sect3>

    <sect3 id="generator">
      <title id="generator-title">Generator</title>

      <para>The XT <emphasis>Generator</emphasis> let you generate Java
      objects starting from simple Java interfaces.</para>

      <sect4 id="dynamicgenerator">
        <title id="dynamicgenerator-title">DynamicGenerator</title>

        <para>The core interface is the <emphasis
        role="bold">DynamicGenerator</emphasis> (see
        <emphasis>org.springmodules.xt.model.generator.DynamicGenerator</emphasis>
        javadoc):</para>

        <programlisting>
public interface DynamicGenerator&lt;T&gt; {

    public T generate();
}

</programlisting>

        <itemizedlist>
          <listitem>
            <para><emphasis>public T generate()</emphasis> : Generate an
            object of generic type <emphasis>T.</emphasis></para>
          </listitem>
        </itemizedlist>

        <para>Given its simple and generic interface, the DynamicGenerator can
        be used to generate all kind of objects.</para>
      </sect4>

      <sect4 id="dynamicfactorygenerator">
        <title
        id="dynamicfactorygenerator-title">DynamicFactoryGenerator</title>

        <para>The <emphasis role="bold">DynamicFactoryGenerator</emphasis>
        (see
        <emphasis>org.springmodules.xt.model.generator.factory.DynamicFactoryGenerator</emphasis>
        javadoc) is a concrete implementation for generating factory objects
        by simply providing a plain Java interface with a number of setter
        methods, representing constructor arguments and properties to use for
        constructing and assembling the <emphasis>product object</emphasis>,
        and a factory method returning the class (or superclass) of that
        object.</para>

        <para>Going into details, the factory interface methods must obey the
        following rules:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis role="bold">Setter</emphasis> methods must be
            annotated either with:</para>

            <itemizedlist>
              <listitem>
                <para>The ConstructorArg (see
                <emphasis>org.springmodules.xt.model.generator.annotation.ConstructorArg</emphasis>)
                annotation if they are constructor arguments, plus the
                optional ConstructorArgType (see
                <emphasis>org.springmodules.xt.model.generator.annotation.ConstructorArgType</emphasis>)
                annotation.</para>
              </listitem>

              <listitem>
                <para>The Property (see
                <emphasis>org.springmodules.xt.model.generator.annotation.Property</emphasis>)
                annotation if they are properties to be set.</para>
              </listitem>

              <listitem>
                <para>The Value (see
                <emphasis>org.springmodules.xt.model.generator.annotation.Value</emphasis>)
                annotation if they are just simple values to use later for
                other purposes.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>The <emphasis role="bold">factory</emphasis> method must be
            annotated with the <emphasis role="bold">FactoryMethod</emphasis>
            (see
            <emphasis>org.springmodules.xt.model.generator.annotation.FactoryMethod</emphasis>
            javadoc) annotation.</para>
          </listitem>

          <listitem>
            <para>Moreover, there can be <emphasis
            role="bold">getter</emphasis> methods corresponding to the setter
            methods above.</para>
          </listitem>
        </itemizedlist>

        <para>Any other method, if called, will throw an exception.</para>

        <para>So here is a simple annotated interface:</para>

        <programlisting>
public interface EmployeeFactory {

    <emphasis role="bold">// Setter methods must be annotated because they represent constructor arguments or
    // just object properties:</emphasis>
    
    @ConstructorArg(position = 0)
    void setNickname(String nickname);
    
    @ConstructorArg(position = 1)
    void setMatriculationCode(String matriculationCode);
    
    @Property(access = Property.AccessType.FIELD)
    void setFirstname(String firstname);
    
    @Property()
    void setSurname(String surname);

    <emphasis role="bold">// Getter methods must not be annotated:</emphasis>

    String getNickname();
    
    String getMatriculationCode();
    
    String getFirstname();

    String getSurname();

    <emphasis role="bold">// The factory method must be annotated in order to make it clear its purpose:</emphasis>
    
    @FactoryMethod()
    IEmployee make();
}
</programlisting>

        <para>And here is how to use it with the
        DynamicFactoryGenerator:</para>

        <programlisting>                    
// <emphasis role="bold">Generate an EmployeeFactory for creating Employees</emphasis>:
DynamicFactoryGenerator&lt;EmployeeFactory, Employee&gt; generator = 
    new DynamicFactoryGenerator(EmployeeFactory.class, Employee.class);

// <emphasis role="bold">Actually generates the factory</emphasis>:
EmployeeFactory factory = generator.generate();

// <emphasis role="bold">Set values for constructing and assembling the employee:</emphasis>
factory.setNickname("SB");
factory.setMatriculationCode("111");
factory.setFirstname("Sergio");
factory.setSurname("Bossa");

<emphasis role="bold">// Actually creates the employee:</emphasis>
IEmployee emp = factory.make();
</programlisting>

        <note>
          <para>The DynamicFactoryGenerator generates a new factory object for
          every call to its <emphasis>generate</emphasis> method, and the
          factory generates a new product object for every call to its factory
          method.</para>
        </note>
      </sect4>
    </sect3>

    <sect3 id="notifications">
      <title id="notifications-title">Notifications</title>

      <para><ulink
      url="http://www.martinfowler.com/eaaDev/Notification.html"><citetitle>Notifications</citetitle></ulink>
      are lightweight objects capable of collecting and carrying messages
      between different application layers, even if most of the time they will
      carry messages toward the presentation layer.</para>

      <para>XT Notifications implementation is based on a
      <emphasis>Message</emphasis> interface and a
      <emphasis>Notification</emphasis> interface.</para>

      <sect4 id="the-message-interface">
        <title id="the-message-interface-title">The Message Interface</title>

        <para>The Message interface looks like this:</para>

        <programlisting>
public interface Message {

    public enum Type { ERROR, WARNING, INFO };

    public String getCode();

    public Message.Type getType();

    public String getPropertyName();

    public String getDefaultMessage();
}
</programlisting>

        <para>A message object can hold the following information:</para>

        <itemizedlist>
          <listitem>
            <para>A message type: <emphasis>ERROR</emphasis>,
            <emphasis>WARNING</emphasis> or <emphasis>INFO</emphasis>.</para>
          </listitem>

          <listitem>
            <para>A message code.</para>
          </listitem>

          <listitem>
            <para>A default message text.</para>
          </listitem>

          <listitem>
            <para>The name of an object property this message refers to, used
            for example when messages refer to validation errors.</para>
          </listitem>
        </itemizedlist>
      </sect4>

      <sect4 id="the-notification-interface">
        <title id="the-notification-interface-title">The Notification
        Interface</title>

        <para>The Notification interface looks like this:</para>

        <programlisting>
public interface Notification {

    public void addMessage(Message message);

    public boolean removeMessage(Message message);

    public Message[] getMessages(Message.Type type);

    public boolean hasMessages(Message.Type type);

    public Message[] getAllMessages();

    public boolean hasMessages();

    public void addAllMessages(Notification notification);
}
</programlisting>

        <para>It is indeed straightforward: you can add and remove Message
        objects, and ask for Messages of a given type.</para>

        <para>Notifications are best used together with <link
        linkend="specifications">Specifications</link>.</para>
      </sect4>
    </sect3>

    <sect3 id="specifications">
      <title id="specifications-title">Specifications</title>

      <para><ulink
      url="http://www.martinfowler.com/apsupp/spec.pdf"><citetitle>Specifications</citetitle></ulink>
      are predicate-like objects for powerfully expressing all kind of
      business/validation/selection rules and matching business objects
      against them.</para>

      <para>Every Specification implementation must have a boolean method for
      verifying if a business object satisfies the Specification rules.</para>

      <para>XT Specification implementation is based on the following
      interface:</para>

      <programlisting>
public interface Specification&lt;O&gt; {

    public boolean evaluate(O object);

    public boolean evaluate(O object, Notification notification);

    public void addMessage(Message message, boolean whenSatisfied);

    public boolean removeMessage(Message message, boolean whenSatisfied);
}
</programlisting>

      <para>The Specification has one generic type, <emphasis>O</emphasis>,
      representing the object type you want to evaluate.</para>

      <para>As you may note, you can specify what <link
      linkend="the-message-interface">Messages</link> will be thrown when the
      specification is satisfied or unsatisfied, and collect them into a <link
      linkend="notifications">Notification</link> object at evaluation
      time.</para>

      <sect4 id="composite-specifications">
        <title id="composite-specifications-title">Composite
        Specifications</title>

        <para>Composite Specifications let you compose your own specification
        objects through logical operators and define what <link
        linkend="the-message-interface">Messages</link> will be issued by what
        specifications when satisfied or unsatisfied, all using a nice <ulink
        url="http://www.martinfowler.com/bliki/FluentInterface.html"><citetitle>fluent
        interface</citetitle></ulink>.</para>

        <para>Other than this, the main advantage of using the Composite
        Specification is that you can combine your own specifications whatever
        their class is, without modifying one line of your code.</para>

        <para>Here is the CompositeSpecification interface:</para>

        <programlisting>
public interface CompositeSpecification&lt;S, O&gt; extends Specification&lt;O&gt; {

    public CompositeSpecification and(CompositeSpecification&lt;S, O&gt; specification);

    public CompositeSpecification and(S specification);

    public CompositeSpecification andNot(CompositeSpecification&lt;S, O&gt; specification);

    public CompositeSpecification andNot(S specification);

    public CompositeSpecification compose(S specification);

    public CompositeSpecification withMessage(Message message, boolean whenSatisfied);

    public boolean evaluate(O object);

    public CompositeSpecification or(CompositeSpecification&lt;S, O&gt; specification);

    public CompositeSpecification or(S specification);

    public CompositeSpecification orNot(CompositeSpecification&lt;S, O&gt; specification);

    public CompositeSpecification orNot(S specification);
}
</programlisting>

        <para>The CompositeSpecification has two generic types,
        <emphasis>S</emphasis> and <emphasis>O</emphasis>: the former
        represents the type of the specification you want to compose, the
        latter the type of the object you want to evaluate.</para>

        <para>Some code is worth a lot of words, so for taking a glimpse on
        how powerful a CompositeSpecification can be, say you have implemented
        these two specifications in your own application (not depending on the
        XT library):</para>

        <programlisting>
public class OfficeIdSpecification implements BaseSpecification&lt;IOffice&gt; {

    public boolean isSatisfiedBy(IOffice o) {
        return o.getOfficeId().matches("\\d+") || o.getOfficeId().matches("o\\d+"); 
    }

}
</programlisting>

        <programlisting>
public class FullOfficeSpecification implements BaseSpecification&lt;IOffice&gt; {

    private int limit = 3;

    public boolean isSatisfiedBy(IOffice o) {
        return o.getEmployees().size() &gt; this.limit; 
    }

}
</programlisting>

        <para>You can powerfully compose them in a composite specification by
        simply writing the following:</para>

        <programlisting id="events">
// <emphasis role="bold">Create your business-specific specifications:</emphasis>
OfficeIdSpecification idSpecification = new OfficeIdSpecification();
FullOfficeSpecification fullOfficeSpecification = new FullOfficeSpecification();

// <emphasis role="bold">Create a CompositeSpecification for composing BaseSpecification specifications (your base class):</emphasis>
CompositeSpecification&lt;BaseSpecification, IOffice&gt; compositeSpecification = 
    new CompositeSpecificationImpl(BaseSpecification.class, "isSatisfiedBy");

// <emphasis role="bold">Create an error message for the wrong id:</emphasis>
Message wrongIdMessage = new MessageImpl(OfficeErrorCodes.WRONG_ID, 
    Message.Type.ERROR,
    "officeId",
    "Wrong office id");

// <emphasis role="bold">Create an error message for the full office:</emphasis>
Message fullOfficeMessage = new MessageImpl(OfficeErrorCodes.FULL,
Message.Type.ERROR,
    "employees", 
    "Too many employees");

// <emphasis role="bold">Compose all:</emphasis>
compositeSpecification.compose(idSpecification).withMessage(wrongIdMessage, false)
    .andNot(fullOfficeSpecification).withMessage(fullOfficeMessage, true);
</programlisting>

        <para>This will compose a specification matching an office that has a
        correct id and is not full.</para>
      </sect4>
    </sect3>

    <sect3 id="events">
      <title id="events-title">Events</title>

      <para>Introducing events into your application architecture is proven to
      be an effective technique for:</para>

      <itemizedlist>
        <listitem>
          <para>Decoupling otherwise intricated application modules, letting
          them communicate through proper events.</para>
        </listitem>

        <listitem>
          <para>Enabling, in a typical layered application architecture, lower
          layers communication towards higher layers; i.e., the communication
          from the domain layer to the presentation one.</para>
        </listitem>

        <listitem>
          <para>Multicasting system changes to an unknown number of interested
          listeners.</para>
        </listitem>

        <listitem>
          <para>Recording system changes in order to track/undo/correct
          them.</para>
        </listitem>
      </itemizedlist>

      <para>The XT Modeling Framework provides several facilities for
      implementing an event-based architecture in your application. It is
      built on the standard <ulink
      url="http://static.springframework.org/spring/docs/2.0.x/reference/beans.html#context-functionality-events">Spring
      events system</ulink>, which provides the following base
      components:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>org.springframework.context.event.ApplicationEventMulticaster</emphasis>.</para>
        </listitem>

        <listitem>
          <para><emphasis>org.springframework.context.ApplicationListener</emphasis>.</para>
        </listitem>

        <listitem>
          <para><emphasis>org.springframework.context.ApplicationEvent</emphasis>.</para>
        </listitem>
      </itemizedlist>

      <para>ApplicationListeners configured into the Spring context will be
      automatically notified of ApplicationEvents published through an
      ApplicationEventMulticaster.</para>

      <para>The XT Modeling Framework extends those components by providing
      the following additional features:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Events filtering</emphasis>.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Events collection</emphasis>.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Event Driven POJOs</emphasis>.</para>
        </listitem>
      </itemizedlist>

      <sect4 id="filtering-events">
        <title id="filtering-events-title">Filtering Events</title>

        <para>Filtering events is important when your application generates a
        great number of different events and you want your listeners to be
        notified only of those events they are interested to. </para>

        <para>The XT Modeling Framework provides two key classes for enabling
        events filtering capabilities:</para>

        <itemizedlist>
          <listitem>
            <para>The <emphasis
            role="bold">FilteringApplicationEventMulticaster</emphasis> (see
            <emphasis>org.springmodules.xt.model.event.filtering.FilteringApplicationEventMulticaster</emphasis>
            javadoc).</para>
          </listitem>

          <listitem>
            <para>The <emphasis
            role="bold">FilteringApplicationListener</emphasis> (see
            <emphasis>org.springmodules.xt.model.event.filtering.FilteringApplicationListener</emphasis>
            javadoc).</para>
          </listitem>
        </itemizedlist>

        <para>The FilteringApplicationEventMulticaster is an <ulink
        url="http://www.springframework.org/docs/api/org/springframework/context/event/ApplicationEventMulticaster.html">ApplicationEventMulticaster</ulink>
        implementation that used in conjunction with
        FilteringApplicationListener implementations permits to efficiently
        filter published events, in order to avoid notifying
        <emphasis>every</emphasis> listener of <emphasis>every</emphasis>
        published event.</para>

        <para>The FilteringApplicationListener interface defines supported
        events, providing a clear separation between event processing and
        event filtering logic: </para>

        <programlisting>public interface FilteringApplicationListener extends ApplicationListener {
    
    public Class[] getSupportedEventClasses();
    
    public boolean accepts(ApplicationEvent event);
}</programlisting>

        <itemizedlist>
          <listitem>
            <para><emphasis>public Class[]
            getSupportedEventClasses()</emphasis> : defines supported event
            classes.</para>
          </listitem>

          <listitem>
            <para><emphasis>public boolean accepts(ApplicationEvent
            event)</emphasis> : defines the actual filtering logic, often
            based on event state.</para>
          </listitem>
        </itemizedlist>

        <para>Concrete FilteringApplicationListener implementations must then
        be registered to a FilteringApplicationEventMulticaster.</para>

        <para>Once events gets published through the
        FilteringApplicationEventMulticaster, it will notify each registered
        FilteringApplicationListener implementation only of those events whose
        class is supported by the given listener, and that are accepted by the
        listener itself.</para>

        <note>
          <para>The FilteringApplicationEventMulticaster filters events only
          for registered FilteringApplicationListener implementations;
          however, it is possible to register other <ulink
          url="http://www.springframework.org/docs/api/org/springframework/context/ApplicationListener.html">ApplicationListener</ulink>
          implementations, losing filtering capabilities: those
          ApplicationListeners will be notified (as always) of every published
          event.</para>
        </note>
      </sect4>

      <sect4 id="collecting-events">
        <title id="filtering-events-title">Collecting Events</title>

        <para>While standard <ulink
        url="http://www.springframework.org/docs/api/org/springframework/context/ApplicationListener.html">ApplicationListener</ulink>
        implementations directly process events once they get notified,
        <emphasis>event collectors</emphasis> are special ApplicationListeners
        that collect and store published events, in order to provide FIFO
        (First In First Out) access to external, interested, objects.</para>

        <para>Event collectors all share the following interface: </para>

        <programlisting>public interface ApplicationCollector extends ApplicationListener {
    
    public ApplicationEvent pollEvent();
    
    public List&lt;ApplicationEvent&gt; getEvents();
    
    public void clear();
}</programlisting>

        <itemizedlist>
          <listitem>
            <para><emphasis>public ApplicationEvent pollEvent()</emphasis> :
            poll the first collected event, removing it from the queue of
            collected events.</para>
          </listitem>

          <listitem>
            <para><emphasis>public List&lt;ApplicationEvent&gt;
            getEvents()</emphasis> : get all collected events, without
            removing them from the queue of collected events.</para>
          </listitem>

          <listitem>
            <para><emphasis>public void clear()</emphasis> : clear all
            collected events.</para>
          </listitem>
        </itemizedlist>

        <para>Once registered into an ApplicationEventMulticaster as with any
        other ApplicationListener, ApplicationCollector implementations will
        start to collect notified events.</para>

        <para> The XT Modeling Framework provides several, ready to use,
        ApplicationCollector implementations:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis role="bold">SimpleCollector</emphasis> (see
            <emphasis>org.springmodules.xt.model.event.collector.SimpleCollector</emphasis>
            javadoc) : simple, non thread safe, ApplicationCollector
            implementation that simply collect events in a queue.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">ThreadLocalCollector</emphasis> (see
            <emphasis>org.springmodules.xt.model.event.collector.ThreadLocalCollector</emphasis>
            javadoc) : thread safe ApplicationCollector implementation storing
            collected events with per-thread scope.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">BlockingCollector</emphasis> (see
            <emphasis>org.springmodules.xt.model.event.collector.BlockingCollector</emphasis>
            javadoc) : thread safe, synchronous, ApplicationCollector
            implementation that blocks when polling for events if no event is
            actually available.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">ConcurrentCollector</emphasis> (see
            <emphasis>org.springmodules.xt.model.event.collector.ConcurrentCollector</emphasis>
            javadoc) : synchronized ApplicationCollector implementation that
            wraps another non thread safe collector, in order to make it
            possible to safely share it among threads. </para>
          </listitem>
        </itemizedlist>
      </sect4>

      <sect4 id="edp">
        <title id="edp-title">Event Driven POJOs</title>

        <para><emphasis role="bold">Event Driven POJO</emphasis>s (<emphasis
        role="bold">EDPs</emphasis>) are a powerful XT Modeling Framework
        feature that makes whatever application-specific object capable of
        processing events published through a Spring
        ApplicationEventMulticaster in a completely <emphasis
        role="bold">transparent non-invasive way</emphasis> , without having
        to implement any Spring specific interface. </para>

        <para>So, an EDP is a plain old (framework agnostic) Java object with
        methods invoked on event publishing.</para>

        <para>For enabling EDPs in your application, you have to configure an
        <emphasis role="bold">EDPInvoker</emphasis> (see
        <emphasis>org.springmodules.xt.model.event.edp.EDPInvoker</emphasis>
        javadoc) for every bean you want to make an EDP.</para>

        <para>The EDPInvoker defines:</para>

        <itemizedlist>
          <listitem>
            <para>The invoked EDP bean.</para>
          </listitem>

          <listitem>
            <para>The name of the method to invoke on published events.</para>
          </listitem>
        </itemizedlist>

        <para>More specifically, the XT Modeling Framework provides the
        <emphasis role="bold">DefaultEDPInvoker</emphasis> (see
        <emphasis>org.springmodules.xt.model.event.edp.DefaultEDPInvoker</emphasis>
        javadoc), which, once configured the EDP bean to use and the name of
        the method to invoke, will actually invoke the EDP if the bean has a
        method with name equal to the configured one, and that accepts a
        single parameter whose type is the same as, or is a super
        class/interface of, the published event. </para>

        <note>
          <para>Please note that if the EDP bean provides several overloaded
          implementations of the invokable method, the DefaultEDPInvoker will
          invoke <emphasis role="bold">all</emphasis> methods supporting a
          given published event, that is, all methods accepting a parameter
          whose type is the same as, or is a super class/interface of the
          published event type.</para>
        </note>

        <para>So, given the following POJO:</para>

        <programlisting>public class SimpleBean {
    
    // <emphasis role="bold">This is the method that will be invoked</emphasis>
    public void onEvent(CustomEvent event) {
        // ...
    }
}</programlisting>

        <para>Here is how to configure a DefaultEDPInvoker for invoking the
        SimpleBean on publishing of CustomEvent events:</para>

        <programlisting>&lt;!-- <emphasis role="bold">The EDP to invoke</emphasis> --&gt;
&lt;bean id="simpleBean" class="org.example.SimpleBean"&gt;

&lt;!-- <emphasis role="bold">The EDP invoker</emphasis> --&gt;
&lt;bean id="edpInvoker" class="org.springmodules.xt.model.event.edp.DefaultEDPInvoker"&gt;
    &lt;!-- <emphasis role="bold">The bean configuration</emphasis> --&gt;
    &lt;property name="invokedBean" ref="simpleBean"/&gt;
    &lt;!-- <emphasis role="bold">The method name configuration</emphasis> --&gt;
    &lt;property name="invokedMethodName" value="onEvent"/&gt;
&lt;/bean&gt;

</programlisting>

        <tip>
          <para>If you want an EDPInvoker with filtering capabilities, to use
          with a FilteringApplicationEventMulticaster, you can pick the
          FilteringEDPInvoker: see the
          <emphasis>org.springmodules.xt.model.event.edp.FilteringEDPInvoker</emphasis>
          javadoc for more information.</para>
        </tip>
      </sect4>
    </sect3>
  </sect2>

  <sect2 id="modeling-advanced">
    <title id="modeling-advanced-title">Advanced Concepts</title>

    <sect3 id="modeling-annotations">
      <title id="modeling-annotations-title">Other annotations</title>

      <sect4 id="DynamicIntroductor-Annotations">
        <title id="DynamicIntroductor-Annotations-title">DynamicIntroductor
        Annotations</title>

        <para>DynamicIntroductor concrete implementations let you modify the
        standard introductor behaviour by applying the following annotations
        on introduced interfaces:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis
            role="bold">org.springmodules.xt.model.introductor.annotation.MapToTargetField</emphasis>
            : Determines if a setter or getter method directly maps to the
            corresponding field in the target class. I.E., if this annotation
            is applied to a <emphasis>getName()</emphasis> method, the
            introductor will have to access the <emphasis>name</emphasis>
            attribute in the target object.</para>
          </listitem>

          <listitem>
            <para><emphasis
            role="bold">org.springmodules.xt.model.introductor.annotation.OverrideTarget</emphasis>
            : Determines if a method of an introduced interface must always
            override the corresponding method in the target class. The two
            methods must have equal signature.</para>
          </listitem>
        </itemizedlist>

        <para>Please read the javadoc of DynamicIntroductor implementations to
        verify supported annotations.</para>
      </sect4>
    </sect3>

    <sect3 id="specification-adapters">
      <title id="specification-adapters-title">Apache Commons Predicates
      integration</title>

      <para>The XT Modeling Framework provides ways for adapting generic
      Specification interfaces, as well as the XT <link
      linkend="specifications">Specification</link> interfaces, to the well
      known <ulink
      url="http://jakarta.apache.org/commons/collections/api-release/org/apache/commons/collections/Predicate.html"><citetitle>Apache
      Commons Predicate</citetitle></ulink> interface through the use of two
      Adapter objects: <link
      linkend="PredicateGenericAdapter">PredicateGenericAdapter</link> and
      <link
      linkend="PredicateCompositeAdapter">PredicateCompositeAdapter</link>.</para>

      <sect4 id="PredicateGenericAdapter">
        <title id="PredicateGenericAdapter-title">Using the
        PredicateGenericAdapter</title>

        <para>The
        <emphasis>org.springmodules.xt.model.specifications.adapter.PredicateGenericAdapter</emphasis>
        adapts generic specification objects to the Apache Commons Predicate
        interface.</para>

        <para>You can construct the adapter using one of the two
        constructors:</para>

        <programlisting>
public PredicateGenericAdapter(Object specification, Method specificationMethod)
</programlisting>

        <programlisting>
public PredicateGenericAdapter(Object specification, String specificationMethod)
</programlisting>

        <para>The constructor requires the specification object to adapt and
        the specification method to call for evaluating the Predicate.</para>

        <para>Once constructed, the Predicate adapter can be evaluated through
        the standard <ulink
        url="http://jakarta.apache.org/commons/collections/api-release/org/apache/commons/collections/Predicate.html#evaluate(java.lang.Object)">evaluate(Object
        )</ulink> method.</para>
      </sect4>

      <sect4 id="PredicateCompositeAdapter">
        <title id="PredicateCompositeAdapter-title">Using the
        PredicateCompositeAdapter</title>

        <para>The
        <emphasis>org.springmodules.xt.model.specifications.adapter.PredicateCompositeAdapter</emphasis>
        adapts the XT <link linkend="composite-specifications">Composite
        Specification</link> to the Apache Commons Predicate interface.</para>

        <para>You can construct the adapter using the following
        constructor:</para>

        <programlisting>
public PredicateCompositeAdapter(CompositeSpecification specification)
</programlisting>

        <para>The constructor requires the CompositeSpecification object to
        adapt.</para>

        <para>Once constructed, the Predicate adapter can be evaluated through
        the standard <ulink
        url="http://jakarta.apache.org/commons/collections/api-release/org/apache/commons/collections/Predicate.html#evaluate(java.lang.Object)">evaluate(Object
        )</ulink> method.</para>
      </sect4>
    </sect3>
  </sect2>
</sect1>