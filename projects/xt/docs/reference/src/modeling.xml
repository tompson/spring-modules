<?xml version="1.0" encoding="UTF-8"?>
<sect1 id="modeling">
  <title>XT Modeling Framework</title>

  <sect2 id="modeling-intro">
    <title id="modeling-intro-title">Introduction</title>

    <para>XT Modeling Framework provides several facilities for constructing
    rich domain models which gracefully collaborate and interact with other
    layers and components in your application. It comprises different parts
    we'll illustrate in the section below.</para>
  </sect2>

  <sect2 id="modeling-base">
    <title id="modeling-base-title">Base Concepts</title>

    <sect3 id="introductor">
      <title id="introductor-title">Introductor</title>

      <para>The XT <emphasis>Introductor</emphasis> permits you to make
      existent objects implementing additional interfaces defined at runtime,
      that is, it <emphasis>introduces</emphasis> new interfaces into already
      existent Plain Old Java Objects. This is achieved through the use of
      <ulink
      url="http://www.springframework.org/documentation"><citetitle>Spring
      AOP</citetitle></ulink> <emphasis>Introduction</emphasis>, for creating
      proxy objects that behave like the original one but also implement new
      interfaces.</para>

      <sect4 id="dynamicintroductor">
        <title id="dynamicintroductor-title">DynamicIntroductor</title>

        <para>The core interface is the <emphasis
        role="bold">DynamicIntroductor</emphasis> (see
        <emphasis>org.springmodules.xt.model.introductor.DynamicIntroductor</emphasis>
        javadoc):</para>

        <programlisting>
public interface DynamicIntroductor {

    public Object introduceInterfaces(Object target, Class[] introducedInterfaces);

    public Object introduceInterfaces(Object target, Class[] introducedInterfaces, 
                                      Class[] targetInterfaces);

    public Object getTarget(Object proxy);
}</programlisting>

        <itemizedlist>
          <listitem>
            <para><emphasis>public Object introduceInterfaces(Object target,
            Class[] introducedInterfaces)</emphasis> : Introduce to the given
            target object a set of interfaces defined at runtime. The
            resulting proxy object <emphasis role="bold">extends</emphasis>
            the target object class.</para>
          </listitem>

          <listitem>
            <para><emphasis>public Object introduceInterfaces(Object target,
            Class[] introducedInterfaces, Class[] targetInterfaces)</emphasis>
            : Introduce to the given target object a set of interfaces defined
            at runtime. The resulting proxy object <emphasis
            role="bold">implements</emphasis> a set of target interfaces
            defined at runtime (without extending the target object).</para>
          </listitem>

          <listitem>
            <para><emphasis>public Object getTarget(Object proxy)</emphasis> :
            Get the original target object from the proxied (introduced)
            one.</para>
          </listitem>
        </itemizedlist>
      </sect4>

      <sect4 id="dynamicbeanintroductor">
        <title
        id="dynamicbeanintroductor-title">DynamicBeanIntroductor</title>

        <para>The <emphasis role="bold">DynamicBeanIntroductor</emphasis> (see
        <emphasis>org.springmodules.xt.model.introductor.bean.DynamicBeanIntroductor</emphasis>
        javadoc) is a concrete implementation for introducing
        <emphasis>JavaBeans-style</emphasis> interfaces with getter/setter
        methods into already existent <emphasis role="bold">target</emphasis>
        objects. You can introduce any interface <emphasis
        role="bold">without</emphasis> manually implementing it, because its
        getter/setter methods will be automatically implemented; the only
        <emphasis role="bold">constraints</emphasis> to follow when using the
        DynamicBeanIntroductor are to not introduce interfaces with methods
        different than getter or setters, and to not use primitive types as
        getter return types, using instead their object wrappers.</para>

        <para>For example, take this Employee object:</para>

        <programlisting>
public class Employee implements IEmployee {

    private String matriculationCode;
    private String firstname;
    private String surname;

    public String getFirstname() {
        return firstname;
    }

    public void setFirstname(String firstname) {
        this.firstname = firstname;
    }

    public String getSurname() {
        return surname;
    }

    public void setSurname(String surname) {
        this.surname = surname;
    }

    public String getMatriculationCode() {
        return matriculationCode;
    }

    public void setMatriculationCode(String matriculationCode) {
        this.matriculationCode = matriculationCode;
    }
}
</programlisting>

        <para>You can automatically introduce the following interface:</para>

        <programlisting>
public interface EmployeeView {

    void setOffice(Office office);

    Office getOffice();

    void setSelected(Boolean selected);

    Boolean isSelected();
}
</programlisting>

        <para>By simply doing:</para>

        <programlisting>
IEmployee employee = new Employee();

DynamicBeanIntroductor introductor =  new DynamicBeanIntroductor();

Object newEmployee = introductor.introduceInterfaces(employee, 
                                                     new Class[]{EmployeeView.class});
</programlisting>

        <para>You can now use your brand new object:</para>

        <programlisting>
IEmployee employee = (IEmployee) newEmployee;
EmployeeView view = (EmployeeView) newEmployee;

employee.setMatriculationCode(...);
view.setSelected(...);</programlisting>

        <para>When calling methods on an object created through the
        DynamicBeanIntroductor, the following happens:</para>

        <itemizedlist>
          <listitem>
            <para>Every call to a getter/setter method declared into the
            introduced interface is delegated to the target object if this
            declares and implements a public method with equal signature,
            otherwise it is automatically implemented by the proxy.</para>
          </listitem>

          <listitem>
            <para>Every call to a non getter/setter method declared into the
            introduced interface throws an exception.</para>
          </listitem>

          <listitem>
            <para>Every call to a method not declared into the introduced
            interface is directly delegated to the target object.</para>
          </listitem>
        </itemizedlist>

        <para>Moreover, the DynamicBeanIntroductor behaviour can be
        customized: see <link
        linkend="DynamicIntroductor-Annotations">DynamicIntroductor
        annotations</link>.</para>
      </sect4>

      <sect4 id="dynamicbeanintroductor">
        <title
        id="dynamicbeanintroductor-title">DynamicImplementorIntroductor</title>

        <para>The <emphasis
        role="bold">DynamicImplementorIntroductor</emphasis> (see
        <emphasis>org.springmodules.xt.model.introductor.implementor.DynamicImplementorIntroductor</emphasis>
        javadoc) is a concrete implementation for introducing additional
        interfaces into already existent <emphasis
        role="bold">target</emphasis> objects and delegate the implementation
        of those interfaces to an external Java object called <emphasis
        role="bold">implementor</emphasis>.</para>

        <para>For example, take this Manager object:</para>

        <programlisting>
public class Manager implements IManager {
    
    private List&lt;IEmployee&gt; managedEmployees;
    private String matriculationCode;
    
    public void setManagedEmployees(List&lt;IEmployee&gt; employees) {
        this.managedEmployees = employees;
    }
    
    public List&lt;IEmployee&gt; getManagedEmployees() {
        return this.managedEmployees;
    }
}</programlisting>

        <para>You can introduce the following interface:</para>

        <programlisting>
public interface IEmployee {
    
    String getMatriculationCode();
    
    String getFirstname();

    String getSurname();
    
    void setMatriculationCode(String matriculationCode);

    void setFirstname(String firstname);

    void setSurname(String surname);
}</programlisting>

        <para>With the following implementation:</para>

        <programlisting>
public class Employee implements IEmployee {

    private String matriculationCode;
    private String firstname;
    private String surname;

    public String getFirstname() {
        return firstname;
    }

    public void setFirstname(String firstname) {
        this.firstname = firstname;
    }

    public String getSurname() {
        return surname;
    }

    public void setSurname(String surname) {
        this.surname = surname;
    }

    public String getMatriculationCode() {
        return matriculationCode;
    }

    public void setMatriculationCode(String matriculationCode) {
        this.matriculationCode = matriculationCode;
    }
}
</programlisting>

        <para>By simply doing:</para>

        <programlisting>
IManager manager = new Manager();
IEmployee employee = new Employee();
DynamicImplementorIntroductor introductor  = new DynamicImplementorIntroductor(employee); <emphasis
            role="bold">// (1)</emphasis>

Object newManager = introductor.introduceInterfaces(manager, 
                                                    new Class[]{IEmployee.class}); // <emphasis
            role="bold">(2)</emphasis></programlisting>

        <para>You have to simply construct the
        <emphasis>DynamicImplementorIntroductor</emphasis> object (1) by
        passing it the <emphasis>implementor</emphasis> object, that is, the
        object that will implement the interfaces to introduce. Then, you have
        to actually introduce the interfaces into the
        <emphasis>target</emphasis> object (2).</para>

        <para>You can now use your brand new object:</para>

        <programlisting>
IManager manager = (IManager) newManager;
IEmployee employee = (IEmployee) newManager;

manager.setManagedEmployees(...);
employee.setMatriculationCode(...);</programlisting>

        <para>When calling methods on an object created through the
        DynamicImplementorIntroductor, the following happens:</para>

        <itemizedlist>
          <listitem>
            <para>Every call to a method declared into an introduced interface
            will be delegated to the <emphasis
            role="bold">implementor</emphasis> object if it implements the
            introduced interface; otherwise, an exception occurs.</para>
          </listitem>

          <listitem>
            <para>Every call to a method not declared into the introduced
            interface is as always executed by the <emphasis
            role="bold">target</emphasis> object.</para>
          </listitem>
        </itemizedlist>
      </sect4>

      <sect4 id="introductor-collections">
        <title id="introductor-collections-title">Introductor
        Collections</title>

        <para>Introductor Collections (see
        <emphasis>org.springmodules.xt.model.introductor.collections</emphasis>
        javadocs) are <ulink
        url="http://java.sun.com/docs/books/tutorial/collections/index.html"><citetitle>Java
        Collections</citetitle></ulink> decorators that apply Dynamic
        Introductors to contained objects. You can decorate a Java <ulink
        url="http://java.sun.com/docs/books/tutorial/collections/interfaces/index.html"><citetitle>Collection</citetitle></ulink>,
        <ulink
        url="http://java.sun.com/docs/books/tutorial/collections/interfaces/index.html"><citetitle>Set</citetitle></ulink>,
        or <ulink
        url="http://java.sun.com/docs/books/tutorial/collections/interfaces/index.html"><citetitle>List</citetitle></ulink>.
        Here is how you construct an Introductor Collection:</para>

        <programlisting>
public IntroductorCollection(Collection target, Class[] introducedInterfaces, 
                             Class[] targetObjectsInterfaces, DynamicIntroductor introductor);

public IntroductorCollection(Collection target, Class[] interfaces, 
                             DynamicIntroductor introductor);

public IntroductorSet(Collection target, Class[] introducedInterfaces, 
                      Class[] targetObjectsInterfaces, DynamicIntroductor introductor);

public IntroductorSet(Collection target, Class[] interfaces, 
                      DynamicIntroductor introductor);

public IntroductorList(Collection target, Class[] introducedInterfaces, 
                       Class[] targetObjectsInterfaces, DynamicIntroductor introductor);

public IntroductorList(Collection target, Class[] interfaces, 
                       DynamicIntroductor introductor);
</programlisting>

        <para>You can specify the following constructor parameters:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>Collection target</emphasis> : The target
            collection to decorate</para>
          </listitem>

          <listitem>
            <para><emphasis>Class[] introducedInterfaces</emphasis> : The
            interfaces to introduce into every contained object.</para>
          </listitem>

          <listitem>
            <para><emphasis>Class[] targetObjectsInterfaces</emphasis> : The
            interfaces of the target object that the proxy object must
            implement.</para>
          </listitem>

          <listitem>
            <para><emphasis>DynamicIntroductor introductor</emphasis> : The
            Dynamic Introductor to use.</para>
          </listitem>
        </itemizedlist>

        <para>You can safely add and remove objects to and from Introductor
        Collections like they were normal collections: all changes are backed
        by the original non-decorated collection. Every object you get from an
        Introductor Collection implements a given set of interfaces using a
        particular, concrete, Dynamic Introductor, but <emphasis
        role="bold">note</emphasis> that objects stored in the original
        collection <emphasis role="bold">are not modified</emphasis>.</para>
      </sect4>
    </sect3>

    <sect3 id="generator">
      <title id="generator-title">Generator</title>

      <para>The XT <emphasis>Generator</emphasis> let you generate Java
      objects starting from simple Java interfaces.</para>

      <sect4 id="dynamicgenerator">
        <title id="dynamicgenerator-title">DynamicGenerator</title>

        <para>The core interface is the <emphasis
        role="bold">DynamicGenerator</emphasis> (see
        <emphasis>org.springmodules.xt.model.generator.DynamicGenerator</emphasis>
        javadoc):</para>

        <programlisting>
public interface DynamicGenerator&lt;T&gt; {

    public T generate();
}

</programlisting>

        <itemizedlist>
          <listitem>
            <para><emphasis>public T generate()</emphasis> : Generate an
            object of generic type <emphasis>T.</emphasis></para>
          </listitem>
        </itemizedlist>

        <para>Given its simple and generic interface, the DynamicGenerator can
        be used to generate all kind of objects.</para>
      </sect4>

      <sect4 id="dynamicfactorygenerator">
        <title
        id="dynamicfactorygenerator-title">DynamicFactoryGenerator</title>

        <para>The <emphasis role="bold">DynamicFactoryGenerator</emphasis>
        (see
        <emphasis>org.springmodules.xt.model.generator.factory.DynamicFactoryGenerator</emphasis>
        javadoc) is a concrete implementation for generating factory objects
        by simply providing a plain Java interface with a number of setter
        methods, representing constructor arguments and properties to use for
        constructing and assembling the <emphasis>product object</emphasis>,
        and a factory method returning the class (or superclass) of that
        object.</para>

        <para>Going into details, the factory interface methods must obey the
        following rules:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis role="bold">Setter</emphasis> methods must be
            annotated either with the <emphasis
            role="bold">ConstructorArg</emphasis> (see
            <emphasis>org.springmodules.xt.model.generator.annotation.ConstructorArg</emphasis>
            javadoc) annotation if they are constructor arguments, or with the
            <emphasis role="bold">Property</emphasis> (see
            <emphasis>org.springmodules.xt.model.generator.annotation.Property</emphasis>
            javadoc) annotation if they are properties to be set.</para>
          </listitem>

          <listitem>
            <para>The <emphasis role="bold">factory</emphasis> method must be
            annotated with the <emphasis role="bold">FactoryMethod</emphasis>
            (see
            <emphasis>org.springmodules.xt.model.generator.annotation.FactoryMethod</emphasis>
            javadoc) annotation.</para>
          </listitem>
        </itemizedlist>

        <para>Any other method, if called, will throw an exception.</para>

        <para>So here is a simple annotated interface:</para>

        <programlisting>
public interface EmployeeFactory {
    
    @ConstructorArg(position = 0)
    void setNickname(String nickname);
    
    @ConstructorArg(position = 1)
    void setMatriculationCode(String matriculationCode);
    
    @Property(access = Property.AccessType.FIELD)
    void setFirstname(String firstname);
    
    @Property()
    void setSurname(String surname);
    
    @FactoryMethod()
    IEmployee make();
}
</programlisting>

        <para>And here is how to use it with the
        DynamicFactoryGenerator:</para>

        <programlisting>                    
// <emphasis role="bold">Generate an EmployeeFactory for creating Employees</emphasis>:
DynamicFactoryGenerator&lt;EmployeeFactory, Employee&gt; generator = 
    new DynamicFactoryGenerator(EmployeeFactory.class, Employee.class);

// <emphasis role="bold">Actually generates the factory</emphasis>:
EmployeeFactory factory = generator.generate();

// <emphasis role="bold">Set values for constructing and assembling the employee:</emphasis>
factory.setNickname("SB");
factory.setMatriculationCode("111");
factory.setFirstname("Sergio");
factory.setSurname("Bossa");

<emphasis role="bold">// Actually creates the employee:</emphasis>
IEmployee emp = factory.make();
</programlisting>

        <note>
          <para>The DynamicFactoryGenerator generates a new factory object for
          every call to its <emphasis>generate</emphasis> method, and the
          factory generates a new product object for every call to its factory
          method.</para>
        </note>
      </sect4>
    </sect3>

    <sect3 id="notifications">
      <title id="notifications-title">Notifications</title>

      <para><ulink
      url="http://www.martinfowler.com/eaaDev/Notification.html"><citetitle>Notifications</citetitle></ulink>
      are lightweight objects capable of collecting and carrying messages
      between different application layers, even if most of the time they will
      carry messages toward the presentation layer.</para>

      <para>XT Notifications implementation is based on a
      <emphasis>Message</emphasis> interface and a
      <emphasis>Notification</emphasis> interface.</para>

      <sect4 id="the-message-interface">
        <title id="the-message-interface-title">The Message Interface</title>

        <para>The Message interface looks like this:</para>

        <programlisting>
public interface Message {

    public enum Type { ERROR, WARNING, INFO };

    public String getCode();

    public Message.Type getType();

    public String getPropertyName();

    public String getDefaultMessage();
}
</programlisting>

        <para>A message object can hold the following information:</para>

        <itemizedlist>
          <listitem>
            <para>A message type: <emphasis>ERROR</emphasis>,
            <emphasis>WARNING</emphasis> or <emphasis>INFO</emphasis>.</para>
          </listitem>

          <listitem>
            <para>A message code.</para>
          </listitem>

          <listitem>
            <para>A default message text.</para>
          </listitem>

          <listitem>
            <para>The name of an object property this message refers to, used
            for example when messages refer to validation errors.</para>
          </listitem>
        </itemizedlist>
      </sect4>

      <sect4 id="the-notification-interface">
        <title id="the-notification-interface-title">The Notification
        Interface</title>

        <para>The Notification interface looks like this:</para>

        <programlisting>
public interface Notification {

    public void addMessage(Message message);

    public boolean removeMessage(Message message);

    public Message[] getMessages(Message.Type type);

    public boolean hasMessages(Message.Type type);

    public Message[] getAllMessages();

    public boolean hasMessages();

    public void addAllMessages(Notification notification);
}
</programlisting>

        <para>It is indeed straightforward: you can add and remove Message
        objects, and ask for Messages of a given type.</para>

        <para>Notifications are best used together with <link
        linkend="specifications">Specifications</link>.</para>
      </sect4>
    </sect3>

    <sect3 id="specifications">
      <title id="specifications-title">Specifications</title>

      <para><ulink
      url="http://www.martinfowler.com/apsupp/spec.pdf"><citetitle>Specifications</citetitle></ulink>
      are predicate-like objects for powerfully expressing all kind of
      business/validation/selection rules and matching business objects
      against them.</para>

      <para>Every Specification implementation must have a boolean method for
      verifying if a business object satisfies the Specification rules.</para>

      <para>XT Specification implementation is based on the following
      interface:</para>

      <programlisting>
public interface Specification&lt;O&gt; {

    public boolean evaluate(O object);

    public boolean evaluate(O object, Notification notification);

    public void addMessage(Message message, boolean whenSatisfied);

    public boolean removeMessage(Message message, boolean whenSatisfied);
}
</programlisting>

      <para>The Specification has one generic type, <emphasis>O</emphasis>,
      representing the object type you want to evaluate.</para>

      <para>As you may note, you can specify what <link
      linkend="the-message-interface">Messages</link> will be thrown when the
      specification is satisfied or unsatisfied, and collect them into a <link
      linkend="notifications">Notification</link> object at evaluation
      time.</para>

      <sect4 id="composite-specifications">
        <title id="composite-specifications-title">Composite
        Specifications</title>

        <para>Composite Specifications let you compose your own specification
        objects through logical operators and define what <link
        linkend="the-message-interface">Messages</link> will be issued by what
        specifications when satisfied or unsatisfied, all using a nice <ulink
        url="http://www.martinfowler.com/bliki/FluentInterface.html"><citetitle>fluent
        interface</citetitle></ulink>.</para>

        <para>Other than this, the main advantage of using the Composite
        Specification is that you can combine your own specifications whatever
        their class is, without modifying one line of your code.</para>

        <para>Here is the CompositeSpecification interface:</para>

        <programlisting>
public interface CompositeSpecification&lt;S, O&gt; extends Specification&lt;O&gt; {

    public CompositeSpecification and(CompositeSpecification&lt;S, O&gt; specification);

    public CompositeSpecification and(S specification);

    public CompositeSpecification andNot(CompositeSpecification&lt;S, O&gt; specification);

    public CompositeSpecification andNot(S specification);

    public CompositeSpecification compose(S specification);

    public CompositeSpecification withMessage(Message message, boolean whenSatisfied);

    public boolean evaluate(O object);

    public CompositeSpecification or(CompositeSpecification&lt;S, O&gt; specification);

    public CompositeSpecification or(S specification);

    public CompositeSpecification orNot(CompositeSpecification&lt;S, O&gt; specification);

    public CompositeSpecification orNot(S specification);
}
</programlisting>

        <para>The CompositeSpecification has two generic types,
        <emphasis>S</emphasis> and <emphasis>O</emphasis>: the former
        represents the type of the specification you want to compose, the
        latter the type of the object you want to evaluate.</para>

        <para>Some code is worth a lot of words, so for taking a glimpse on
        how powerful a CompositeSpecification can be, say you have implemented
        these two specifications in your own application (not depending on the
        XT library):</para>

        <programlisting>
public class OfficeIdSpecification implements BaseSpecification&lt;IOffice&gt; {

    public boolean isSatisfiedBy(IOffice o) {
        return o.getOfficeId().matches("\\d+") || o.getOfficeId().matches("o\\d+"); 
    }

}
</programlisting>

        <programlisting>
public class FullOfficeSpecification implements BaseSpecification&lt;IOffice&gt; {

    private int limit = 3;

    public boolean isSatisfiedBy(IOffice o) {
        return o.getEmployees().size() &gt; this.limit; 
    }

}
</programlisting>

        <para>You can powerfully compose them in a composite specification by
        simply writing the following:</para>

        <programlisting>
// <emphasis role="bold">Create your business-specific specifications:</emphasis>
OfficeIdSpecification idSpecification = new OfficeIdSpecification();
FullOfficeSpecification fullOfficeSpecification = new FullOfficeSpecification();

// <emphasis role="bold">Create a CompositeSpecification for composing BaseSpecification specifications (your base class):</emphasis>
CompositeSpecification&lt;BaseSpecification, IOffice&gt; compositeSpecification = 
    new CompositeSpecificationImpl(BaseSpecification.class, "isSatisfiedBy");

// <emphasis role="bold">Create an error message for the wrong id:</emphasis>
Message wrongIdMessage = new MessageImpl(OfficeErrorCodes.WRONG_ID, 
    Message.Type.ERROR,
    "officeId",
    "Wrong office id");

// <emphasis role="bold">Create an error message for the full office:</emphasis>
Message fullOfficeMessage = new MessageImpl(OfficeErrorCodes.FULL,
Message.Type.ERROR,
    "employees", 
    "Too many employees");

// <emphasis role="bold">Compose all:</emphasis>
compositeSpecification.compose(idSpecification).withMessage(wrongIdMessage, false)
    .andNot(fullOfficeSpecification).withMessage(fullOfficeMessage, true);
</programlisting>

        <para>This will compose a specification matching an office that has a
        correct id and is not full.</para>
      </sect4>
    </sect3>
  </sect2>

  <sect2 id="modeling-advanced">
    <title id="modeling-advanced-title">Advanced Concepts</title>

    <sect3 id="modeling-annotations">
      <title id="modeling-annotations-title">Other annotations</title>

      <sect4 id="DynamicIntroductor-Annotations">
        <title id="DynamicIntroductor-Annotations-title">DynamicIntroductor
        Annotations</title>

        <para>DynamicIntroductor concrete implementations let you modify the
        standard introductor behaviour by applying the following annotations
        on introduced interfaces:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis
            role="bold">org.springmodules.xt.model.introductor.annotation.MapToTargetField</emphasis>
            : Determines if a setter or getter method directly maps to the
            corresponding field in the target class. I.E., if this annotation
            is applied to a <emphasis>getName()</emphasis> method, the
            introductor will have to access the <emphasis>name</emphasis>
            attribute in the target object.</para>
          </listitem>

          <listitem>
            <para><emphasis
            role="bold">org.springmodules.xt.model.introductor.annotation.OverrideTarget</emphasis>
            : Determines if a method of an introduced interface must always
            override the corresponding method in the target class. The two
            methods must have equal signature.</para>
          </listitem>
        </itemizedlist>

        <para>Please read the javadoc of DynamicIntroductor implementations to
        verify supported annotations.</para>
      </sect4>
    </sect3>

    <sect3 id="specification-adapters">
      <title id="specification-adapters-title">Apache Commons Predicates
      integration</title>

      <para>The XT Modeling Framework provides ways for adapting generic
      Specification interfaces, as well as the XT <link
      linkend="specifications">Specification</link> interfaces, to the well
      known <ulink
      url="http://jakarta.apache.org/commons/collections/api-release/org/apache/commons/collections/Predicate.html"><citetitle>Apache
      Commons Predicate</citetitle></ulink> interface through the use of two
      Adapter objects: <link
      linkend="PredicateGenericAdapter">PredicateGenericAdapter</link> and
      <link
      linkend="PredicateCompositeAdapter">PredicateCompositeAdapter</link>.</para>

      <sect4 id="PredicateGenericAdapter">
        <title id="PredicateGenericAdapter-title">Using the
        PredicateGenericAdapter</title>

        <para>The
        <emphasis>org.springmodules.xt.model.specifications.adapter.PredicateGenericAdapter</emphasis>
        adapts generic specification objects to the Apache Commons Predicate
        interface.</para>

        <para>You can construct the adapter using one of the two
        constructors:</para>

        <programlisting>
public PredicateGenericAdapter(Object specification, Method specificationMethod)
</programlisting>

        <programlisting>
public PredicateGenericAdapter(Object specification, String specificationMethod)
</programlisting>

        <para>The constructor requires the specification object to adapt and
        the specification method to call for evaluating the Predicate.</para>

        <para>Once constructed, the Predicate adapter can be evaluated through
        the standard <ulink
        url="http://jakarta.apache.org/commons/collections/api-release/org/apache/commons/collections/Predicate.html#evaluate(java.lang.Object)">evaluate(Object
        )</ulink> method.</para>
      </sect4>

      <sect4 id="PredicateCompositeAdapter">
        <title id="PredicateCompositeAdapter-title">Using the
        PredicateCompositeAdapter</title>

        <para>The
        <emphasis>org.springmodules.xt.model.specifications.adapter.PredicateCompositeAdapter</emphasis>
        adapts the XT <link linkend="composite-specifications">Composite
        Specification</link> to the Apache Commons Predicate interface.</para>

        <para>You can construct the adapter using the following
        constructor:</para>

        <programlisting>
public PredicateCompositeAdapter(CompositeSpecification specification)
</programlisting>

        <para>The constructor requires the CompositeSpecification object to
        adapt.</para>

        <para>Once constructed, the Predicate adapter can be evaluated through
        the standard <ulink
        url="http://jakarta.apache.org/commons/collections/api-release/org/apache/commons/collections/Predicate.html#evaluate(java.lang.Object)">evaluate(Object
        )</ulink> method.</para>
      </sect4>
    </sect3>
  </sect2>
</sect1>