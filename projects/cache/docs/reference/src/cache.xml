<?xml version="1.0" encoding="UTF-8"?>
<chapter id="cache">
  <title>Caching</title>

  <sect1 id="cache-introduction">
    <title>Introduction</title>

    <para>
      The
      <emphasis>Caching Module</emphasis>
      provides a consistent abstraction for performing caching, delivering the
      following benefits.
    </para>

    <itemizedlist>
      <listitem>
        <para>
          Provides a consistent programming model across different caching APIs 
          such as <ulink url="http://ehcache.sourceforge.net/">EHCache</ulink>, 
          <ulink url="http://www.jboss.com/products/jbosscache">JBoss Cache</ulink>, 
          <ulink url="http://jakarta.apache.org/jcs/">Java Caching System (JCS)</ulink>
          and <ulink url="http://www.opensymphony.com/oscache">OSCache</ulink>.
        </para>
      </listitem>
      <listitem>  
        <para>
          Provides a unified, simpler, easier to use, API for programmatic use of 
          caching services than most of these previously mentioned APIs.
        </para>
      </listitem>
      <listitem>
        <para>
          Supports different strategies for declarative caching services.
        </para>
      </listitem>
      <listitem>
        <para>
         The <emphasis>Caching Module</emphasis> may be easily extended to 
         support additional cache providers.
        </para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="cache-uses">
    <title>Uses</title>

    <para>
      Caching is frequently used to improve application performance. A
      good example is the caching of data retrieved from a database.
      Even though ORM frameworks such as
      <ulink url="http://www.ibatis.com/">iBATIS</ulink>
      and
      <ulink url="http://www.hibernate.org/">Hibernate</ulink>
      already provide built-in caching, the
      <emphasis>Caching Module</emphasis>
      can be useful when executing methods that perform heavy
      calculations, are time consuming, and/or are resource hungry.
    </para>

    <para>
      Caching can be added to frameworks without inherent caching
      support, such as JDBC or
      <ulink
        url="http://www.springframework.org/docs/reference/jdbc.html">
        Spring JDBC</ulink>.
    </para>

    <para>
      The <emphasis>Caching Module</emphasis> may be used to have more control 
      over your caching provider.
    </para>

  </sect1>

  <sect1>
    <title>Configuration</title>

    <para>
      Caching and cache-flushing can be easily configured by following
      the following steps.
    </para>

    <orderedlist>
      <listitem>
        <para>
          <emphasis role="bold">Set up the cache provider.</emphasis>
          Instead of imposing the use of a particular cache
          implementation, the
          <emphasis>Caching Module</emphasis>
          lets you choose a cache provider that best suites the needs of
          your project.
        </para>
      </listitem>

      <listitem>
        <para>
          <emphasis role="bold">Enable the caching services.</emphasis>
          The <emphasis>Caching Module</emphasis> provides two ways to enable 
          caching services.
        </para>

        <orderedlist>
          <listitem>
            <para>Declarative caching services.
              <itemizedlist>
                <listitem>
                  <para><literal>CacheProxyFactoryBean</literal>.</para>
                </listitem>
                <listitem>
                  <para>Source-level metadata attributes using 
                  <ulink
                    url="http://jakarta.apache.org/commons/attributes/">
                    Commons-Attributes</ulink>
                  or 
                  <ulink 
                    url="http://java.sun.com/j2se/1.5.0/docs/guide/language/annotations.html">
                  JDK 1.5+ Annotations</ulink>.</para>
                </listitem>
                <listitem>
                  <para>AutoProxy with 
                  <literal>MethodMapCachingInterceptor</literal>
                  and <literal>MethodMapFlushingInterceptor</literal>.</para>
                </listitem>
              </itemizedlist>
            </para>
          </listitem>

          <listitem>
            <para>
              Programmatic use (via a single interface,
              <literal>org.springmodules.cache.provider.CacheProviderFacade</literal>).
            </para>
          </listitem>
        </orderedlist>
      </listitem>
    </orderedlist>
  </sect1>

  <sect1 id="cache-setup-provider">
    <title>Cache Provider</title>

    <para>
      The
      <emphasis>Caching Module</emphasis>
      provides a common interface that centralizes the interactions
      with the underlying cache provider. Each facade must implement
      the interface 
      <literal>org.springmodules.cache.provider.CacheProviderFacade</literal>
      or subclass the template 
      <literal>org.springmodules.cache.provider.AbstractCacheProviderFacade</literal>.
    </para>

    <para>
      Each strategy has the following properties.
    </para>

    <orderedlist>
      <listitem>
        <para>
          <emphasis role="bold"><literal>cacheManager</literal> (required)</emphasis>
          <para>
            A cache manager administrates the cache. In general, a cache manager 
            should be able to:
          </para>
          <itemizedlist>
            <listitem>
              <para>Store objects in the cache.</para>
            </listitem>

            <listitem>
              <para>Retrieve objects from the cache.</para>
            </listitem>

            <listitem>
              <para>Remove objects from the cache.</para>
            </listitem>

            <listitem>
              <para>Flush or invalidate one or more regions of the cache, or the
              whole cache (depending on the cache provider.)</para>
            </listitem>
          </itemizedlist>
        </para>
        
        <para>
          The <emphasis>Caching Module</emphasis> provides factories that 
          allow setting up cache managers and ensure that the created cache 
          managers are properly released and destroyed before the Spring 
          application context is closed.
          
          <itemizedlist>
            <listitem>
              <para>
                <literal>org.springmodules.cache.provider.jboss.JbossCacheManagerFactoryBean</literal>
              </para>
            </listitem>
          </itemizedlist>
          <itemizedlist>
            <listitem>
              <para>
                <literal>org.springmodules.cache.provider.jcs.JcsManagerFactoryBean</literal>
              </para>
            </listitem>
          </itemizedlist>
          <itemizedlist>
            <listitem>
              <para>
                <literal>org.springmodules.cache.provider.oscache.OsCacheManagerFactoryBean</literal>
              </para>
            </listitem>
          </itemizedlist>
        
          These factories have a common, 
          <emphasis role="bold">optional</emphasis> property, 
          <emphasis role="bold"><literal>configLocation</literal></emphasis>,
          which can be any resource used for configuration of the cache manager, 
          such as a file or class path resource.
        </para>
      </listitem>

      <listitem>
        <para>
          <emphasis role="bold">
            <literal>failQuietlyEnabled</literal>
            (optional)
          </emphasis>
          <para>
            If <literal>true</literal>, any exception thrown at runtime by the 
            cache manager will not be rethrown, allowing applications to continue
            running even if the caching services fail. The default
            value is <literal>false</literal>: any exception thrown by the
            cache manager will be propagated and eventually will stop the
            execution of the application.
          </para>
        </para>
      </listitem>

      <listitem>
        <para>
          <emphasis role="bold">
            <literal>serializableFactory</literal>
            (optional)
          </emphasis>
          <para>
            Some cache providers, like EHCache and JCS, can only store objects
            that implement the <literal>java.io.Serializable</literal> interface,
            which may be necessary when storing objects in the file system or
            replicating changes in the cache to different nodes in a cluster.
          </para> 
          <para>
            Such requirement imposes a problem when we need to store in the cache 
            objects that are not <literal>Serializable</literal> and we do not 
            have control of, for example objects generated by JAXB.
          </para>
          <para>
            A possible solution could be to &quot;force&quot; serialization on 
            such objects. This can be achieved with
            a
            <literal>org.springmodules.cache.serializable.SerializableFactory</literal>.               
            The <emphasis>Caching Module</emphasis> currently provides one 
            strategy, 
            <literal>org.springmodules.cache.serializable.XStreamSerializableFactory</literal>,
            which uses 
            <ulink url="http://xstream.codehaus.org/">XStream</ulink> to
            <itemizedlist>
              <listitem>
                <para>Serialize objects to XML before being stored in the cache.</para>
              </listitem>
              <listitem>
                <para>Create objects back from XML after being retrieved from 
                the cache.</para>
              </listitem>
            </itemizedlist>
            This feature is disabled by default (the value of 
            <literal>serializableFactory</literal> is <literal>null</literal>.)
          </para>
        </para>
      </listitem>
    </orderedlist>

    <sect2>
      <title>EHCache</title>

      <para>
        <ulink url="http://ehcache.sourceforge.net/">EHCache</ulink> 
        can be used as cache provider through the facade 
        <literal>org.springmodules.cache.provider.ehcache.EhCacheFacade</literal>.
        It must have a <literal>net.sf.ehcache.CacheManager</literal>
        as the underlying cache manager.
      </para>

      <para>
        <programlisting>
&lt;!--  
  The created cache manager is an instance of net.sf.ehcache.CacheManager
--&gt;
&lt;bean id=&quot;cacheManager&quot;
  class=&quot;org.springframework.cache.ehcache.EhCacheManagerFactoryBean&quot;&gt;
&lt;/bean&gt;

&lt;bean id=&quot;cacheProviderFacade&quot;
  class=&quot;org.springmodules.cache.provider.ehcache.EhCacheFacade&quot;&gt;
  &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot; /&gt;
&lt;/bean&gt;</programlisting>
      </para>

      <para>
        For more details about using EHCache with Spring, please refer to 
        this excellent 
          <ulink
              url="http://opensource.atlassian.com/confluence/spring/display/DISC/Caching+the+result+of+methods+using+Spring+and+EHCache">
              article</ulink> by Omar Irbouh.
      </para>
    </sect2>

    <sect2>
      <title>JBoss Cache</title>

      <para>
        <ulink url="http://www.jboss.com/products/jbosscache">JBoss Cache</ulink>
        can be used as cache provider through the facade 
        <literal>org.springmodules.cache.provider.jboss.JbossCacheFacade</literal>.
        It must have a <literal>org.jboss.cache.TreeCache</literal>
        as the underlying cache manager.
      </para>

      <para>
        <programlisting>
&lt;!-- 
  The created cache manager is a singleton instance of org.jboss.cache.TreeCache
--&gt;
&lt;bean id=&quot;cacheManager&quot;
  class=&quot;org.springmodules.cache.provider.jboss.JbossCacheManagerFactoryBean&quot;&gt;
  &lt;!-- Optional properties --&gt;
  &lt;property name=&quot;configLocation&quot; value=&quot;classpath:org/springmodules/samples/cache-service.xml&quot; /&gt;                            
&lt;/bean&gt;

&lt;bean id=&quot;cacheProviderFacade&quot;
  class=&quot;org.springmodules.cache.provider.jboss.JbossCacheFacade&quot;&gt;
  &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot; /&gt;
&lt;/bean&gt;</programlisting>
      </para>
    </sect2>

    <sect2>
      <title>Java Caching System (JCS)</title>

      <para>
        <ulink url="http://jakarta.apache.org/jcs/">JCS</ulink>
        can be used as cache provider through the facade 
        <literal>org.springmodules.cache.provider.jcs.JcsFacade</literal>.
        It must have a <literal>org.apache.jcs.engine.control.CompositeCacheManager</literal>
        as the underlying cache manager.
      </para>

      <para>
        <programlisting>
&lt;!-- 
  The created cache manager is a singleton instance of org.apache.jcs.engine.control.CompositeCacheManager
--&gt;
&lt;bean id=&quot;cacheManager&quot;
  class=&quot;org.springmodules.cache.provider.jcs.JcsManagerFactoryBean&quot;&gt;
  &lt;!-- Optional properties --&gt;
  &lt;property name=&quot;configLocation&quot; value=&quot;classpath:org/springmodules/samples/jcs-config.properties&quot; /&gt;                            
&lt;/bean&gt;

&lt;bean id=&quot;cacheProviderFacade&quot;
  class=&quot;org.springmodules.cache.provider.jcs.JcsFacade&quot;&gt;
  &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot; /&gt;
&lt;/bean&gt;</programlisting>
      </para>
    </sect2>

    <sect2>
      <title>OSCache</title>

      <para>
        <ulink url="http://www.opensymphony.com/oscache">OSCache</ulink>
        can be used as cache provider through the facade 
        <literal>org.springmodules.cache.provider.oscache.OsCacheFacade</literal>.
        It must have a <literal>com.opensymphony.oscache.general.GeneralCacheAdministrator</literal>
        as the underlying cache manager
      </para>

      <para>
        <programlisting>
&lt;!-- 
  The created cache manager is a singleton instance of 
  com.opensymphony.oscache.general.GeneralCacheAdministrator
--&gt;
&lt;bean id=&quot;cacheManager&quot;
  class=&quot;org.springmodules.cache.provider.oscache.OsCacheManagerFactoryBean&quot;&gt;
  &lt;!-- Optional properties --&gt;
  &lt;property name=&quot;configLocation&quot; value=&quot;classpath:org/springmodules/samples/oscache-config.properties&quot; /&gt;                            
&lt;/bean&gt;

&lt;bean id=&quot;cacheProviderFacade&quot;
  class=&quot;org.springmodules.cache.provider.oscache.OsCacheFacade&quot;&gt;
  &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot; /&gt;
&lt;/bean&gt;</programlisting>
      </para>

      <para>
        Rob Harrop posted an
        <ulink
          url="http://opensource.atlassian.com/confluence/spring/display/INTEGRATE/OSCache">
          article</ulink>
        explaining how to set up OSCache in Spring without using any factory.
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>Declarative Caching Services</title>

    <para>
      The <emphasis>Caching Module</emphasis> offers declarative caching
      services powered by
      <ulink
        url="http://www.springframework.org/docs/reference/aop.html">Spring AOP</ulink>.
    </para>
    <para>
      <emphasis>
        Declarative caching services offers a non-invasive solution, eliminating
        any dependencies on any cache implementation from your Java code.
      </emphasis>
    </para>

    <para>
      The following sections describe the internal components common to 
      the different strategies for declarative caching services.
    </para>
      
    <sect2 id="cachingAdvice">
      <title>Caching Advice</title>
      <para>
        A <phrase id="cachingAdvicePhrase">caching advice</phrase> applies 
        caching to the return value of advised methods. It first
        checks that a value previously returned from a method call, with
        the same method arguments, is already stored in the cache. If a
        value is found, it will skip the method call and return the cached value. 
        On the other hand, if the advice cannot find a cached value, it will
        proceed with the method call, store the return value of the call in 
        the cache and finally return the new cached value.
      </para>
      
      <para>
        Methods that do not have a return value 
        (return value is <literal>void</literal>) are 
        ignored, even if they were registered for aspect weaving.
      </para>
    </sect2>
      
    <sect2 id="cachingModels">
      <title>Caching Models</title>
      <para>
        Caching models encapsulate the rules to be followed by the
        <emphasis>caching advice</emphasis> when accessing the cache
        for object storage or retrieval. The <emphasis>Caching Module</emphasis>
        provides caching models for each of the supported cache providers:
        <itemizedlist>
          <listitem>
            <para>
              <literal>org.springmodules.cache.provider.ehcache.EhCacheCachingModel</literal> 
              specifies the name of the cache to use.
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>org.springmodules.cache.provider.jboss.JbossCacheCachingModel</literal> 
                specifies the <emphasis>fully qualified name</emphasis> (FQN)
                of the node of the <literal>TreeCache</literal> to use.
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>org.springmodules.cache.provider.jcs.JcsCachingModel</literal>
              specifies the name of the cache and (optionally) the group to
              use.
            </para>
          </listitem> 
          <listitem>
            <para>
              <literal>org.springmodules.cache.provider.oscache.OsCacheCachingModel</literal>
              specifies the names of the groups to use, the cron expression to
              use to invalidate cache entries and the number of seconds that 
              the object can stay in cache.  All these properties are optional.
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>
        <emphasis>Caching advices</emphasis> can be configured to have
        <phrase id="cachingModelPhrase">caching models</phrase> in a 
        <literal>java.util.Map</literal> having
        each entry defined using standard Spring configuration:
        
        <programlisting>
&lt;-- property of some caching advice --&gt;
&lt;property name=&quot;cachingModels&quot;&gt;
  &lt;map&gt;
    &lt;entry key=&quot;get*&quot;&gt;
      &lt;bean class=&quot;org.springmodules.cache.provider.jcs.JcsCachingModel&quot;&gt;
        &lt;property name=&quot;cacheName&quot; value=&quot;someCache&quot; /&gt;
        &lt;property name=&quot;group&quot; value=&quot;someGroup&quot; /&gt;
      &lt;/bean&gt;
    &lt;/entry&gt;
  &lt;/map&gt;
&lt;/property&gt;</programlisting>

        <emphasis>          
          The type of caching model must match the chosen cache implementation:
          the example above must use 
          <ulink url="http://jakarta.apache.org/jcs/">Java Caching System (JCS)</ulink>
          as the cache provider.                        
        </emphasis>
      </para>
      
      <para>
        <emphasis>Caching advices</emphasis> can also have caching models
        as <literal>java.util.Properties</literal> resulting in a less verbose
        configuration:
        
        <programlisting>
&lt;-- property of some caching advice --&gt;
&lt;property name=&quot;cachingModels&quot;&gt;
  &lt;props&gt;
    &lt;prop key=&quot;get*&quot;&gt;cacheName=someCache;group=someGroup&lt;/prop&gt;
  &lt;/props&gt;
&lt;/property&gt;</programlisting>
      </para>

      <para>
        The caching model has been defined as a String in the format
        <emphasis>propertyName1=propertyValue1;propertyName2=propertyValue2</emphasis>
        which the <emphasis>Caching Module</emphasis> will automatically 
        convert into a caching model using a <literal>PropertyEditor</literal>
        provided by the <literal>CacheProviderFacade</literal>. 
      </para>
    
      <para>          
        The key of each entry is different for each declarative caching 
        service strategy. More details will be provided in further sections.
      </para>
    </sect2>

    <sect2 id="cachingListeners">
      <title>Caching Listeners</title>
      <para>
          An implementation of the interface
          <literal>org.springmodules.cache.interceptor.caching.CachingListener</literal>.
          A listener is notified when an object is stored in
          the cache. The <emphasis>Caching Module</emphasis>
          does not provide any implementation of this interface.
      </para>
    </sect2>

    <sect2 id="keyGenerator">
      <title>Key Generator</title>
      <para>
          An implementation of 
          <literal>org.springmodules.cache.key.CacheKeyGenerator</literal>.
          Generates the keys under which objects are stored in
          the cache. Only one implementation is provided,
          <literal>org.springmodules.cache.key.HashCodeCacheKeyGenerator</literal>,
          which creates keys based on the hash code of the
          object to store and a unique identifier.
      </para>
    </sect2>

    <sect2 id="flushingAdvice">
      <title>Flushing Advice</title>        
      <para>
        A <phrase id="flushingAdvicePhrase">flushing advice</phrase> flushes 
        one or more groups of the cache, or the whole cache (depending
        on the cache provider) <emphasis>before</emphasis> or
        <emphasis>after</emphasis> an advised method is executed.
      </para>
    </sect2>
      
    <sect2 id="flushingModels">
      <title>Flushing Models</title>
      <para>
        Similar to <xref linkend="cachingModels" endterm="cachingModelPhrase" />.
        Flushing models encapsulate the rules to be followed by the
        <emphasis>flushing advice</emphasis> when accessing the cache
        for invalidation or flushing. The <emphasis>Caching Module</emphasis>
        provides flushing models for each of the supported cache providers:
        <itemizedlist>
          <listitem>
            <para>
              <literal>org.springmodules.cache.provider.ehcache.EhCacheFlushingModel</literal> 
              specifies which caches should be flushed.
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>org.springmodules.cache.provider.jboss.JbossCacheFlushingModel</literal> 
                specifies the FQN of the nodes to be removed from the 
                <literal>TreeCache</literal>.
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>org.springmodules.cache.provider.jcs.JcsFlushingModel</literal>
              specifies which groups in which caches should be flushed.
              If the a cache is specified without groups, the whole cache is flushed.
            </para>
          </listitem> 
          <listitem>
            <para>
              <literal>org.springmodules.cache.provider.oscache.OsCacheFlushingModel</literal>
              specifies which groups should be flushed. If none is specified,
              the whole cache is flushed.
            </para>
          </listitem>
        </itemizedlist>
      </para>

      <para>
        Like caching advices, <emphasis>flushing advices</emphasis> can be 
        configured to have <phrase id="flushingModelPhrase">flushing models</phrase> in a 
        <literal>java.util.Map</literal>:
        
        <programlisting>
&lt;-- property of some Flushing advice --&gt;
&lt;property name=&quot;flushingModels&quot;&gt;
  &lt;map&gt;
    &lt;entry key=&quot;update*&quot;&gt;
      &lt;bean class=&quot;org.springmodules.cache.provider.jcs.JcsFlushingModel&quot;&gt;
        &lt;property name=&quot;cacheStructs&quot;&gt;
          &lt;list&gt;
            &lt;bean class=&quot;org.springmodules.cache.provider.jcs.JcsFlushingModel.CacheStruct&quot;&gt;
              &lt;property name=&quot;cacheName&quot; value=&quot;someCache&quot; /&gt;
              &lt;property name=&quot;groups&quot; value=&quot;group1,group2&quot; /&gt;
            &lt;/bean&gt;
          &lt;/list&gt;
        &lt;/property&gt;
      &lt;/bean&gt;
    &lt;/entry&gt;
  &lt;/map&gt;
&lt;/property&gt;</programlisting>

        <emphasis>          
          The type of flushing model must match the chosen cache implementation:
          the example above must use 
          <ulink url="http://jakarta.apache.org/jcs/">Java Caching System (JCS)</ulink>
          as the cache provider.                        
        </emphasis>
      </para>
      
      <para>
        <emphasis>Flushing advices</emphasis> can also have flushing models
        as <literal>java.util.Properties</literal> resulting in a less verbose
        configuration:
        
        <programlisting>
&lt;-- property of some flushing advice --&gt;
&lt;property name=&quot;flushingModels&quot;&gt;
  &lt;props&gt;
    &lt;prop key=&quot;update*&quot;&gt;cacheName=someCache;group=group1,group2&lt;/prop&gt;
  &lt;/props&gt;
&lt;/property&gt;</programlisting>
      </para>

      <para>
        The flushing model has been defined as a String in the format
        <emphasis>propertyName1=propertyValue1;propertyName2=propertyValue2</emphasis>
        which the <emphasis>Caching Module</emphasis> will automatically 
        convert into a flushing model using a <literal>PropertyEditor</literal>
        provided by the <literal>CacheProviderFacade</literal>. 
      </para>
    
      <para>          
        The key of each entry is different for each declarative caching 
        service strategy. More details will be provided in further sections.
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>Strategies for Declarative Caching Services</title>
    
    <para>
      The following sections describe the different strategies for declarative 
      caching services provided by the <emphasis>Caching Module</emphasis>.
    </para>

      <!--  
        <listitem>
          <para>
            <emphasis role="bold">
              Single
              <literal>MethodInterceptor</literal>
              .
            </emphasis>
            A single
            <literal>MethodInterceptor</literal>
            is used to proxy one or more bean definitions.
          </para>
        </listitem>
      </itemizedlist>
      -->
      
    <sect2>
      <title>CacheProxyFactoryBean</title>

      <para>
        A <literal>CacheProxyFactoryBean</literal>
        applies caching services to a single bean definition, performing aspect weaving
        using a 
        <literal>NameMatchCachingInterceptor</literal>
        as <emphasis><xref endterm="cachingAdvicePhrase" linkend="cachingAdvice" /></emphasis>
        and a 
        <literal>NameMatchFlushingInterceptor</literal>
        as <emphasis><xref endterm="flushingAdvicePhrase" linkend="flushingAdvice"/></emphasis>.
      </para>

      <para>
        <programlisting>
&lt;!-- Using a EHCache cache manager --&gt;
&lt;bean id=&quot;cacheProviderFacade&quot; class=&quot;...&quot; /&gt;

&lt;bean id=&quot;cacheableServiceTarget&quot;
  class=&quot;org.springmodules.cache.integration.CacheableServiceImpl&quot;&gt;
  &lt;property name=&quot;names&quot;&gt;
    &lt;list&gt;
      &lt;value&gt;Luke Skywalker&lt;/value&gt;
      &lt;value&gt;Leia Organa&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;cacheableService&quot;
  class=&quot;org.springmodules.cache.interceptor.proxy.CacheProxyFactoryBean&quot;&gt;
  &lt;property name=&quot;cacheProviderFacade&quot; ref=&quot;cacheProviderFacade&quot; /&gt;
  &lt;property name=&quot;cachingModels&quot;&gt;
    &lt;props&gt;
      &lt;prop key=&quot;get*&quot;&gt;cacheName=testCache&lt;/prop&gt;
    &lt;/props&gt;
  &lt;/property&gt;
  &lt;property name=&quot;flushingModels&quot;&gt;
    &lt;props&gt;
      &lt;prop key=&quot;update*&quot;&gt;cacheNames=testCache&lt;/prop&gt;
    &lt;/props&gt;
  &lt;/property&gt;
  &lt;property name=&quot;cachingListeners&quot;&gt;
    &lt;list&gt;
      &lt;ref bean=&quot;cachingListener&quot; /&gt;
    &lt;/list&gt;
  &lt;/property&gt;
  &lt;property name=&quot;target&quot; ref=&quot;cacheableServiceTarget&quot; /&gt;
&lt;/bean&gt;</programlisting>
      </para>

      <para>
        In the above example, <emphasis>cacheableServiceTarget</emphasis> is the 
        <emphasis>advised</emphasis> or <emphasis>proxied</emphasis> object, i.e.
        the bean to apply caching services to.
      </para>

      <para>
        The caching interceptor will use a <literal>NameMatchCachingModelSource</literal> 
        to get the caching models defining the caching rules to be applied to 
        specific methods of the proxied class. In our example, it will apply
        caching to the methods starting with the text &quot;get.&quot;
      </para>

      <para>
        In a similar way, the flushing interceptor will use a 
        <literal>NameMatchFlushingModelSource</literal> 
        to get the flushing models defining the flushing rules to be applied to 
        specific methods of the proxied class. In our example, it will flush
        the cache &quot;testCache&quot; after executing the methods starting 
        with the text &quot;update.&quot;
      </para>
    </sect2>

    <sect2>
      <title>Source-level Metadata-driven Autoproxy</title>

      <para>
        Autoproxying is driven by metadata. This produces a similar
        programming model to Microsoft's .Net
        <literal>ServicedComponents</literal>. 
        AOP proxies for caching services are created automatically for
        the beans containing source-level, caching metadata attributes. The
        <emphasis>Caching Module</emphasis>
        supports metadata provided by
        <ulink
          url="http://jakarta.apache.org/commons/attributes/">
          Commons-Attributes</ulink>
        and 
        <ulink 
          url="http://java.sun.com/j2se/1.5.0/docs/guide/language/annotations.html">
        JDK 1.5+ Annotations</ulink>. Both approaches are very flexible, because
        metadata attributes are restricted to describe <emphasis>whether</emphasis>
        caching services should be applied instead of describing <emphasis>how</emphasis>
        caching should occur. The <emphasis>how</emphasis> is described in the
        Spring configuration file.
     </para>   

     <para>   
        Setting up
        <emphasis><ulink
          url="http://www.springframework.org/docs/reference/aop.html#aop-autoproxy">
          autoproxy</ulink></emphasis>
        is quite simple:

        <programlisting>
&lt;bean id=&quot;autoproxy&quot;
  class=&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot; /&gt;</programlisting>
      </para>

      <sect3>
        <title>Jakarta Commons-Attributes</title>
        
        <para>
          The attributes 
          <literal>org.springmodules.cache.interceptor.caching.Cached</literal>
          and
          <literal>org.springmodules.cache.interceptor.flush.FlushCache</literal>
          are used to indicate that an interface, interface method, class, or 
          class method should be target for caching services.
          
          <programlisting>
public class CacheableServiceImpl implements CacheableService {

  /**
   * @@org.springmodules.cache.interceptor.caching.Cached(modelId="testCaching")
   */
  public final String getName(int index) {
    // some implementation
  }

  /**
   * @@org.springmodules.cache.interceptor.flush.FlushCache(modelId="testFlushing")
   */
  public final void updateName(int index, String name) {
    // some implementation
  }
}</programlisting>
        </para>
        
        <para>
          Now we need to tell Spring to apply caching services to the beans 
          having Commons-Attributes metadata:
          
          <programlisting>
&lt;bean id=&quot;attributes&quot;
  class=&quot;org.springframework.metadata.commons.CommonsAttributes&quot; /&gt;

&lt;bean id="cachingInterceptor"
  class="org.springmodules.cache.interceptor.caching.MetadataCachingInterceptor"&gt;
  &lt;property name="attributes" ref="attributes" /&gt;
  &lt;property name="cacheProviderFacade" ref="cacheProviderFacade" /&gt;
  &lt;property name="cachingListeners"&gt;
    &lt;list&gt;
      &lt;ref bean="cachingListener" /&gt;
    &lt;/list&gt;
  &lt;/property&gt;
  &lt;property name="cachingModels"&gt;
    &lt;props&gt;
      &lt;prop key="testCaching"&gt;cacheName=testCache&lt;/prop&gt;
    &lt;/props&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="cachingAttributeSourceAdvisor"
  class="org.springmodules.cache.interceptor.caching.CachingAttributeSourceAdvisor"&gt;
  &lt;constructor-arg ref="cachingInterceptor" /&gt;
&lt;/bean&gt;

&lt;bean id="flushingInterceptor"
  class="org.springmodules.cache.interceptor.flush.MetadataFlushingInterceptor"&gt;
  &lt;property name="attributes" ref="attributes" /&gt;
  &lt;property name="cacheProviderFacade" ref="cacheProviderFacade" /&gt;
  &lt;property name="flushingModels"&gt;
    &lt;props&gt;
      &lt;prop key="testFlushing"&gt;cacheNames=testCache&lt;/prop&gt;
    &lt;/props&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="flushingAttributeSourceAdvisor"
  class="org.springmodules.cache.interceptor.flush.FlushingAttributeSourceAdvisor"&gt;
  &lt;constructor-arg ref="flushingInterceptor" /&gt;
&lt;/bean&gt;

&lt;!-- Set up the objects to apply caching to --&gt;
&lt;bean id="cacheableService"
  class="org.springmodules.cache.integration.CacheableServiceImpl"&gt;
  &lt;property name="names"&gt;
    &lt;list&gt;
      &lt;value&gt;Luke Skywalker&lt;/value&gt;
      &lt;value&gt;Leia Organa&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>  
        </para>
      
        <para>
          The property <literal>modelId</literal> of the metadata attribute 
          <literal>Cached</literal> should match the id of a caching model
          configured in the caching advice (in our example the bean with id
          <emphasis>cachingInterceptor</emphasis>.) This way the caching advice
          will know which caching model should use and how caching should be
          applied. In the above example, the caching advice will
          store in the EHCache <emphasis>testCache</emphasis> the return value
          of the method <literal>getName</literal>.
        </para>
        
        <para>
          The same matching mechanism is applied to flushing models. The 
          property <literal>modelId</literal> of the metadata attribute
          <literal>FlushCache</literal> shoule match the id of a flushing model
          configured in the flushing advice (the bean with id <emphasis>flushingInterceptor</emphasis>.)
          The flushing advice will know which flushing model to use. In the
          above example, the EHCache <emphasis>testCache</emphasis> will be
          flushed after executing the method <literal>updateName</literal>.
        </para>
        
        <para>
          <emphasis>Usage of Commons-Attributes requires an 
          extra compilation step which generates the code necessary to
          access metadata attributes. Please refer to its <ulink
          url="http://jakarta.apache.org/commons/attributes/">
          documentation</ulink> for more details.</emphasis>
        </para>
      </sect3>

      <sect3>
        <title>JDK 1.5+ Annotations</title>
        
        <para>Source-level metadata attributes can be declared using
        JDK 1.5+ Annotations:
          <programlisting>
public class TigerCacheableService implements CacheableService {

  @Cacheable(modelId = "testCaching")
  public final String getName(int index) {
    // some implementation.
  }

  @CacheFlush(modelId = "testFlushing")
  public final void updateName(int index, String name) {
    // some implementation.
  }
}</programlisting>
        </para>

        <para>
          The annotations <literal>org.springmodules.cache.annotations.Cacheable</literal>
          and <literal>org.springmodules.cache.annotations.CacheFlush</literal> work
          exactly the same as their Commons-Attributes counterparts. Configuration
          in the Spring context is also very similar:
          
          <programlisting>
&lt;bean id=&quot;cachingAttributeSource&quot;
  class=&quot;org.springmodules.cache.annotations.AnnotationCachingAttributeSource&quot;&gt;
&lt;/bean&gt;

&lt;bean id=&quot;cachingInterceptor&quot;
  class=&quot;org.springmodules.cache.interceptor.caching.MetadataCachingInterceptor&quot;&gt;
  &lt;property name=&quot;cacheProviderFacade&quot; ref=&quot;cacheProviderFacade&quot; /&gt;
  &lt;property name=&quot;cachingAttributeSource&quot; ref=&quot;cachingAttributeSource&quot; /&gt;
  &lt;property name=&quot;cachingListeners&quot;&gt;
    &lt;list&gt;
      &lt;ref bean=&quot;cachingListener&quot; /&gt;
    &lt;/list&gt;
  &lt;/property&gt;
  &lt;property name=&quot;cachingModels&quot;&gt;
    &lt;props&gt;
      &lt;prop key=&quot;testCaching&quot;&gt;cacheName=testCache&lt;/prop&gt;
    &lt;/props&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;cachingAttributeSourceAdvisor&quot;
  class=&quot;org.springmodules.cache.interceptor.caching.CachingAttributeSourceAdvisor&quot;&gt;
  &lt;constructor-arg ref=&quot;cachingInterceptor&quot; /&gt;
&lt;/bean&gt;

&lt;bean id=&quot;flushingAttributeSource&quot;
  class=&quot;org.springmodules.cache.annotations.AnnotationFlushingAttributeSource&quot;&gt;
&lt;/bean&gt;

&lt;bean id=&quot;flushingInterceptor&quot;
  class=&quot;org.springmodules.cache.interceptor.flush.MetadataFlushingInterceptor&quot;&gt;
  &lt;property name=&quot;cacheProviderFacade&quot; ref=&quot;cacheProviderFacade&quot; /&gt;
  &lt;property name=&quot;flushingAttributeSource&quot; ref=&quot;flushingAttributeSource&quot; /&gt;
  &lt;property name=&quot;flushingModels&quot;&gt;
    &lt;props&gt;
      &lt;prop key=&quot;testFlushing&quot;&gt;cacheNames=testCache&lt;/prop&gt;
    &lt;/props&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;flushingAttributeSourceAdvisor&quot;
  class=&quot;org.springmodules.cache.interceptor.flush.FlushingAttributeSourceAdvisor&quot;&gt;
  &lt;constructor-arg ref=&quot;flushingInterceptor&quot; /&gt;
&lt;/bean&gt; 

&lt;!-- Set up the objects to apply caching to --&gt;
&lt;bean id=&quot;cacheableService&quot;
  class=&quot;org.springmodules.cache.annotations.TigerCacheableService&quot;&gt;
  &lt;property name=&quot;names&quot;&gt;
    &lt;list&gt;
      &lt;value&gt;Luke Skywalker&lt;/value&gt;
      &lt;value&gt;Leia Organa&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;
          </programlisting>
        </para>        
        
        <para>
          <emphasis>
            By using JDK 1.5+ Annotations, we don't need the extra compilation
            step (required by Commons-Attributes.) The only downside is we can
            not use Annotations with JDK 1.4.
          </emphasis>
        </para>
      </sect3>
    </sect2>

    <sect2>
      <title>BeanNameAutoProxyCreator</title>
      
      <para>
        <programlisting>
&lt;bean id=&quot;cachingInterceptor&quot;
  class=&quot;org.springmodules.cache.interceptor.caching.MethodMapCachingInterceptor&quot;&gt;
  &lt;property name=&quot;cacheProviderFacade&quot; ref=&quot;cacheProviderFacade&quot; /&gt;
  &lt;property name=&quot;cachingListeners&quot;&gt;
    &lt;list&gt;
      &lt;ref bean=&quot;cachingListener&quot; /&gt;
    &lt;/list&gt;
  &lt;/property&gt;
  &lt;property name=&quot;cachingModels&quot;&gt;
    &lt;props&gt;
      &lt;prop key=&quot;org.springmodules.cache.integration.CacheableService.get*&quot;&gt;cacheName=testCache&lt;/prop&gt;
    &lt;/props&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;flushingInterceptor&quot;
  class=&quot;org.springmodules.cache.interceptor.flush.MethodMapFlushingInterceptor&quot;&gt;
  &lt;property name=&quot;cacheProviderFacade&quot; ref=&quot;cacheProviderFacade&quot; /&gt;
  &lt;property name=&quot;flushingModels&quot;&gt;
    &lt;props&gt;
      &lt;prop key=&quot;org.springmodules.cache.integration.CacheableService.update*&quot;&gt;cacheNames=testCache&lt;/prop&gt;
    &lt;/props&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean
  class=&quot;org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator&quot;&gt;
  &lt;property name=&quot;beanNames&quot;&gt;
    &lt;list&gt;
      &lt;idref local=&quot;cacheableService&quot;/&gt;
    &lt;/list&gt;
  &lt;/property&gt;
  &lt;property name=&quot;interceptorNames&quot;&gt;
    &lt;list&gt;
      &lt;value&gt;cachingInterceptor&lt;/value&gt;
      &lt;value&gt;flushingInterceptor&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;cacheableService&quot;
  class=&quot;org.springmodules.cache.integration.CacheableServiceImpl&quot;&gt;
  &lt;property name=&quot;names&quot;&gt;
    &lt;list&gt;
      &lt;value&gt;Luke Skywalker&lt;/value&gt;
      &lt;value&gt;Leia Organa&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>
      </para>
      
      <para>
        Assuming that we already have a <literal>CacheProviderFacade</literal> 
        instance in our ApplicationContext, the first thing we need to do is 
        create the <emphasis>caching advice</emphasis>
        <literal>MethodMapCachingInterceptor</literal> and the 
        <emphasis>flushing advice</emphasis> 
        <literal>MethodMapFlushingInterceptor</literal>> to use.
        The advices decide which methods to intercept matching them using
        the fully qualified name of the class with the name of the name (which accepts 
        wildcards.)
      </para>
      <para>
        Once we have the advices, we feed them to a 
        <literal>BeanNameAutoProxyCreator</literal> along with the
        names of the beans in the ApplicationContext we want to apply
        caching services to.
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>Programmatic Use</title>
  
    <para>
      First, we need to configure a       
      <literal>org.springmodules.cache.provider.CacheProviderFacade</literal>
      in the Spring ApplicationContext (please refer to <xref linkend="cache-setup-provider"/> for more details.)
      Then we need to obtain a reference to it and call any of this methods from
      our Java code:
  
      <programlisting>
void cancelCacheUpdate(Serializable key) throws CacheException;

void flushCache(FlushingModel model) throws CacheException;

Object getFromCache(Serializable key, CachingModel model) throws CacheException;

boolean isFailQuietlyEnabled();

void putInCache(Serializable key, CachingModel model, Object obj) throws CacheException;

void removeFromCache(Serializable key, CachingModel model) throws CacheException;</programlisting>
    </para>
  </sect1>
</chapter>