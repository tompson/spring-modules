<chapter id="template">

	<title>Templates</title>

    <sect1 id="template-framework">

        <title>Templates &amp; Template Engines</title>

        <para>
            The Templates module provides an abstration over common template engines. This abstraction mainly targets
            framework and product developer who don't wish to tie their implementation to a specific template engine.
        </para>

        <sect2>

            <title>Core Constructs &amp; Interfaces</title>

            <para>
                This abstration is based on the following three core interfaces:
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        Template - This interface represents the notion of a template that is capable of generating
                        an output based on a given model.

                        <programlisting>public interface Template {

    void generate(OutputStream out, Map model) throws TemplateGenerationException;

    void generate(Writer writer, Map model) throws TemplateGenerationException;

    String generate(Map model) throws TemplateGenerationException;

}</programlisting>
                        All Template's method essentially do the same thing - generate an output (whether by writing
                        it to an output stream, writer, or just generate a string) based on a given model which is
                        abstracted as a Map. Although declared, the <emphasis>TemplateGenerationException</emphasis> is a runtime exception
                        (Actually, all exceptions thrown by all constructs are runtime exceptions). This exception is
                        thrown when for some reason the template could not generate the desired output.

                    </para>
                </listitem>
                <listitem>
                    <para>
                        TemplateEngine - This interface represents the a template engine that is capable of creating
                        the appropriate template based on a template resource. As there are many different template
                        engines out there and each one defines its own template language, a template generated by one
                        engine is naturally different than the one generated by another engine.

                        <programlisting>public interface TemplateEngine {

    Template createTemplate(Resource resource) throws TemplateCreationException;

    Template createTemplate(Resource resource, String encoding) throws TemplateCreationException;

}</programlisting>
                        As seen above, the template engine methods accept a spring resource as an input (the template
                        definitioning) and create the appropriate template from it. A runtime
                        <emphasis>TemplateCreationException</emphasis> is thrown when for some reason the engine could
                        not create a template from the given resource (perhaps bad template syntax).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        TemplateResolver - This is essentailly a strategy of resolving template based on a template name.
                        For those who are familar with Spring MVC, this resembels the ViewResolver.

                        <programlisting>public interface TemplateResolver {

    Template resolve(String name, String encoding);

    Template resolve(String name);

}</programlisting>
                        As we'll see later on, this interface enables defining different strategies by which templates
                        can be loaded/resolved which makes the development of a template base class simple and clean.
                    </para>
                </listitem>
            </itemizedlist>

        </sect2>

        <sect2>

            <title>Supported Template Engines</title>

            <sect3>

                <title>Apache Velocity</title>

                <para>
                    The <emphasis>org.springmodules.template.engine.velocity.VelocityTemplate</emphasis> class is the
                    Apache Velocity implementation of the <emphasis>TemplateEngine</emphasis> interface. Under the hood
                    it uses the VelocityEngine that can be configured by setting the appropriate velocity settings using
                    the <emphasis>setConfiguration(Properties)</emphasis> method. Here is an example how thie engine
                    can be configured in Spring application context:
                </para>

                <programlisting>&lt;bean id="engine" class="org.springmodules.template.engine.velocity.VelocityTemplateEngine"&gt;
    &lt;property name="defaultEncoding" value="UTF-8"/&gt;
    &lt;property name="configuration"&gt;
        &lt;props&gt;
            &lt;!-- velocity specific properties --&gt;
            &lt;prop key="velocimacro.context.localscope"&gt;false&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>

                <para>
                    A common feature among template engines is support for inter-resource referencing. This feature
                    enables the template author to modularize the structure of the templates and practice code reuse.
                    Velocity support this feature using the <emphasis>#include</emphasis> and <emphasis>#parse</emphasis>
                    directives. The <emphasis>VelocityTemplateEngine</emphasis> integrates tightly with velocity resource
                    management and leverages spring's resource &amp; resource loader support to resolve the referenced
                    resources. This enables the template author to define the references in the spring common resource
                    paths. For example:
                </para>

                <programlisting>&lt;html&gt;
    &lt;body&gt;
        &lt;div&gt;#parse("classpath:header.vm")&lt;/div&gt;
        &lt;div&gt;
            The content body
        &lt;/div&gt;
        &lt;div&gt;#parse("classpath:footer.vm")&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;</programlisting>

                <para>
                    The <emphasis>VelocityTemplateEngine</emphasis> implements springs <emphasis>ResourceLoaderAware</emphasis>
                    interface so the application context serves as the resource loader by default.
                </para>

            </sect3>

            <sect3>

                <title>Freemarker</title>

                <para>
                    Freemarker is a mature and feature rich template engine that is well designed and performs well. The
                    <emphasis>org.springmodules.template.engine.freemarker.FreemarkerTemplateEngine</emphasis> class is
                    capable of reading freemarker template sources and generate the appropriate freemarker templates. The
                    following is an example of application context configuration:
                </para>

                <programlisting>&lt;bean id="freemarker" class="org.springmodules.template.engine.freemarker.FreemarkerTemplateEngine"&gt;
    &lt;property name="defaultEncoding" value="UTF-8"/&gt;
    &lt;property name="settings"&gt;
        &lt;props&gt;
            &lt;prop key="locale"&gt;en_US&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
    &lt;property name="sharedVariables"&gt;
        &lt;map&gt;
            &lt;entry key="name" value="${name}"/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>

                <para>
                    As shown above, it is also possible to define variables that will be shared among all templates. In
                    this case the shared variable is configured using a property placeholder.
                </para>

                <para>
                    Like with velocity, <emphasis>FreemarkerTemplateEngine</emphasis> also laverages spring's
                    resource support to support inter-resource referencing. This enables writing a template like:
                </para>

                <programlisting>&lt;html&gt;
    &lt;body&gt;
        &lt;div&gt;&lt;#include "classpath:header.html" parse=false&gt;&lt;/div&gt;
        &lt;div&gt;
            The content body
        &lt;/div&gt;
        &lt;div&gt;&lt;#include "classpath:footer.ftl"&gt;&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;</programlisting>

            </sect3>

            <sect3>

                <title>Groovy Template</title>

                <para>
                    Groovy Template is a library that ships with groovy which enables writing templates in the groovy
                    language (GString's for those familar with groovy). While current imlementation performance
                    is somewhat lagging behind Velocity and Freemarker, groovy as a templating language brings quite
                    a lot of power to the hands of temlate authors. The
                    <emphasis>org.springmodules.template.engine.groovy.GroovyTemplateEngine</emphasis> is the template
                    engine that create Groovy templates. Here is how this engine would be configured in an application
                    context:
                </para>

                <programlisting>&lt;bean id="groovy" class="org.springmodules.template.engine.groovy.GroovyTemplateEngine"&gt;
    &lt;property name="defaultEncoding" value="UTF-8"/&gt;
&lt;/bean&gt;</programlisting>

                <para>
                    As seen above, there isn't much to configure when defining a groovy template engine. This engine is
                    much more simplistic and less featured than both Velocity and Freemarker (for example, it has no support
                    inter-template referencing).
                </para>

            </sect3>

        </sect2>

        <sect2>

            <title>Template Resolvers</title>

            <para>
                We've seen how we can create/define the template engines that enables the creation of template of
                different types. However, in order to utilize them to create those actual templates, one needs to first
                load the appropriate template resource and hand it over to the engine. Although it is perfectly valid
                approach, template resolvers come to simplify this process even more.
            </para>

            <para>
                The following are the different types of template resolvers that are provided out-of-the-box:
            </para>

            <sect3>

                <title>BasicTemplateResolver</title>

                <para>
                    As the name suggests, this is a very basic implementation of the <emphasis>TemplateResolver</emphasis>
                    interface. It is configured with a template engine and a resource loader. The resource loader is used
                    to load the template resources based on the template name, while the template engine is used to create
                    the templates from the loaded template resources. In this case, the resolver's <emphasis>resolve(String)</emphasis>
                    calls the resource loader's <emphasis>getResource(String)</emphasis> with the provided template name.
                    Here is how this resolver can be defined within an application context:
                </para>

                <programlisting>&lt;bean id="resolver" class="org.springmodules.template.resolver.BasicTemplateResolver"&gt;
    &lt;property name="engine" ref="freemarker"/&gt;
&lt;/bean&gt;</programlisting>

                <para>
                    The <emphasis>BasicTemplateResolver</emphasis> also implements the <emphasis>ResourceLoaderAware</emphasis>
                    interface, so when defined in the application context, by default the application context is used
                    as the resource loader implementation.
                </para>

                <para>
                    Most of the time you wouldn't choose to use this implementation in your application. As we'll see soon,
                    this class mainly serves as a base class for the other template resolver implementations.
                </para>

            </sect3>

            <sect3>

                <title>CachingTemplateResolver</title>

                <para>
                    This is a simple extention on top of the <emphasis>BasicTemplateResolver</emphasis> which caches
                    the resolved templates by their names. Calling <emphasis>resolve(String)</emphasis> on this resolver
                    for the first time, will go through the same process as with the <emphasis>BasicTemplateResolver</emphasis>
                    but with one differece, just before the resolved template is returned, it is cached internally by
                    its name. As a consequence, the next call for the same tempate (using the same template name) will
                    just return the cached template.
                </para>

                <para>
                    Although for most cases using a cached template resolver is the preferred choice, there are some things
                    to consider. First, the cache effectiveness high depends on the concrete implementation of the template
                    that is used. For example, it could be that a template is implemented in such a way that every call to
                    <emphasis>generate(Writer, Map)</emphasis> the template resource is being re-read. Another thing to
                    consider is that some engines has a built-in support for automatic reload (that is, when the template
                    source changes, the template is reloaded). For some implementations, caching the template will
                    prevent from the reload to actually work. Hopefully, in a future release we'll have our own support
                    for such reload funtionality.
                </para>

            </sect3>

            <sect3>

                <title>SimpleTempalteResolver</title>

                <para>
                    Again, as its name suggests, this is a simple template resolver that extends the caching resolver.
                    It is very likely that you will use this resolver implementation most of the time. In addition to
                    all functionality this resolver inherits from the caching and basic resolver, it adds two addition
                    features. With this resolver it is possible to define a prefix and a suffix that when combined with
                    the template name, are used to create the template resource path. Here's how this resolver can be
                    configured within an application context:
                </para>

                <programlisting>&lt;bean id="simpleResolver" class="org.springmodules.template.resolver.SimpleTemplateResolver"&gt;
    &lt;property name="engine" ref="freemarker"/&gt;
    &lt;property name="prefix" value="classpath:/templates/"/&gt;
    &lt;property name="suffix" value=".ftl"/&gt;
&lt;/bean&gt;</programlisting>

                <para>
                    In the example above, when trying to resolve a template named "email", the resolver will try to load
                    the template resource from the "classpath:/templates/email.ftl" location. This is quite powerful
                    mechanism as it lets you define all template resources in a well defined and proprietary location,
                    while still the user only needs to deal with the logical name of the template (i.e. "email").
                </para>

            </sect3>

            <sect3>

                <title>LocalizedTempalteResolver</title>

                <para>
                    While the <emphasis>SimpleTemplateResolver</emphasis> can serve you well most of the time, sometimes
                    you want to support multiple locales and provide the same template in multiple languages. The
                    <emphasis>LocalizedTempalteResolver</emphasis> enables you to do just that. Again, it inherits
                    all the functionality from the caching and basic resolvers, while this time, it tries to load
                    localized versions of the templates based on the resource bundles file naming convensions. For example,
                    when resolving a template named "email" with an extension ".ftl" and assuming the current locale
                    context is <emphasis>en_US</emphasis>, it will first try to load the "email_en_US.ftl" resource, when
                    that fails, it will try loading "email_en.ftl", and if that fails it will fallback and try to load
                    "email.ftl". Here's how this resolver can be configured within an application context:
                </para>

                <programlisting>&lt;bean id="localizedResolver" class="org.springmodules.template.resolver.LocalizedTemplateResolver"&gt;
    &lt;property name="engine" ref="freemarker"/&gt;
    &lt;property name="prefix" value="classpath:/termplates/"/&gt;
    &lt;property name="extension" value=".ftl"/&gt;
&lt;/bean&gt;</programlisting>

                <para>
                    As can be seen above, this is fairly similar to the configuration of the <emphasis>SimpleTempalteResolver</emphasis>.
                    All of the localization extra work is done inside the resolver itself.
                </para>

            </sect3>

        </sect2>

    </sect1>

    <sect1 id="email-framework">

        <title>Email Framwork</title>

        <para>

        </para>

    </sect1>

</chapter>