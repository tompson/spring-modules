<chapter id="template">

	<title>Templates</title>

    <sect1 id="template-framework">

        <title>Templates &amp; Template Engines</title>

        <para>
            The Templates module provides an abstration over common template engines. This abstraction mainly targets
            framework and product developer who don't wish to tie their implementation to a specific template engine.
        </para>

        <sect2>

            <title>Core Constructs &amp; Interfaces</title>

            <para>
                This abstration is based on the following three core interfaces:
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        Template - This interface represents the notion of a template that is capable of generating
                        an output based on a given model.

                        <programlisting>public interface Template {

    void generate(OutputStream out, Map model) throws TemplateGenerationException;

    void generate(Writer writer, Map model) throws TemplateGenerationException;

    String generate(Map model) throws TemplateGenerationException;

}</programlisting>
                        All Template's method essentially do the same thing - generate an output (whether by writing
                        it to an output stream, writer, or just generate a string) based on a given model which is
                        abstracted as a Map. Although declared, the <emphasis>TemplateGenerationException</emphasis> is a runtime exception
                        (Actually, all exceptions thrown by all constructs are runtime exceptions). This exception is
                        thrown when for some reason the template could not generate the desired output.

                    </para>
                </listitem>
                <listitem>
                    <para>
                        TemplateEngine - This interface represents the a template engine that is capable of creating
                        the appropriate template based on a template resource. As there are many different template
                        engines out there and each one defines its own template language, a template generated by one
                        engine is naturally different than the one generated by another engine.

                        <programlisting>public interface TemplateEngine {

    Template createTemplate(Resource resource) throws TemplateCreationException;

    Template createTemplate(Resource resource, String encoding) throws TemplateCreationException;

}</programlisting>
                        As seen above, the template engine methods accept a spring resource as an input (the template
                        definitioning) and create the appropriate template from it. A runtime
                        <emphasis>TemplateCreationException</emphasis> is thrown when for some reason the engine could
                        not create a template from the given resource (perhaps bad template syntax).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        TemplateResolver - This is essentailly a strategy of resolving template based on a template name.
                        For those who are familar with Spring MVC, this resembels the ViewResolver.

                        <programlisting>public interface TemplateResolver {

    Template resolve(String name, String encoding);

    Template resolve(String name);

}</programlisting>
                        As we'll see later on, this interface enables defining different strategies by which templates
                        can be loaded/resolved which makes the development of a template base class simple and clean.
                    </para>
                </listitem>
            </itemizedlist>

        </sect2>

        <sect2>

            <title>Supported Template Engines</title>

            <sect3>

                <title>Apache Velocity</title>

                <para>
                    The <emphasis>org.springmodules.template.engine.velocity.VelocityTemplate</emphasis> class is the
                    Apache Velocity implementation of the <emphasis>TemplateEngine</emphasis> interface. Under the hood
                    it uses the VelocityEngine that can be configured by setting the appropriate velocity settings using
                    the <emphasis>setConfiguration(Properties)</emphasis> method. Here is an example how thie engine
                    can be configured in Spring application context:
                </para>

                <programlisting>&lt;bean id="engine" class="org.springmodules.template.engine.velocity.VelocityTemplateEngine"&gt;
    &lt;property name="defaultEncoding" value="UTF-8"/&gt;
    &lt;property name="configuration"&gt;
        &lt;props&gt;
            &lt;!-- velocity specific properties --&gt;
            &lt;prop key="velocimacro.context.localscope"&gt;false&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>

                <para>
                    A common feature among template engines is support for inter-resource referencing. This feature
                    enables the template author to modularize the structure of the templates and practice code reuse.
                    Velocity support this feature using the <emphasis>#include</emphasis> and <emphasis>#parse</emphasis>
                    directives. The <emphasis>VelocityTemplateEngine</emphasis> integrates tightly with velocity resource
                    management and leverages spring's resource &amp; resource loader support to resolve the referenced
                    resources. This enables the template author to define the references in the spring common resource
                    paths. For example:
                </para>

                <programlisting>&lt;html&gt;
    &lt;body&gt;
        &lt;div&gt;#parse("classpath:header.vm")&lt;/div&gt;
        &lt;div&gt;
            The content body
        &lt;/div&gt;
        &lt;div&gt;#parse("classpath:footer.vm")&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;</programlisting>

                <para>
                    The <emphasis>VelocityTemplateEngine</emphasis> implements springs <emphasis>ResourceLoaderAware</emphasis>
                    interface so the application context serves as the resource loader by default.
                </para>

            </sect3>

            <sect3>

                <title>Freemarker</title>

                <para>
                    Freemarker is a mature and feature rich template engine that is well designed and performs well. The
                    <emphasis>org.springmodules.template.engine.freemarker.FreemarkerTemplateEngine</emphasis> class is
                    capable of reading freemarker template sources and generate the appropriate freemarker templates. The
                    following is an example of application context configuration:
                </para>

                <programlisting>&lt;bean id="freemarker" class="org.springmodules.template.engine.freemarker.FreemarkerTemplateEngine"&gt;
    &lt;property name="defaultEncoding" value="UTF-8"/&gt;
    &lt;property name="settings"&gt;
        &lt;props&gt;
            &lt;prop key="locale"&gt;en_US&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
    &lt;property name="sharedVariables"&gt;
        &lt;map&gt;
            &lt;entry key="name" value="${name}"/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>

                <para>
                    As shown above, it is also possible to define variables that will be shared among all templates. In
                    this case the shared variable is configured using a property placeholder.
                </para>

                <para>
                    Like with velocity, <emphasis>FreemarkerTemplateEngine</emphasis> also laverages spring's
                    resource support to support inter-resource referencing. This enables writing a template like:
                </para>

                <programlisting>&lt;html&gt;
    &lt;body&gt;
        &lt;div&gt;&lt;#include "classpath:header.html" parse=false&gt;&lt;/div&gt;
        &lt;div&gt;
            The content body
        &lt;/div&gt;
        &lt;div&gt;&lt;#include "classpath:footer.ftl"&gt;&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;</programlisting>

            </sect3>

            <sect3>

                <title>Groovy Template</title>

                

            </sect3>

        </sect2>

        <sect2>

            <title>Template Resolvers</title>

            <sect3>

                <title>BasicTemplateResolver</title>

            </sect3>

            <sect3>

                <title>CachingTemplateResolver</title>

            </sect3>

            <sect3>

                <title>SimpleTempalteResolver</title>

            </sect3>

            <sect3>

                <title>LocalizedTempalteResolver</title>

            </sect3>

        </sect2>

    </sect1>

    <sect1 id="email-framework">

        <title>Email Framwork</title>

        <para>
            The Commons Validator is a library that allows you to perform
            validation based on rules specified in XML configuration files.
        </para>

    </sect1>

</chapter>