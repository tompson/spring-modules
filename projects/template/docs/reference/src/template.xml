<chapter id="template">

	<title>Templates</title>

    <sect1 id="template-framework">

        <title>Templates &amp; Template Engines</title>

        <para>
            The Templates module provides an abstraction over common template engines. This abstraction mainly targets
            frameworks and products developers who don't wish to tie their implementation to a specific template engine.
        </para>

        <sect2>

            <title>Core Constructs &amp; Interfaces</title>

            <para>
                This abstraction is based on the following three core interfaces:
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        Template - This interface represents the notion of a template that is capable of generating
                        an output based on a given model.

                        <programlisting>public interface Template {

    void generate(OutputStream out, Map model) throws TemplateGenerationException;

    void generate(Writer writer, Map model) throws TemplateGenerationException;

    String generate(Map model) throws TemplateGenerationException;

}</programlisting>
                        All Template's method essentially do the same thing - generate an output (whether by writing
                        it to an output stream, writer, or just generate a string) based on a given model which is
                        abstracted as a Map. Although declared, the <emphasis>TemplateGenerationException</emphasis> is a runtime exception
                        (Actually, all exceptions thrown by all constructs are runtime exceptions). This exception is
                        thrown when for some reason the template could not generate the desired output.

                    </para>
                </listitem>
                <listitem>
                    <para>
                        TemplateEngine - This interface represents the a template engine that is capable of creating
                        the appropriate template based on a template resource. As there are many different template
                        engines out there and each one defines its own template language, a template generated by one
                        engine is naturally different than the one generated by another engine.

                        <programlisting>public interface TemplateEngine {

    Template createTemplate(Resource resource) throws TemplateCreationException;

    Template createTemplate(Resource resource, String encoding) throws TemplateCreationException;

}</programlisting>
                        As seen above, the template engine methods accept a Spring resource as an input (the template
                        definition) and create the appropriate template from it. A runtime
                        <emphasis>TemplateCreationException</emphasis> is thrown when for some reason the engine could
                        not create a template from the given resource (perhaps bad template syntax).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        TemplateResolver - This is essentially a strategy for resolving templates based on a template names.
                        For those who are familiar with Spring MVC, this resembles the ViewResolver.

                        <programlisting>public interface TemplateResolver {

    Template resolve(String name, String encoding);

    Template resolve(String name);

}</programlisting>
                        As we'll see later on, this interface enables defining different strategies by which templates
                        can be loaded/resolved which makes the development of a template base class simple and clean.
                    </para>
                </listitem>
            </itemizedlist>

        </sect2>

        <sect2>

            <title>Supported Template Engines</title>

            <sect3>

                <title>Apache Velocity</title>

                <para>
                    The <emphasis>org.springmodules.template.engine.velocity.VelocityTemplate</emphasis> class is the
                    Apache Velocity implementation of the <emphasis>TemplateEngine</emphasis> interface. Under the hood
                    it uses the VelocityEngine that can be configured by setting the appropriate Velocity settings using
                    the <emphasis>setConfiguration(Properties)</emphasis> method. Here is an example how the engine
                    can be configured in Spring application context:
                </para>

                <programlisting>&lt;bean id="engine" class="org.springmodules.template.engine.velocity.VelocityTemplateEngine"&gt;
    &lt;property name="defaultEncoding" value="UTF-8"/&gt;
    &lt;property name="configuration"&gt;
        &lt;props&gt;
            &lt;!-- Velocity specific properties --&gt;
            &lt;prop key="velocimacro.context.localscope"&gt;false&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>

                <para>
                    A common feature among template engines is support for inter-resource referencing. This feature
                    enables the template author to modularize the structure of the templates and practice code reuse.
                    Velocity support this feature using the <emphasis>#include</emphasis> and <emphasis>#parse</emphasis>
                    directives. The <emphasis>VelocityTemplateEngine</emphasis> integrates tightly with Velocity resource
                    management and leverages Spring's resource &amp; resource loader support to resolve the referenced
                    resources. This enables the template author to define the references in the Spring common resource
                    paths. For example:
                </para>

                <programlisting>&lt;html&gt;
    &lt;body&gt;
        &lt;div&gt;#parse("classpath:header.vm")&lt;/div&gt;
        &lt;div&gt;
            The content body
        &lt;/div&gt;
        &lt;div&gt;#parse("classpath:footer.vm")&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;</programlisting>

                <para>
                    The <emphasis>VelocityTemplateEngine</emphasis> implements Spring's <emphasis>ResourceLoaderAware</emphasis>
                    interface so the application context serves as the resource loader by default.
                </para>

            </sect3>

            <sect3>

                <title>Freemarker</title>

                <para>
                    Freemarker is a mature and feature rich template engine that is well designed and performs well. The
                    <emphasis>org.springmodules.template.engine.freemarker.FreemarkerTemplateEngine</emphasis> class is
                    capable of reading FreeMarker template sources and generate the appropriate FreeMarker templates. The
                    following is an example of application context configuration:
                </para>

                <programlisting>&lt;bean id="freemarker" class="org.springmodules.template.engine.freemarker.FreemarkerTemplateEngine"&gt;
    &lt;property name="defaultEncoding" value="UTF-8"/&gt;
    &lt;property name="settings"&gt;
        &lt;props&gt;
            &lt;prop key="locale"&gt;en_US&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
    &lt;property name="sharedVariables"&gt;
        &lt;map&gt;
            &lt;entry key="name" value="${name}"/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>

                <para>
                    As shown above, it is also possible to define variables that will be shared among all templates. In
                    this case the shared variable is configured using a property placeholder.
                </para>

                <para>
                    Like with Velocity, <emphasis>FreemarkerTemplateEngine</emphasis> also leverages Spring's
                    resource support to support inter-resource referencing. This enables writing a template like:
                </para>

                <programlisting>&lt;html&gt;
    &lt;body&gt;
        &lt;div&gt;&lt;#include "classpath:header.html" parse=false&gt;&lt;/div&gt;
        &lt;div&gt;
            The content body
        &lt;/div&gt;
        &lt;div&gt;&lt;#include "classpath:footer.ftl"&gt;&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;</programlisting>

            </sect3>

            <sect3>

                <title>Groovy Template</title>

                <para>
                    Groovy Template is a library that ships with groovy which enables writing templates in the groovy
                    language (GString's for those familiar with groovy). While current implementation performance
                    is somewhat lagging behind Velocity and Freemarker, groovy as a template language brings quite
                    a lot of power to the hands of template authors. The
                    <emphasis>org.springmodules.template.engine.groovy.GroovyTemplateEngine</emphasis> is the template
                    engine that create Groovy templates. Here is how this engine would be configured in an application
                    context:
                </para>

                <programlisting>&lt;bean id="groovy" class="org.springmodules.template.engine.groovy.GroovyTemplateEngine"&gt;
    &lt;property name="defaultEncoding" value="UTF-8"/&gt;
&lt;/bean&gt;</programlisting>

                <para>
                    As seen above, there isn't much to configure when defining a groovy template engine. This engine is
                    much more simplistic and less featured than both Velocity and Freemarker (for example, it has no support
                    inter-template referencing).
                </para>

            </sect3>

        </sect2>

        <sect2>

            <title>Template Resolvers</title>

            <para>
                We've seen how we can create/define the template engines that enables the creation of template of
                different types. However, in order to utilize them to create those actual templates, one needs to first
                load the appropriate template resource and hand it over to the engine. Although it is perfectly valid
                approach, template resolvers come to simplify this process even more.
            </para>

            <para>
                The following are the different types of template resolvers that are provided out-of-the-box:
            </para>

            <sect3>

                <title>BasicTemplateResolver</title>

                <para>
                    As the name suggests, this is a very basic implementation of the <emphasis>TemplateResolver</emphasis>
                    interface. It is configured with a template engine and a resource loader. The resource loader is used
                    to load the template resources based on the template name, while the template engine is used to create
                    the templates from the loaded template resources. In this case, the resolver's <emphasis>resolve(String)</emphasis>
                    calls the resource loader's <emphasis>getResource(String)</emphasis> with the provided template name.
                    Here is how this resolver can be defined within an application context:
                </para>

                <programlisting>&lt;bean id="resolver" class="org.springmodules.template.resolver.BasicTemplateResolver"&gt;
    &lt;property name="engine" ref="freemarker"/&gt;
&lt;/bean&gt;</programlisting>

                <para>
                    The <emphasis>BasicTemplateResolver</emphasis> also implements the <emphasis>ResourceLoaderAware</emphasis>
                    interface, so when defined in the application context, by default the application context is used
                    as the resource loader implementation.
                </para>

                <para>
                    Most of the time you wouldn't choose to use this implementation in your application. As we'll see soon,
                    this class mainly serves as a base class for the other template resolver implementations.
                </para>

            </sect3>

            <sect3>

                <title>CachingTemplateResolver</title>

                <para>
                    This is a simple extension on top of the <emphasis>BasicTemplateResolver</emphasis> which caches
                    the resolved templates by their names. Calling <emphasis>resolve(String)</emphasis> on this resolver
                    for the first time, will go through the same process as with the <emphasis>BasicTemplateResolver</emphasis>
                    but with one difference, just before the resolved template is returned, it is cached internally by
                    its name. As a consequence, the next call for the same template (using the same template name) will
                    just return the cached template.
                </para>

                <para>
                    Although for most cases using a cached template resolver is the preferred choice, there are some things
                    to consider. First, the cache effectiveness high depends on the concrete implementation of the template
                    that is used. For example, it could be that a template is implemented in such a way that every call to
                    <emphasis>generate(Writer, Map)</emphasis> the template resource is being re-read. Another thing to
                    consider is that some engines has a built-in support for automatic reload (that is, when the template
                    source changes, the template is reloaded). For some implementations, caching the template will
                    prevent from the reload to actually work. Hopefully, in a future release we'll have our own support
                    for such reload functionality.
                </para>

            </sect3>

            <sect3>

                <title>SimpleTemplateResolver</title>

                <para>
                    Again, as its name suggests, this is a simple template resolver that extends the caching resolver.
                    It is very likely that you will use this resolver implementation most of the time. In addition to
                    all functionality this resolver inherits from the caching and basic resolver, it adds two addition
                    features. With this resolver it is possible to define a prefix and a suffix that when combined with
                    the template name, are used to create the template resource path. Here's how this resolver can be
                    configured within an application context:
                </para>

                <programlisting>&lt;bean id="simpleResolver" class="org.springmodules.template.resolver.SimpleTemplateResolver"&gt;
    &lt;property name="engine" ref="freemarker"/&gt;
    &lt;property name="prefix" value="classpath:/templates/"/&gt;
    &lt;property name="suffix" value=".ftl"/&gt;
&lt;/bean&gt;</programlisting>

                <para>
                    In the example above, when trying to resolve a template named "email", the resolver will try to load
                    the template resource from the "classpath:/templates/email.ftl" location. This is quite powerful
                    mechanism as it lets you define all template resources in a well defined and proprietary location,
                    while still the user only needs to deal with the logical name of the template (i.e. "email").
                </para>

            </sect3>

            <sect3>

                <title>LocalizedTemplateResolver</title>

                <para>
                    While the <emphasis>SimpleTemplateResolver</emphasis> can serve you well most of the time, sometimes
                    you want to support multiple locales and provide the same template in multiple languages. The
                    <emphasis>LocalizedTemplateResolver</emphasis> enables you to do just that. Again, it inherits
                    all the functionality from the caching and basic resolvers, while this time, it tries to load
                    localized versions of the templates based on the resource bundles file naming conventions. For example,
                    when resolving a template named "email" with an extension ".ftl" and assuming the current locale
                    context is <emphasis>en_US</emphasis>, it will first try to load the "email_en_US.ftl" resource, when
                    that fails, it will try loading "email_en.ftl", and if that fails it will fallback and try to load
                    "email.ftl". Here's how this resolver can be configured within an application context:
                </para>

                <programlisting>&lt;bean id="localizedResolver" class="org.springmodules.template.resolver.LocalizedTemplateResolver"&gt;
    &lt;property name="engine" ref="freemarker"/&gt;
    &lt;property name="prefix" value="classpath:/templates/"/&gt;
    &lt;property name="extension" value=".ftl"/&gt;
&lt;/bean&gt;</programlisting>

                <para>
                    As can be seen above, this is fairly similar to the configuration of the <emphasis>SimpleTemplateResolver</emphasis>.
                    All of the localization extra work is done inside the resolver itself.
                </para>

            </sect3>

        </sect2>

    </sect1>

    <sect1 id="email-framework">

        <title>Email Framework</title>

        <para>
            Spring comes with an out-of-the-box support for emailing services. The main goal of this support is to
            provide a higher abstraction of this type of service and hide all the complexities when dealing with
            the <emphasis>javax.mail</emphasis> and <emphasis>java.activation</emphasis> API.
        </para>

        <para>
            While this abstraction succeeds in what it was set up to do, it only provides a new (simpler) set of API's for the developer to
            work with. When it comes to integrating the email service in an enterprise application, a quite common approach
            is to write as set of templates (using Velocity or FreeMarker) to represent the email body, so instead of having
            the content of the email hardcoded in java, one can customize this content on demand without changing the codebase.
            While this approach is better than the pure programmatic one, it's only a partial solution to the problem as the
            developer still needs to hard code the other properties of the email such as subject, sender, recipients, and more.
        </para>

        <para>
            This email framework tries to answer all these issues by introducing an XML based email descriptor which
            can serve as a template for creating email definitions. This email definitions are then handled appropriately
            by leveraging Spring's mail services.
        </para>

        <sect2>
            <title>Core Constructs &amp; Interfaces</title>

            <itemizedlist>
                <listitem>
                    <para>
                        <emphasis>Email</emphasis> - A simple POJO representing an email message. As opposed to all Spring's
                        <emphasis>MailMessage</emphasis> implementation, this POJO tries to capture all possible data of
                        a mail message as bean properties including normal and embedded (inline) attachements.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>EmailDispatcher</emphasis> - An interface used to send Email messages. Can be seen
                        as Spring's <emphasis>MailSender</emphasis> counterpart which works with <emphasis>Email</emphasis>
                        objects.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>EmailParser</emphasis> - Represents a parser that can read email descriptors, parse
                        them, and create Email objects from them.
                    </para>
                </listitem>
            </itemizedlist>

        </sect2>

        <sect2>
            <title>EML files - Email Descriptor</title>

            <para>
                The email descriptor is a simple XML source describing an email. It holds most (if not all) data
                associated with an email, making it possible to keep all email definitions outside of the code base.
                Below you can find a sample email descriptor:
            </para>

            <para>
                <programlisting>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
&lt;email xmlns="http://www.springmodules.org/schema/template/email-1.0"&gt;

    &lt;from name="John Doe"&gt;john@doe.org&lt;/from&gt; <co id="from-co" linkends="from"/>

    &lt;reply-to name="No Reply"&gt;noreply@doe.org&lt;/reply-to&gt; <co id="reply-to-co" linkends="reply-to"/>

    &lt;to&gt; <co id="to-co" linkends="to"/>
        &lt;address name="Client"&gt;client@foo.com&lt;/address&gt; <co id="address-co" linkends="address-to"/>
    &lt;/to&gt;

    &lt;cc&gt; <co id="cc-co" linkends="cc"/>
        &lt;address name="Managing Director"&gt;md@doe.org&lt;/address&gt;
        &lt;address name="VP Marketing"&gt;vpm@doe.org&lt;/address&gt;
    &lt;/cc&gt;

    &lt;bcc&gt; <co id="bcc-co" linkends="bcc"/>
        &lt;address&gt;anonymous@doe.org&lt;/address&gt;
    &lt;/bcc&gt;

    &lt;priority&gt;HIGH&lt;/priority&gt; <co id="priority-co" linkends="priority"/>

    &lt;subject&gt;The subject of the mail&lt;/subject&gt; <co id="subject-co" linkends="subject"/>

    &lt;text-body&gt; <co id="text-body-co" linkends="text-body"/>
        This is the text based body of the email
    &lt;/text-body&gt;

    &lt;html-body&gt; <co id="html-body-co" linkends="html-body"/>
        &lt;![CDATA[
            &lt;html&gt;&lt;body&gt;
                &lt;div&gt;&lt;img src="cid:logo"/&gt;&lt;/div&gt;
                &lt;div&gt;This is the HTML based body of the email&lt;/div&gt;
            &lt;/body&gt;&lt;/html&gt;
        ]]&gt;
    &lt;/html-body&gt;

    &lt;attachments&gt; <co id="attachments-co" linkends="attachments"/>
        &lt;attachment name="Marketing.doc"&gt;classpath:/documents/marketing.doc&lt;/attachment&gt; <co id="attachment-co" linkends="attachment"/>
    &lt;/attachments&gt;

    &lt;inline-attachments&gt; <co id="inline-attachments-co" linkends="inline-attachments"/>
        &lt;attachment name="logo"&gt;classpath:/images/logo.gif&lt;/attachment&gt; <co id="inline-attachment-co" linkends="inline-attachment"/>
    &lt;/inline-attachments&gt;

&lt;/email&gt;</programlisting>

                <calloutlist>
                    <callout arearefs="from-co" id="from">
                        <para>Specifying the sender's email address. The "name" attribute is optional and can be used to define the personal name of the sender.</para>
                    </callout>
                    <callout arearefs="reply-to-co" id="reply-to">
                        <para>An optional element specifying the address to which the recipients should reply</para>
                    </callout>
                    <callout arearefs="to-co" id="to">
                        <para>Holds a list of primary recipient addresses to which this email is sent</para>
                    </callout>
                    <callout arearefs="address-co" id="address">
                        <para>Defines an address. The optional "name" attribute can be used to define a personal name for the address</para>
                    </callout>
                    <callout arearefs="cc-co" id="cc">
                        <para>Holds a list of addresses to which this email is will be cc'ed</para>
                    </callout>
                    <callout arearefs="bcc-co" id="bcc">
                        <para>Holds a list of addresses to which this email is will be bcc'ed</para>
                    </callout>
                    <callout arearefs="priority-co" id="priority">
                        <para>
                            Optional element to specify the priority of the email message. The priority can be on of
                            5 options: LOWEST, LOW, NORMAL, HIGH, and HIGHEST. By default the priority is set to NORMAL.
                        </para>
                    </callout>
                    <callout arearefs="subject-co" id="subject">
                        <para>Specifies the subject of the email</para>
                    </callout>
                    <callout arearefs="text-body-co" id="text-body">
                        <para>Specifies the plain text body of the email</para>
                    </callout>
                    <callout arearefs="html-body-co" id="html-body">
                        <para>Specifies the html body of the email.</para>
                    </callout>
                    <callout arearefs="attachments-co" id="attachments">
                        <para>Holds a list of resources to be attached to the email as normal attachments.</para>
                    </callout>
                    <callout arearefs="attachment-co" id="attachment">
                        <para>
                            Defines an attachment where the name serves as the file name and the value specifies
                            the location of the resource. As we'll later see, the location path is determined by the
                            <emphasis>ResourceLoader</emphasis> implementation that is used by the <emphasis>EmailParser</emphasis>.
                            Most commonly the <emphasis>DefaultResourceLoader</emphasis>.
                        </para>
                    </callout>
                    <callout arearefs="inline-attachments-co" id="inline-attachments">
                        <para>Holds a list of resources to be attached to the email as inline (embedded) attachments.</para>
                    </callout>
                    <callout arearefs="inline-attachment-co" id="inline-attachment">
                        <para>
                            Defines an inline attachment where the "name" serves as the id of the attachment by which it
                            can be referenced in the body of the content (for example, assuming the name is set to "001"
                            , the html body can contain the following image element &lt;img src="cid:theId""/&gt;). Here too
                            the value of the element specifies the location of the resource. As we'll later see, the
                            location path is determined by the <emphasis>ResourceLoader</emphasis> implementation that
                            is used by the <emphasis>EmailParser</emphasis>. Most commonly the <emphasis>DefaultResourceLoader</emphasis>.
                        </para>
                    </callout>
                </calloutlist>
            </para>

            <para>
                This XML based email descriptor is the only descriptor that the framework is delivered with. Nonetheless,
                it is possible to define other descriptors as well. The <emphasis>EmailParser</emphasis> interface enables
                loading an email descriptor resource into an Email object. The default implementation is
                <emphasis>SaxEmailParser</emphasis> with parses the XML based descriptor.
            </para>


        </sect2>

        <sect2>
            <title>Email Dispatcher</title>

            <para>
                The email dispatcher is the heart of this framework. This interface enables sending emails. Here is the
                <emphasis>EmailDispatcher</emphasis> interface:
            </para>

            <programlisting>public interface EmailDispatcher {

    void send(Email email); <co id="email-co" linkends="email"/>

    void send(String emailName); <co id="name-co" linkends="name"/>

    void send(String emailName, Map model); <co id="name-model-co" linkends="name-model"/>

    void send(String emailName, Map model, EmailPreparator preparator); <co id="name-model-preparator-co" linkends="name-model-preparator"/>

}</programlisting>

            <para>
                <calloutlist>
                    <callout arearefs="email-co" id="email">
                        <para>
                            Sends the given email
                        </para>
                    </callout>
                    <callout arearefs="name-co" id="name">
                        <para>
                            Resolves the email identified by the given name and sends it.
                        </para>
                    </callout>
                    <callout arearefs="name-model-co" id="name-model">
                        <para>
                            Resolves the email identified by the given name, populating it using the given model and
                            sends it.
                        </para>
                    </callout>
                    <callout arearefs="name-model-preparator-co" id="name-model-preparator">
                        <para>
                            Resolves the email identified by the given name, populating it using the given model, preparing
                            it using the given email preparator and sends it.
                        </para>
                    </callout>
                </calloutlist>
            </para>

            <para>
                As can be seen, there are essentially two ways of sending an email. A direct way which mean the client
                of this interface provides the email to be sent. The other way is more implicit way where the client
                requests the dispatcher to send an email identified by its name.
            </para>

            <para>
                <emphasis>AbstractEmailDispatcher</emphasis> is a base class for the two concrete implementation of this
                interface <emphasis>JavaMailEmailDispatcher</emphasis> and <emphasis>SimpleEmailDispatcher</emphasis>. The
                abstract class takes care of resolving and preparing the emails. It does this by first loading the
                appropriate template for the given email, generating the output using the given model, The output is expected
                to be an email descriptor and so an <emphasis>EmailParser</emphasis> is used to parse it to a concrete
                <emphasis>Email</emphasis> object. And last but not least, if necessary, preparing the result email using an
                <emphasis>EmailPreparator</emphasis>. In this implementation, the email name essentially serves as an
                email template name that will eventually be generating the actual emails descriptors.
            </para>

            <para>
                As mentioned above there are two concrete <emphasis>EmailDispatcher</emphasis> implementations:
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        <emphasis>JavaMailEmailDispatcher</emphasis> - This dispatcher should be used when configured with
                        a <emphasis>JavaMailSender</emphasis> as the underlying <emphasis>MailSender</emphasis>.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>SimpleEmailDispatcher</emphasis> - This dispatcher should be used when configured with
                        other <emphasis>MailSender</emphasis> implementations such as <emphasis>CosMailSenderImpl</emphasis>.
                        As <emphasis>MailSender</emphasis> works with <emphasis>SimpleMailMessage</emphasis>, this
                        dispatcher makes sure that only the supported information is extracted from the provided
                        <emphasis>Email</emphasis> objects. For example, the attachments in the provided emails will be
                        ignored since <emphasis>SimpleMailMessage</emphasis> does not support attachments of any kind.
                    </para>
                </listitem>
            </itemizedlist>

            <para>
                Here's an example of how the <emphasis>JavaMailEmailDispatcher</emphasis> can be configured in
                an application context:
            </para>

            <programlisting>&lt;bean id="emailDispatcher" class="org.springmodules.email.JavaMailEmailDispatcher"&gt;
    &lt;property name="emailParser" ref="emailParser"/&gt;
    &lt;property name="mailSender" ref="mailSender"/&gt;
    &lt;property name="templateResolver" ref="templateResolver"/&gt;
&lt;/bean&gt;

&lt;bean id="emailParser" class="org.springmodules.email.conf.SaxEmailParser"/&gt;

&lt;bean id="mailSender" class="org.springframework.mail.javamail.JavaMailSenderImpl"&gt;
    &lt;property name="host" value="${mail.host}"/&gt;
    &lt;property name="port" value="${mai.port}"/&gt;
&lt;/bean&gt;

&lt;bean id="templateResolver" class="org.springmodules.template.resolver.SimpleTemplateResolver"&gt;
    &lt;property name="engine" ref="freemarker"/&gt;
    &lt;property name="prefix" value="classpath:/emails/"/&gt;
    &lt;property name="suffix" value=".eml"/&gt;
&lt;/bean&gt;

&lt;bean id="freemarker" class="org.springmodules.template.engine.freemarker.FreemarkerTemplateEngine"/&gt;</programlisting>

        </sect2>

    </sect1>

</chapter>