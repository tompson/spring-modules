/* 
 * Created on Sep 24, 2004
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 * Copyright @2004 the original author or authors.
 */

package org.springmodules.cache.interceptor.caching;

import java.io.Serializable;
import java.lang.reflect.Method;

import junit.framework.TestCase;

import org.aopalliance.intercept.MethodInvocation;
import org.easymock.MockControl;
import org.springmodules.cache.key.CacheKeyGenerator;
import org.springmodules.cache.key.HashCodeCacheKeyGenerator;
import org.springmodules.cache.provider.CacheProviderFacade;

/**
 * <p>
 * Unit Tests for <code>{@link CachingInterceptor}</code>.
 * </p>
 * 
 * @author Alex Ruiz
 * 
 * @version $Revision: 1.6 $ $Date: 2005/09/09 02:19:00 $
 */
public final class CachingInterceptorTests extends TestCase {

  /**
   * Key to be generated by <code>{@link #cacheKeyGenerator}</code>.
   */
  private Serializable cacheKey;

  private CacheKeyGenerator cacheKeyGenerator;

  private MockControl cacheKeyGeneratorControl;

  private CacheProviderFacade cacheProviderFacade;

  private MockControl cacheProviderFacadeControl;

  /**
   * Metadata attribute for the intercepted method.
   */
  private Cached cachingAttribute;

  private CachingAttributeSource cachingAttributeSource;

  private MockControl cachingAttributeSourceControl;

  private CachingInterceptor cachingInterceptor;

  private EntryStoredListener entryStoredListener;

  private MockControl entryStoredListenerControl;

  /**
   * Method to be intercepted by <code>{@link #cachingInterceptor}</code>.
   */
  private Method interceptedMethod;

  private MethodInvocation methodInvocation;

  private MockControl methodInvocationControl;

  public CachingInterceptorTests(String name) {
    super(name);
  }

  protected void setUp() throws Exception {
    super.setUp();

    Class targetClass = String.class;
    interceptedMethod = targetClass.getMethod("concat",
        new Class[] { String.class });

    cacheProviderFacadeControl = MockControl
        .createControl(CacheProviderFacade.class);
    cacheProviderFacade = (CacheProviderFacade) cacheProviderFacadeControl
        .getMock();

    cachingAttribute = new Cached();
    cachingAttribute.setCacheProfileId("CACHE_PROFILE");

    cachingAttributeSourceControl = MockControl
        .createControl(CachingAttributeSource.class);
    cachingAttributeSource = (CachingAttributeSource) cachingAttributeSourceControl
        .getMock();

    methodInvocationControl = MockControl.createControl(MethodInvocation.class);
    methodInvocation = (MethodInvocation) methodInvocationControl.getMock();

    cachingInterceptor = new CachingInterceptor();
    cachingInterceptor.setCacheProviderFacade(cacheProviderFacade);
    cachingInterceptor.setCachingAttributeSource(cachingAttributeSource);

    setUpCommonMockControlExpectations();
  }

  private void setUpCacheKey() {
    cacheKey = "Key";
  }

  private void setUpCommonMockControlExpectations() {
    methodInvocation.getMethod();
    methodInvocationControl.setReturnValue(interceptedMethod);
  }

  private void setUpCacheKeyGeneratorAsMockObject() {
    cacheKeyGeneratorControl = MockControl
        .createControl(CacheKeyGenerator.class);
    cacheKeyGenerator = (CacheKeyGenerator) cacheKeyGeneratorControl.getMock();
    cachingInterceptor.setCacheKeyGenerator(cacheKeyGenerator);
  }

  private void setUpEntryStoredListenerAsMockObject() {
    entryStoredListenerControl = MockControl
        .createControl(EntryStoredListener.class);
    entryStoredListener = (EntryStoredListener) entryStoredListenerControl
        .getMock();
    cachingInterceptor.setEntryStoredListener(entryStoredListener);
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#afterPropertiesSet()}</code> assigns a
   * new instance of <code>{@link HashCodeCacheKeyGenerator}</code> as the key
   * generator of the interceptor if the interceptor does not have a cache
   * generator already set.
   */
  public void testAfterPropertiesSetWhenCacheKeyGeneratorIsNotSet() {
    cachingInterceptor.setCacheKeyGenerator(null);

    // execute the method to test.
    cachingInterceptor.afterPropertiesSet();

    CacheKeyGenerator assignedCacheKeyGenerator = cachingInterceptor
        .getCacheKeyGenerator();
    assertNotNull(assignedCacheKeyGenerator);

    Class expectedClass = HashCodeCacheKeyGenerator.class;
    assertEquals("<Key generator class>", expectedClass,
        assignedCacheKeyGenerator.getClass());
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#afterPropertiesSet()}</code> does not
   * change the key generator assigned to the interceptor.
   */
  public void testAfterPropertiesSetWhenCacheKeyGeneratorIsSet() {
    CacheKeyGenerator newCacheKeyGenerator = new HashCodeCacheKeyGenerator();
    cachingInterceptor = new CachingInterceptor();
    cachingInterceptor.setCacheKeyGenerator(newCacheKeyGenerator);

    // execute the method to test.
    cachingInterceptor.afterPropertiesSet();

    assertSame(newCacheKeyGenerator, cachingInterceptor.getCacheKeyGenerator());
  }

  private void setStateOfMockControlsToReplay() {
    if (cacheKeyGeneratorControl != null) {
      cacheKeyGeneratorControl.replay();
    }

    cacheProviderFacadeControl.replay();
    cachingAttributeSourceControl.replay();

    if (entryStoredListenerControl != null) {
      entryStoredListenerControl.replay();
    }

    methodInvocationControl.replay();
  }

  private void verifyExpectationsOfMockControlsWereMet() {
    if (cacheKeyGeneratorControl != null) {
      cacheKeyGeneratorControl.verify();
    }

    cacheProviderFacadeControl.verify();
    cachingAttributeSourceControl.verify();

    if (entryStoredListenerControl != null) {
      entryStoredListenerControl.verify();
    }

    methodInvocationControl.verify();
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#getCachingAttribute(MethodInvocation)}</code>
   * returns the instance of <code>{@link Cached}</code> retrieved from
   * <code>{@link #cachingAttributeSource}</code>.
   */
  public void testGetCachingAttribute() throws Exception {
    Object thisObject = "A String!";
    Class targetClass = thisObject.getClass();

    // get the target object for an invocation.
    methodInvocation.getThis();
    methodInvocationControl.setReturnValue(thisObject);

    // get the caching attribute of the intercepted method.
    cachingAttributeSource.getCachingAttribute(interceptedMethod, targetClass);
    cachingAttributeSourceControl.setReturnValue(cachingAttribute);

    setStateOfMockControlsToReplay();

    // execute the method to test.
    Cached returnedCachingAttribute = cachingInterceptor
        .getCachingAttribute(methodInvocation);

    assertSame(cachingAttribute, returnedCachingAttribute);

    verifyExpectationsOfMockControlsWereMet();
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#getCachingAttribute(MethodInvocation)}</code>
   * returns the instance of <code>{@link Cached}</code> retrieved from
   * <code>{@link #cachingAttributeSource}</code> when
   * <code>MethodInvocation.getThis()</code> returns <code>null</code>.
   */
  public void testGetCachingAttributeWithMethodInvocationHavingThisObjectEqualToNull()
      throws Exception {

    Object thisObject = null;
    Class targetClass = null;

    // get the target object for an invocation.
    methodInvocation.getThis();
    methodInvocationControl.setReturnValue(thisObject);

    // get the caching attribute of the intercepted method.
    cachingAttributeSource.getCachingAttribute(interceptedMethod, targetClass);
    cachingAttributeSourceControl.setReturnValue(cachingAttribute);

    setStateOfMockControlsToReplay();

    // execute the method to test.
    Cached returnedCachingAttribute = cachingInterceptor
        .getCachingAttribute(methodInvocation);

    assertSame(cachingAttribute, returnedCachingAttribute);

    verifyExpectationsOfMockControlsWereMet();
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#invoke(MethodInvocation)}</code> does not
   * store in the cache the return value of the intercepted method if the
   * intercepted method does not contain any caching attributes.
   */
  public void testInvokeHavingCachingAttributeEqualToNull() throws Throwable {
    Object thisObject = "A String!";
    Class targetClass = thisObject.getClass();

    // return value expected to be returned when executing the intercepted
    // method.
    Object expectedReturnValue = new Integer(10);

    // get the target object for an invocation.
    methodInvocation.getThis();
    methodInvocationControl.setReturnValue(thisObject);

    // get the caching attribute for the intercepted method. The returned
    // caching attribute should be null.
    cachingAttributeSource.getCachingAttribute(interceptedMethod, targetClass);
    cachingAttributeSourceControl.setReturnValue(null);

    // execute the intercepted method. The return value should not be cached
    // since there is not any caching attribute.
    methodInvocation.proceed();
    methodInvocationControl.setReturnValue(expectedReturnValue);

    setStateOfMockControlsToReplay();

    // execute the method to test.
    Object actualReturnValue = cachingInterceptor.invoke(methodInvocation);

    assertSame(expectedReturnValue, actualReturnValue);

    verifyExpectationsOfMockControlsWereMet();
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#invoke(MethodInvocation)}</code> returns
   * <code>null</code> if the cache already stored the returned value of the
   * intercepted method and the stored value is
   * <code>{@link CachingAspectSupport#NULL_ENTRY}</code>.
   */
  public void testInvokeHavingObjectInCacheEqualToNullEntry() throws Throwable {
    setUpCacheKey();
    setUpCacheKeyGeneratorAsMockObject();
    Object thisObject = "A String!";
    Class targetClass = thisObject.getClass();
    Object cachedObject = CachingAspectSupport.NULL_ENTRY;

    // get the target object for an invocation.
    methodInvocation.getThis();
    methodInvocationControl.setReturnValue(thisObject);

    // get the caching attribute for the intercepted method.
    cachingAttributeSource.getCachingAttribute(interceptedMethod, targetClass);
    cachingAttributeSourceControl.setReturnValue(cachingAttribute);

    // generate the key for the object to cache (or already cached).
    cacheKeyGenerator.generateKey(methodInvocation);
    cacheKeyGeneratorControl.setReturnValue(cacheKey);

    // get the object stored in the cache under the id retrieved from the
    // caching attribute.
    String cacheProfileId = cachingAttribute.getCacheProfileId();
    cacheProviderFacade.getFromCache(cacheKey, cacheProfileId);
    cacheProviderFacadeControl.setReturnValue(cachedObject);

    setStateOfMockControlsToReplay();

    // execute the method to test.
    Object actualCachedObject = cachingInterceptor.invoke(methodInvocation);

    assertNull(actualCachedObject);

    verifyExpectationsOfMockControlsWereMet();
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#invoke(MethodInvocation)}</code>
   * retrieves from the cache the stored return value of the intercepted method
   * and returns it instead of executing the method.
   */
  public void testInvokeHavingObjectInCacheNotEqualToNull() throws Throwable {
    setUpCacheKey();
    setUpCacheKeyGeneratorAsMockObject();
    Object thisObject = "A String!";
    Class targetClass = thisObject.getClass();
    Object expectedCachedObject = new Integer(4225);

    // get the target object for an invocation.
    methodInvocation.getThis();
    methodInvocationControl.setReturnValue(thisObject);

    // get the caching attribute for the intercepted method.
    cachingAttributeSource.getCachingAttribute(interceptedMethod, targetClass);
    cachingAttributeSourceControl.setReturnValue(cachingAttribute);

    // generate the key for the object to cache (or already cached).
    cacheKeyGenerator.generateKey(methodInvocation);
    cacheKeyGeneratorControl.setReturnValue(cacheKey);

    // get the object stored in the cache under the id retrieved from the
    // caching attribute.
    String cacheProfileId = cachingAttribute.getCacheProfileId();
    cacheProviderFacade.getFromCache(cacheKey, cacheProfileId);
    cacheProviderFacadeControl.setReturnValue(expectedCachedObject);

    setStateOfMockControlsToReplay();

    // execute the method to test.
    Object actualCachedObject = cachingInterceptor.invoke(methodInvocation);

    assertSame(expectedCachedObject, actualCachedObject);

    verifyExpectationsOfMockControlsWereMet();
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#invoke(MethodInvocation)}</code> stores
   * in the cache the return value of the intercepted method and notifies the
   * listener that a new object has been saved in the cache.
   */
  public void testInvokeWhenObjectIsNotCachedAndInterceptorHasListener()
      throws Throwable {
    setUpCacheKey();
    setUpCacheKeyGeneratorAsMockObject();
    setUpEntryStoredListenerAsMockObject();

    Object thisObject = "A String!";
    Class targetClass = thisObject.getClass();
    Object proceedReturnValue = new Integer(434);

    // get the target object for an invocation.
    methodInvocation.getThis();
    methodInvocationControl.setReturnValue(thisObject);

    // get the caching attribute for the intercepted method.
    cachingAttributeSource.getCachingAttribute(interceptedMethod, targetClass);
    cachingAttributeSourceControl.setReturnValue(cachingAttribute);

    // generate the key for the object to cache (or already cached).
    cacheKeyGenerator.generateKey(methodInvocation);
    cacheKeyGeneratorControl.setReturnValue(cacheKey);

    // get the object stored in the cache under the id retrieved from the
    // caching attribute. There should not be any cached object.
    String cacheProfileId = cachingAttribute.getCacheProfileId();
    cacheProviderFacade.getFromCache(cacheKey, cacheProfileId);
    cacheProviderFacadeControl.setReturnValue(null);

    // since the object is not cached, execute the intercepted method.
    methodInvocation.proceed();
    methodInvocationControl.setReturnValue(proceedReturnValue);

    // put in the cache the return value of the intercepted method.
    cacheProviderFacade
        .putInCache(cacheKey, cacheProfileId, proceedReturnValue);

    entryStoredListener.onEntryAdd(cacheKey, proceedReturnValue);

    setStateOfMockControlsToReplay();

    // execute the method to test.
    Object actualCachedObject = cachingInterceptor.invoke(methodInvocation);

    assertSame(proceedReturnValue, actualCachedObject);

    verifyExpectationsOfMockControlsWereMet();
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#invoke(MethodInvocation)}</code> stores
   * in the cache <code>{@link CachingAspectSupport#NULL_ENTRY}</code> if the
   * return value of the intercepted method is <code>null</code>.
   */
  public void testInvokeWhenObjectIsNotCachedAndProceedReturnsNull()
      throws Throwable {

    setUpCacheKey();
    setUpCacheKeyGeneratorAsMockObject();

    Object thisObject = "A String!";
    Class targetClass = thisObject.getClass();

    // get the target object for an invocation.
    methodInvocation.getThis();
    methodInvocationControl.setReturnValue(thisObject);

    // get the caching attribute for the intercepted method.
    cachingAttributeSource.getCachingAttribute(interceptedMethod, targetClass);
    cachingAttributeSourceControl.setReturnValue(cachingAttribute);

    // generate the key for the object to cache (or already cached).
    cacheKeyGenerator.generateKey(methodInvocation);
    cacheKeyGeneratorControl.setReturnValue(cacheKey);

    // get the object stored in the cache under the id retrieved from the
    // caching attribute. There should not be any cached object.
    String cacheProfileId = cachingAttribute.getCacheProfileId();
    cacheProviderFacade.getFromCache(cacheKey, cacheProfileId);
    cacheProviderFacadeControl.setReturnValue(null);

    // since the object is not cached, execute the intercepted method.
    methodInvocation.proceed();
    methodInvocationControl.setReturnValue(null);

    // put in the cache the return value of the intercepted method.
    cacheProviderFacade.putInCache(cacheKey, cacheProfileId,
        CachingAspectSupport.NULL_ENTRY);

    setStateOfMockControlsToReplay();

    // execute the method to test.
    Object actualReturnedValue = cachingInterceptor.invoke(methodInvocation);

    assertNull("The return value of the intercepted method should be null",
        actualReturnedValue);

    verifyExpectationsOfMockControlsWereMet();
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#invoke(MethodInvocation)}</code> cancels
   * the update being made to the cache when a <code>Throwable</code> is
   * thrown when the intercepted method is being executed.
   */
  public void testInvokeWhenObjectIsNotCachedAndProceedThrowsThrowable()
      throws Throwable {

    setUpCacheKey();
    setUpCacheKeyGeneratorAsMockObject();

    Object thisObject = "A String!";
    Class targetClass = thisObject.getClass();

    // get the target object for an invocation.
    methodInvocation.getThis();
    methodInvocationControl.setReturnValue(thisObject);

    // get the caching attribute for the intercepted method.
    cachingAttributeSource.getCachingAttribute(interceptedMethod, targetClass);
    cachingAttributeSourceControl.setReturnValue(cachingAttribute);

    // generate the key for the object to cache (or already
    // cached).
    cacheKeyGenerator.generateKey(methodInvocation);
    cacheKeyGeneratorControl.setReturnValue(cacheKey);

    // get the object stored in the cache under the id retrieved from the
    // caching attribute. There should not be any cached object.
    String cacheProfileId = cachingAttribute.getCacheProfileId();
    cacheProviderFacade.getFromCache(cacheKey, cacheProfileId);
    cacheProviderFacadeControl.setReturnValue(null);

    // since the object is not cached, execute the intercepted method. It should
    // throw an exception.
    methodInvocation.proceed();
    methodInvocationControl.setThrowable(new Throwable());

    // cancel the update to the cache.
    cacheProviderFacade.cancelCacheUpdate(cacheKey);

    setStateOfMockControlsToReplay();

    // execute the method to test.
    try {
      cachingInterceptor.invoke(methodInvocation);
      fail();
    } catch (Throwable throwable) {
      // we expect to catch this throwable.
    }

    verifyExpectationsOfMockControlsWereMet();
  }
}