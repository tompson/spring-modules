/* 
 * Created on Sep 24, 2004
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 * Copyright @2004 the original author or authors.
 */

package org.springmodules.cache.interceptor.caching;

import java.io.Serializable;

import org.aopalliance.intercept.MethodInvocation;
import org.easymock.MockControl;
import org.springmodules.cache.interceptor.AbstractCacheModuleInterceptorTests;
import org.springmodules.cache.key.CacheKeyGenerator;
import org.springmodules.cache.key.HashCodeCacheKeyGenerator;
import org.springmodules.cache.provider.CacheProviderFacadeStatus;

/**
 * <p>
 * Unit Tests for <code>{@link CachingInterceptor}</code>.
 * </p>
 * 
 * @author Alex Ruiz
 * 
 * @version $Revision: 1.8 $ $Date: 2005/09/22 00:42:40 $
 */
public final class CachingInterceptorTests extends
    AbstractCacheModuleInterceptorTests {

  /**
   * Key to be generated by <code>{@link #cacheKeyGenerator}</code>.
   */
  private Serializable cacheKey;

  private CacheKeyGenerator cacheKeyGenerator;

  private MockControl cacheKeyGeneratorControl;

  /**
   * Metadata attribute for the intercepted method.
   */
  private Cached cachingAttribute;

  private CachingAttributeSource cachingAttributeSource;

  private MockControl cachingAttributeSourceControl;

  private CachingInterceptor cachingInterceptor;

  private EntryStoredListener entryStoredListener;

  private MockControl entryStoredListenerControl;

  public CachingInterceptorTests(String name) {
    super(name);
  }

  private void assertInterceptorInvocationIsCorrect(
      Object expectedInvocationReturnValue) throws Throwable {
    setStateOfMockControlsToReplay();

    Object actualReturnValue = cachingInterceptor.invoke(methodInvocation);
    assertSame(expectedInvocationReturnValue, actualReturnValue);

    verifyExpectationsOfMockControlsWereMet();
  }

  private void assertInvokeWithStatusOfCacheProviderNotReadyDoesNotAccessCache(
      CacheProviderFacadeStatus status) throws Throwable {
    cacheProviderFacade.getStatus();
    cacheProviderFacadeControl.setReturnValue(status);

    Object proceedReturnValue = "Luke Skywalker";
    expectProceedMethodInvocation(proceedReturnValue);

    assertInterceptorInvocationIsCorrect(proceedReturnValue);
  }

  private void expectGenerateCacheEntryKey() {
    cacheKeyGenerator.generateKey(methodInvocation);
    cacheKeyGeneratorControl.setReturnValue(cacheKey);
  }

  private void expectGetCacheEntry(Object returnValue) {
    cacheProviderFacade.getFromCache(cacheKey, cachingAttribute
        .getCacheProfileId());
    cacheProviderFacadeControl.setReturnValue(returnValue);
  }

  private void expectGetCachingAttributeForInterceptedMethod(Object thisObject,
      Cached returnValue) {
    Class targetClass = (thisObject != null) ? thisObject.getClass() : null;

    expectGetMethodFromMethodInvocation();
    cachingAttributeSource.getCachingAttribute(interceptedMethod, targetClass);
    cachingAttributeSourceControl.setReturnValue(returnValue);
  }

  protected void onSetStateOfMockControlsToReplay() {
    if (cacheKeyGeneratorControl != null) {
      cacheKeyGeneratorControl.replay();
    }

    cachingAttributeSourceControl.replay();

    if (entryStoredListenerControl != null) {
      entryStoredListenerControl.replay();
    }
  }

  protected void onSetUp() throws Exception {
    cachingAttribute = new Cached();
    cachingAttribute.setCacheProfileId("CACHE_PROFILE");

    cachingAttributeSourceControl = MockControl
        .createControl(CachingAttributeSource.class);
    cachingAttributeSource = (CachingAttributeSource) cachingAttributeSourceControl
        .getMock();

    cachingInterceptor = new CachingInterceptor();
    cachingInterceptor.setCacheProviderFacade(cacheProviderFacade);
    cachingInterceptor.setCachingAttributeSource(cachingAttributeSource);
  }

  protected void onVerifyExpectationsOfMockControlsWereMet() {
    if (cacheKeyGeneratorControl != null) {
      cacheKeyGeneratorControl.verify();
    }

    cachingAttributeSourceControl.verify();

    if (entryStoredListenerControl != null) {
      entryStoredListenerControl.verify();
    }
  }

  private void setUpCacheKeyAndCacheKeyGeneratorAsMockObject() {
    cacheKey = "Tie Fighter";

    cacheKeyGeneratorControl = MockControl
        .createControl(CacheKeyGenerator.class);
    cacheKeyGenerator = (CacheKeyGenerator) cacheKeyGeneratorControl.getMock();
    cachingInterceptor.setCacheKeyGenerator(cacheKeyGenerator);
  }

  private void setUpEntryStoredListenerAsMockObject() {
    entryStoredListenerControl = MockControl
        .createControl(EntryStoredListener.class);
    entryStoredListener = (EntryStoredListener) entryStoredListenerControl
        .getMock();
    cachingInterceptor.setEntryStoredListener(entryStoredListener);
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#afterPropertiesSet()}</code> assigns a
   * new instance of <code>{@link HashCodeCacheKeyGenerator}</code> as the key
   * generator of the interceptor if the interceptor does not have a cache
   * generator already set.
   */
  public void testAfterPropertiesSetWhenCacheKeyGeneratorIsNotSet() {
    cachingInterceptor.setCacheKeyGenerator(null);

    // execute the method to test.
    cachingInterceptor.afterPropertiesSet();

    CacheKeyGenerator assignedCacheKeyGenerator = cachingInterceptor
        .getCacheKeyGenerator();
    assertNotNull(assignedCacheKeyGenerator);

    assertEquals(HashCodeCacheKeyGenerator.class, assignedCacheKeyGenerator
        .getClass());
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#afterPropertiesSet()}</code> does not
   * change the key generator assigned to the interceptor.
   */
  public void testAfterPropertiesSetWhenCacheKeyGeneratorIsSet() {
    CacheKeyGenerator newCacheKeyGenerator = new HashCodeCacheKeyGenerator();
    cachingInterceptor = new CachingInterceptor();
    cachingInterceptor.setCacheKeyGenerator(newCacheKeyGenerator);

    // execute the method to test.
    cachingInterceptor.afterPropertiesSet();

    assertSame(newCacheKeyGenerator, cachingInterceptor.getCacheKeyGenerator());
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#getCachingAttribute(MethodInvocation)}</code>
   * returns the instance of <code>{@link Cached}</code> retrieved from
   * <code>{@link #cachingAttributeSource}</code>.
   */
  public void testGetCachingAttribute() throws Exception {
    Object thisObject = OBJECT_HOLDING_JOINPOINT_STATIC_PART;
    expectGetThisFromJoinpoint(thisObject);
    expectGetCachingAttributeForInterceptedMethod(thisObject, cachingAttribute);

    setStateOfMockControlsToReplay();

    // execute the method to test.
    Cached returnedCachingAttribute = cachingInterceptor
        .getCachingAttribute(methodInvocation);

    assertSame(cachingAttribute, returnedCachingAttribute);

    verifyExpectationsOfMockControlsWereMet();
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#getCachingAttribute(MethodInvocation)}</code>
   * returns the instance of <code>{@link Cached}</code> retrieved from
   * <code>{@link #cachingAttributeSource}</code> when
   * <code>MethodInvocation.getThis()</code> returns <code>null</code>.
   */
  public void testGetCachingAttributeWithMethodInvocationHavingThisObjectEqualToNull()
      throws Exception {
    Object thisObject = null;
    expectGetThisFromJoinpoint(thisObject);
    expectGetCachingAttributeForInterceptedMethod(thisObject, cachingAttribute);

    setStateOfMockControlsToReplay();

    // execute the method to test.
    Cached returnedCachingAttribute = cachingInterceptor
        .getCachingAttribute(methodInvocation);

    assertSame(cachingAttribute, returnedCachingAttribute);

    verifyExpectationsOfMockControlsWereMet();
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#invoke(MethodInvocation)}</code> does not
   * store in the cache the return value of the intercepted method if the
   * intercepted method does not contain any caching attributes.
   */
  public void testInvokeHavingCachingAttributeEqualToNull() throws Throwable {
    expectCacheProviderFacadeStatusIsReady();

    Object thisObject = OBJECT_HOLDING_JOINPOINT_STATIC_PART;
    expectGetThisFromJoinpoint(thisObject);
    expectGetCachingAttributeForInterceptedMethod(thisObject, null);

    // execute the intercepted method. The return value should not be cached
    // since there is not any caching attribute.
    Object proceedReturnValue = new Integer(10);
    expectProceedMethodInvocation(proceedReturnValue);

    assertInterceptorInvocationIsCorrect(proceedReturnValue);
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#invoke(MethodInvocation)}</code> returns
   * <code>null</code> if the cache already stored the returned value of the
   * intercepted method and the stored value is
   * <code>{@link CachingAspectSupport#NULL_ENTRY}</code>.
   */
  public void testInvokeHavingObjectInCacheEqualToNullEntry() throws Throwable {
    setUpCacheKeyAndCacheKeyGeneratorAsMockObject();

    expectCacheProviderFacadeStatusIsReady();

    Object thisObject = OBJECT_HOLDING_JOINPOINT_STATIC_PART;
    expectGetThisFromJoinpoint(thisObject);
    expectGetCachingAttributeForInterceptedMethod(thisObject, cachingAttribute);
    expectGenerateCacheEntryKey();

    // get the object stored in the cache under the id retrieved from the
    // caching attribute.
    expectGetCacheEntry(CachingAspectSupport.NULL_ENTRY);

    assertInterceptorInvocationIsCorrect(null);
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#invoke(MethodInvocation)}</code>
   * retrieves from the cache the stored return value of the intercepted method
   * and returns it instead of executing the method.
   */
  public void testInvokeHavingObjectInCacheNotEqualToNull() throws Throwable {
    setUpCacheKeyAndCacheKeyGeneratorAsMockObject();

    expectCacheProviderFacadeStatusIsReady();

    Object thisObject = OBJECT_HOLDING_JOINPOINT_STATIC_PART;
    expectGetThisFromJoinpoint(thisObject);
    expectGetCachingAttributeForInterceptedMethod(thisObject, cachingAttribute);
    expectGenerateCacheEntryKey();

    Object expectedCachedObject = new Integer(4225);
    expectGetCacheEntry(expectedCachedObject);

    assertInterceptorInvocationIsCorrect(expectedCachedObject);
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#invoke(MethodInvocation)}</code> stores
   * in the cache the return value of the intercepted method and notifies the
   * listener that a new object has been saved in the cache.
   */
  public void testInvokeWhenObjectIsNotCachedAndInterceptorHasListener()
      throws Throwable {
    setUpCacheKeyAndCacheKeyGeneratorAsMockObject();
    setUpEntryStoredListenerAsMockObject();

    expectCacheProviderFacadeStatusIsReady();

    Object thisObject = OBJECT_HOLDING_JOINPOINT_STATIC_PART;
    expectGetThisFromJoinpoint(thisObject);
    expectGetCachingAttributeForInterceptedMethod(thisObject, cachingAttribute);
    expectGenerateCacheEntryKey();

    // get the object stored in the cache under the id retrieved from the
    // caching attribute. There should not be any cached object.
    expectGetCacheEntry(null);

    Object proceedReturnValue = new Integer(434);
    expectProceedMethodInvocation(proceedReturnValue);

    // put in the cache the return value of the intercepted method.
    String cacheProfileId = cachingAttribute.getCacheProfileId();
    cacheProviderFacade
        .putInCache(cacheKey, cacheProfileId, proceedReturnValue);

    entryStoredListener.onEntryAdd(cacheKey, proceedReturnValue);

    assertInterceptorInvocationIsCorrect(proceedReturnValue);
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#invoke(MethodInvocation)}</code> stores
   * in the cache <code>{@link CachingAspectSupport#NULL_ENTRY}</code> if the
   * return value of the intercepted method is <code>null</code>.
   */
  public void testInvokeWhenObjectIsNotCachedAndProceedReturnsNull()
      throws Throwable {
    setUpCacheKeyAndCacheKeyGeneratorAsMockObject();

    expectCacheProviderFacadeStatusIsReady();

    Object thisObject = OBJECT_HOLDING_JOINPOINT_STATIC_PART;
    expectGetThisFromJoinpoint(thisObject);
    expectGetCachingAttributeForInterceptedMethod(thisObject, cachingAttribute);
    expectGenerateCacheEntryKey();

    // get the object stored in the cache under the id retrieved from the
    // caching attribute. There should not be any cached object.
    expectGetCacheEntry(null);

    expectProceedMethodInvocation(null);

    // put in the cache the return value of the intercepted method.
    cacheProviderFacade.putInCache(cacheKey, cachingAttribute
        .getCacheProfileId(), CachingAspectSupport.NULL_ENTRY);

    assertInterceptorInvocationIsCorrect(null);
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#invoke(MethodInvocation)}</code> cancels
   * the update being made to the cache when a <code>Throwable</code> is
   * thrown when the intercepted method is being executed.
   */
  public void testInvokeWhenObjectIsNotCachedAndProceedThrowsThrowable()
      throws Throwable {
    setUpCacheKeyAndCacheKeyGeneratorAsMockObject();

    expectCacheProviderFacadeStatusIsReady();

    Object thisObject = OBJECT_HOLDING_JOINPOINT_STATIC_PART;
    expectGetThisFromJoinpoint(thisObject);
    expectGetCachingAttributeForInterceptedMethod(thisObject, cachingAttribute);
    expectGenerateCacheEntryKey();

    // get the object stored in the cache under the id retrieved from the
    // caching attribute. There should not be any cached object.
    expectGetCacheEntry(null);

    // since the object is not cached, execute the intercepted method. It should
    // throw an exception.
    methodInvocation.proceed();
    methodInvocationControl.setThrowable(new Throwable());

    // cancel the update to the cache.
    cacheProviderFacade.cancelCacheUpdate(cacheKey);

    setStateOfMockControlsToReplay();

    // execute the method to test.
    try {
      cachingInterceptor.invoke(methodInvocation);
      fail();
    } catch (Throwable throwable) {
      // we are expecting this exception
    }

    verifyExpectationsOfMockControlsWereMet();
  }

  public void testInvokeWithCacheProviderUninitialized() throws Throwable {
    assertInvokeWithStatusOfCacheProviderNotReadyDoesNotAccessCache(CacheProviderFacadeStatus.UNINITIALIZED);
  }

  public void testInvokeWithIllegalStatusOfCacheProvider() throws Throwable {
    assertInvokeWithStatusOfCacheProviderNotReadyDoesNotAccessCache(CacheProviderFacadeStatus.INVALID);
  }
}