options {
	STATIC = false;
	DEBUG_PARSER = false;
}
PARSER_BEGIN(ValangParser)

package org.springmodules.validation.valang;

import org.springmodules.validation.predicates.Operator;
import org.springmodules.validation.predicates.OperatorConstants;
import org.springmodules.validation.predicates.GenericTestPredicate;
import org.springmodules.validation.predicates.BasicValidationRule;

import org.springmodules.validation.functions.Function;
import org.springmodules.validation.functions.LiteralFunction;
import org.springmodules.validation.functions.DateLiteralFunction;
import org.springmodules.validation.functions.BeanPropertyFunction;
import org.springmodules.validation.functions.LengthOfFunction;
import org.springmodules.validation.functions.MapEntryFunction;
import org.springmodules.validation.functions.TargetBeanFunction;
import org.springmodules.validation.functions.AddFunction;
import org.springmodules.validation.functions.SubtractFunction;
import org.springmodules.validation.functions.MultiplyFunction;
import org.springmodules.validation.functions.DivideFunction;
import org.springmodules.validation.functions.ModuloFunction;

import org.springmodules.validation.valang.ValangVisitor;
import org.springmodules.validation.valang.DefaultVisitor;

import org.apache.commons.collections.Predicate;
import org.apache.commons.collections.functors.AndPredicate;
import org.apache.commons.collections.functors.OrPredicate;
import org.apache.commons.collections.functors.NotPredicate;

import org.springmodules.util.dateparser.DateParseException;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.springframework.util.StringUtils;

import java.math.BigDecimal;

import java.util.Collection;
import java.util.ArrayList;

public class ValangParser
{
	private static Log log = LogFactory.getLog(ValangParser.class);
	
	private DefaultVisitor visitor = new DefaultVisitor();
		
	public DefaultVisitor getVisitor() {
	   if (this.visitor == null) {
	       throw new IllegalStateException("Visistor is not set on parser");
	   }
	   return this.visitor;
	}
	
	public void setVisitor(DefaultVisitor visitor) {
		this.visitor = visitor;
	}
	
	private String replace(String s) {
		String tmpS = s;
		
		tmpS = StringUtils.replace(tmpS, "\\'", "'");
		tmpS = StringUtils.replace(tmpS, "\\n", "\n");
		tmpS = StringUtils.replace(tmpS, "\\r", "\r");
		tmpS = StringUtils.replace(tmpS, "\\t", "\t");
		tmpS = StringUtils.replace(tmpS, "\\b", "\b");
		tmpS = StringUtils.replace(tmpS, "\\f", "\f");		
		tmpS = StringUtils.replace(tmpS, "\\\\", "\\");		
		
		return tmpS;
	}
}

PARSER_END(ValangParser)

SKIP :
{
	" "
|	"\t"
|	"\n"
|	"\r"
}

TOKEN [IGNORE_CASE] :
{
	< AND : "AND" >
|	< OR : "OR" >
|	< NOT : "NOT" >
|	< BETWEEN : "BETWEEN" >
|	< NOT_BETWEEN: "NOT BETWEEN" >
|	< IN : "IN" >
|	< NOT_IN : "NOT IN" >
|	< IS_NULL : "IS NULL" | "NULL" >
|	< IS_NOT_NULL : "IS NOT NULL" | "NOT NULL" >
|	< HAS_TEXT : "HAS TEXT" >
|	< HAS_NO_TEXT : "HAS NO TEXT" >
|	< HAS_LENGTH : "HAS LENGTH" >
|	< HAS_NO_LENGTH : "HAS NO LENGTH" >
|	< IS_BLANK : "IS BLANK" >
|	< IS_NOT_BLANK : "IS NOT BLANK" >
|	< IS_UPPER_CASE : "IS UPPERCASE" | "IS UPPER CASE" | "IS UPPER" >
|	< IS_NOT_UPPER_CASE : "IS NOT UPPERCASE" | "IS NOT UPPER CASE" | "IS NOT UPPER" >
|	< IS_LOWER_CASE : "IS LOWERCASE" | "IS LOWER CASE" | "IS LOWER" >
|	< IS_NOT_LOWER_CASE : "IS NOT LOWERCASE" | "IS NOT LOWER CASE" | "IS NOT LOWER" >
|	< IS_WORD : "IS WORD" >
|	< IS_NOT_WORD : "IS NOT WORD" >
|	< TRUE : "TRUE" | "YES" >
|	< FALSE : "FALSE" | "NO" >
|	< MORE_THAN_OR_EQUAL : ">=" | "=>" >
|	< MORE_THAN : ">" >
|	< LESS_THAN_OR_EQUAL : "<=" | "=<" >
|	< LESS_THAN : "<" >
|	< NOT_EQUAL : "!=" | "<>" | "><" >
|	< EQUALS : "=" | "==" >
|	< ADD : "+" >
|	< SUBTRACT : "-" >
|	< MULTIPLY : "*" >
|	< DIVIDE : "/" | "div" >
|	< MOD : "%" | "mod" >
}

TOKEN :
{
	< NUM : ("-")?(["0"-"9"])+ | ("-")?(["0"-"9"])+"." (["0"-"9"])* >
|	< STRING : "'" ( ~["'", "\\", "\n", "\r"] | ( "\\" ( "'" | "\\" | "\n" | "\r" | "\t" | "\b" | "\f" ) ) )* "'" >
|	< DATE : "[" (~["[", "]"])* "]" >
|	< #DOT : "." >
|   < #UNDERSCORE : "_" >
|	< #DIGIT : ["0"-"9"] >
|	< #LOWERLETTER : ["a"-"z"] >
|	< #UPPERLETTER : ["A"-"Z"] >
|   < #PLAIN_PATH_ELEMENT : ( <LOWERLETTER> | <UNDERSCORE> ) ( <LOWERLETTER> | <UPPERLETTER> | <DIGIT> | <UNDERSCORE> )* >
|	< #INDEXED_PATH_ELEMENT : "[" <PLAIN_PATH_ELEMENT> "]" >
|	< FUNCTION_NAME : <PLAIN_PATH_ELEMENT> >
|	< PATH : <PLAIN_PATH_ELEMENT> ( ( <DOT> <PLAIN_PATH_ELEMENT> ) | <INDEXED_PATH_ELEMENT> )* >
}

Predicate parseExpression() :
{
	Predicate predicate = null;
	Function targetBeanFunction = new TargetBeanFunction();
}
{
	predicate = predicates(targetBeanFunction) <EOF> { return predicate; }
}

Collection parseValidation() :
{
	Predicate predicate = null;
	Collection rules = new ArrayList();
	String message = null;
	String field = null;
	String errorKey = null;
	Collection errorArgs = null;
	Function function = null;
	Function fieldFunction = null;
}
{
	(
		( 
			"{" 
			( <FUNCTION_NAME> | <PATH> )
			{ 
				field = token.image; 
				fieldFunction = new BeanPropertyFunction(field);
				/* MOD-26: re-initiliaze error key and arguments to null for every rule.
				   kudos to Cèsar Ordiñana for reporting this bug. */ 
				errorKey = null; 
				errorArgs = new ArrayList(); 
			}
			":"
			predicate = predicates(fieldFunction) 
			":" 
			<STRING> { message = token.image.substring(1, token.image.length() - 1); } 
			[
				":"
				<STRING> { errorKey = token.image.substring(1, token.image.length() - 1); }
				[
					":"
					(
						LOOKAHEAD(2)
						function = function(fieldFunction) { errorArgs.add(function); }
						","
					)*
					function = function(fieldFunction) { errorArgs.add(function); } 
				]
			]
			"}"
		)
		{
			/* JIRA-MOD-20: take into account error key and error args for localization, kudos to Cèsar Ordiñana. */
			rules.add(new BasicValidationRule(field, predicate, errorKey, message, errorArgs));
		}
	)+
	<EOF>
	{
		return rules;
	}
}

Predicate not(Function fieldFunction) :
{
	Predicate predicate = null;
}
{
	<NOT> predicate = expression(fieldFunction) { return NotPredicate.getInstance(predicate); }
}

Predicate predicates(Function fieldFunction) :
{
	Predicate predicate1 = null;
	Predicate predicate2 = null;
	boolean andTest = false;
	boolean orTest = false;
}
{
	(
		predicate1 = expression(fieldFunction)			
		(
			(
				<AND>	{ andTest = true; }
			|	<OR>	{ orTest = true; }
			)
			predicate2 = expression(fieldFunction)
			{
				if (andTest) {
					predicate1 = AndPredicate.getInstance(predicate1, predicate2);
					andTest = false;
				} else if (orTest) {
					predicate1 = OrPredicate.getInstance(predicate1, predicate2);
					orTest = false;
				}
			}
		)*
	)
	{
		return predicate1;
	}
}

Predicate expression(Function fieldFunction) :
{
	Predicate predicate = null;
}
{
	(
		LOOKAHEAD("(" predicates(fieldFunction) ")")
		"(" predicate = predicates(fieldFunction) ")"
	|	predicate = not(fieldFunction)
	|	predicate = predicate(fieldFunction)
	)
	{
		return predicate;
	}
}


Predicate predicate(Function fieldFunction) :
{
	Function leftFunction = null;
	Function rightFunction1 = null;
	Function rightFunction2 = null;
	Function tmpFunction = null;
	Operator operator = null;
	boolean notBetween = false;
	boolean notIn = false;
	Collection functions = new ArrayList();
	boolean collectionProperty = false;
}
{
	(
		leftFunction = additiveExpr(fieldFunction)
		(
			(
	    		operator = binaryOperator() rightFunction1 = additiveExpr(fieldFunction)
			|	operator = unaryOperator()
	    	)
	    	{
	    		return getVisitor().getPredicate(leftFunction, operator, rightFunction1, 0, 0);
	    	}
	    |	(
				( <BETWEEN> | <NOT_BETWEEN> { notBetween = true; } )
				(
					rightFunction1 = additiveExpr(fieldFunction)
					<AND>
					rightFunction2 = additiveExpr(fieldFunction)
				)
				{
					if (notBetween) {
						return getVisitor().getPredicate(leftFunction, OperatorConstants.NOT_BETWEEN_OPERATOR, new LiteralFunction(new Function[] { rightFunction1, rightFunction2 }), 0, 0);
					} else {
						return getVisitor().getPredicate(leftFunction, OperatorConstants.BETWEEN_OPERATOR, new LiteralFunction(new Function[] { rightFunction1, rightFunction2 }), 0, 0);
					}
				}
	    	)
	    |	(
				( <IN> | <NOT_IN> { notIn = true; } )
				(
					(
					    LOOKAHEAD(2)
						tmpFunction = additiveExpr(fieldFunction) { functions.add(tmpFunction); }
						","
					)*
					tmpFunction = additiveExpr(fieldFunction) { functions.add(tmpFunction); }
				|	"@" tmpFunction = beanProperty(fieldFunction) { collectionProperty = true; }
				) 
				{
					if (!collectionProperty) {
						tmpFunction = new LiteralFunction(functions);
					}
					if (notIn) {
						return getVisitor().getPredicate(leftFunction, OperatorConstants.NOT_IN_OPERATOR, tmpFunction, 0, 0);
					} else {
						return getVisitor().getPredicate(leftFunction, OperatorConstants.IN_OPERATOR, tmpFunction, 0, 0);
					}
				}
	    	)
		)
	)
}

Function function(Function fieldFunction) :
{
    String function = null;
    Function leftFunction = null;
    Function rightFunction = null;
    int line = 0;
    int column = 0;
    Collection functionArguments = new ArrayList();
}
{
    (
        LOOKAHEAD(2)
        ( "!" | <FUNCTION_NAME> ) 
        { function = token.image; line = token.beginLine; column = token.beginColumn; } 
        "(" 
        	leftFunction = function(fieldFunction) { functionArguments.add(leftFunction); }
        	(
        		"," 
        		leftFunction = function(fieldFunction) { functionArguments.add(leftFunction); }
        	)*
        ")" 
        { leftFunction = getVisitor().getFunction(function, (Function[])functionArguments.toArray(new Function[functionArguments.size()]), line, column); }
    |   leftFunction = beanPropertyOrLiteral(fieldFunction)
    |	"?" { leftFunction = fieldFunction; }
    |	"(" leftFunction = additiveExpr(fieldFunction) ")"
    )
    {
    	return leftFunction;
    }
}

Function additiveExpr(Function fieldFunction) :
{
	Function leftFunction = null;
	Function rightFunction = null;
	int line = 0;
	int column = 0;
}
{
	leftFunction = subtractiveExpr(fieldFunction)
	( 
		<ADD> { line = token.beginLine; column = token.beginColumn; } rightFunction = subtractiveExpr(fieldFunction) { leftFunction = new AddFunction(leftFunction, rightFunction, line, column); }
	)*
	{
		return leftFunction;
	}
}

Function subtractiveExpr(Function fieldFunction) :
{
	Function leftFunction = null;
	Function rightFunction = null;
	int line = 0;
	int column = 0;
}
{
	leftFunction = multiplicativeExpr(fieldFunction)
	( 
		<SUBTRACT> { line = token.beginLine; column = token.beginColumn; } rightFunction = multiplicativeExpr(fieldFunction) { leftFunction = new SubtractFunction(leftFunction, rightFunction, line, column); }
	)*
	{
		return leftFunction;
	}
}

Function multiplicativeExpr(Function fieldFunction) :
{
	Function leftFunction = null;
	Function rightFunction = null;
	int line = 0;
	int column = 0;
}
{
	leftFunction = function(fieldFunction)
	(
		<MULTIPLY> { line = token.beginLine; column = token.beginColumn; } rightFunction = function(fieldFunction) { leftFunction = new MultiplyFunction(leftFunction, rightFunction, line, column); }
	|	<DIVIDE> { line = token.beginLine; column = token.beginColumn; } rightFunction = function(fieldFunction) { leftFunction = new DivideFunction(leftFunction, rightFunction, line, column); }
	|	<MOD> { line = token.beginLine; column = token.beginColumn; } rightFunction = function(fieldFunction) { leftFunction = new ModuloFunction(leftFunction, rightFunction, line, column); }
	)*
	{
		return leftFunction;
	}
}

Function beanPropertyOrLiteral(Function fieldFunction) :
{
	Function function = null;
}
{
    (
		function = literal() { return function; }
    |   function = beanProperty(fieldFunction) { return function; }
    )
}

Function literal() :
{}
{
    (
        <TRUE>      { return new LiteralFunction(Boolean.TRUE); }
    |   <FALSE>     { return new LiteralFunction(Boolean.FALSE); }
    |   <STRING>    { return new LiteralFunction(replace(token.image.substring(1, token.image.length() - 1))); }
    |   <NUM>       { return new LiteralFunction(new BigDecimal(token.image)); }
    |	<DATE>		{
    					try {
							getVisitor().getDateParser().parse(token.image.substring(1, token.image.length() - 1));    					
    					} catch (DateParseException e) {
    						throw new ParseException("Could not parse date [" + token.image.substring(1, token.image.length() - 1) + "] at line " + token.beginLine + ", column " + token.beginColumn + ".");
    					} 
    					return new DateLiteralFunction(token.image.substring(1, token.image.length() - 1), getVisitor().getDateParser(), token.beginLine, token.beginColumn); 
    				}
	)
}

Function beanProperty(Function fieldFunction) :
{
	Function function = null;
}
{
	function = path() { return function; }
}	

Function path() :
{
	String path = null;
}
{
	(
		<PATH>							{ path = token.image; }
	|	<FUNCTION_NAME>		{ path = token.image; }
	)
	{ 
		return new BeanPropertyFunction(path);
	}
}

Operator binaryOperator() :
{
	Operator operator = null;
}
{
	(
		<NOT_EQUAL>		{ operator = OperatorConstants.NOT_EQUAL_OPERATOR; }
	|	<MORE_THAN_OR_EQUAL>	{ operator = OperatorConstants.MORE_THAN_OR_EQUAL_OPERATOR; }
	|	<MORE_THAN>		{ operator = OperatorConstants.MORE_THAN_OPERATOR; }
	|	<LESS_THAN_OR_EQUAL>	{ operator = OperatorConstants.LESS_THAN_OR_EQUAL_OPERATOR; }
	|	<LESS_THAN>		{ operator = OperatorConstants.LESS_THAN_OPERATOR; }
	|	<EQUALS>		{ operator = OperatorConstants.EQUALS_OPERATOR; }
	)
	{
		return operator;	
	}
}

Operator unaryOperator() :
{
	Operator operator = null;
}
{
	(
		<IS_NULL>		{ operator = OperatorConstants.NULL_OPERATOR; }
	|	<IS_NOT_NULL>		{ operator = OperatorConstants.NOT_NULL_OPERATOR; }
	|	<HAS_TEXT>		{ operator = OperatorConstants.HAS_TEXT_OPERATOR; }
	|	<HAS_NO_TEXT>		{ operator = OperatorConstants.HAS_NO_TEXT_OPERATOR; }
	|	<HAS_LENGTH>		{ operator = OperatorConstants.HAS_LENGTH_OPERATOR; }
	|	<HAS_NO_LENGTH>		{ operator = OperatorConstants.HAS_NO_LENGTH_OPERATOR; }
	|	<IS_BLANK>		{ operator = OperatorConstants.IS_BLANK_OPERATOR; }
	|	<IS_NOT_BLANK>	{ operator = OperatorConstants.IS_NOT_BLANK_OPERATOR; }
	|	<IS_WORD>		{ operator = OperatorConstants.IS_WORD_OPERATOR; }
	|	<IS_NOT_WORD>	{ operator = OperatorConstants.IS_NOT_WORD_OPERATOR; }
	|	<IS_UPPER_CASE>		{ operator = OperatorConstants.IS_UPPER_CASE_OPERATOR; }
	|	<IS_NOT_UPPER_CASE>		{ operator = OperatorConstants.IS_NOT_UPPER_CASE_OPERATOR; }
	|	<IS_LOWER_CASE>		{ operator = OperatorConstants.IS_LOWER_CASE_OPERATOR; }
	|	<IS_NOT_LOWER_CASE>		{ operator = OperatorConstants.IS_NOT_LOWER_CASE_OPERATOR; }
	)
	{
		return operator;
	}
}


