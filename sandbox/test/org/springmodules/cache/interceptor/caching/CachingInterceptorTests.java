/* 
 * Created on Sep 24, 2004
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 * Copyright @2004 the original author or authors.
 */

package org.springmodules.cache.interceptor.caching;

import java.io.Serializable;
import java.lang.reflect.Method;

import junit.framework.TestCase;

import org.aopalliance.intercept.MethodInvocation;
import org.easymock.MockControl;
import org.springmodules.cache.EntryRetrievalException;
import org.springmodules.cache.key.CacheKey;
import org.springmodules.cache.key.CacheKeyGenerator;
import org.springmodules.cache.key.HashCodeCacheKeyGenerator;
import org.springmodules.cache.mock.FixedValueCacheKey;
import org.springmodules.cache.provider.CacheProviderFacade;

/**
 * <p>
 * Unit Test for <code>{@link CachingInterceptor}</code>.
 * </p>
 * 
 * @author Alex Ruiz
 * 
 * @version $Revision: 1.1 $ $Date: 2005/04/22 02:19:00 $
 */
public final class CachingInterceptorTests extends TestCase {

  /**
   * Key to be generated by <code>{@link #mockCacheKeyGenerator}</code>.
   */
  private CacheKey cacheKey;

  /**
   * Metadata attribute for the intercepted method.
   */
  private Cached cachingAttribute;

  /**
   * Primary object (instance of the class to test).
   */
  private CachingInterceptor cachingInterceptor;

  /**
   * Method to be intercepted by <code>{@link #cachingInterceptor}</code>.
   */
  private Method interceptedMethod;

  /**
   * Mock object that simulates the generation of unique keys for cached
   * objects.
   */
  private CacheKeyGenerator mockCacheKeyGenerator;

  /**
   * Controls the behavior of <code>{@link #mockCacheKeyGenerator}</code>.
   */
  private MockControl mockCacheKeyGeneratorControl;

  /**
   * Mock object that simulates a facade to a cache provider.
   */
  private CacheProviderFacade mockCacheProviderFacade;

  /**
   * Controls the behavior of <code>{@link #mockCacheProviderFacade}</code>.
   */
  private MockControl mockCacheProviderFacadeControl;

  /**
   * Mock object that simulates a search of caching-attributes for a given
   * method.
   */
  private CachingAttributeSource mockCachingAttributeSource;

  /**
   * Controls the behavior of <code>{@link #mockCachingAttributeSource}</code>.
   */
  private MockControl mockCachingAttributeSourceControl;

  /**
   * Mock object that simulates a listener that receives a notification every
   * time a new entry is added to the cache.
   */
  private EntryStoredListener mockEntryStoredListener;

  /**
   * Controls the behavior of <code>{@link #mockEntryStoredListener}</code>.
   */
  private MockControl mockEntryStoredListenerControl;

  /**
   * Simulates the definition of the method being intercepted by
   * <code>{@link #cachingInterceptor}</code>.
   */
  private MethodInvocation mockMethodInvocation;

  /**
   * Controls the behavior of <code>{@link #mockMethodInvocation}</code>.
   */
  private MockControl mockMethodInvocationControl;

  /**
   * Constructor.
   * 
   * @param name
   *          the name of the Test Case.
   */
  public CachingInterceptorTests(String name) {
    super(name);
  }

  /**
   * Sets up the test fixture.
   */
  protected void setUp() throws Exception {
    super.setUp();

    Class targetClass = String.class;
    this.interceptedMethod = targetClass.getMethod("concat",
        new Class[] { String.class });

    this.mockCacheProviderFacadeControl = MockControl
        .createControl(CacheProviderFacade.class);
    this.mockCacheProviderFacade = (CacheProviderFacade) this.mockCacheProviderFacadeControl
        .getMock();

    this.cachingAttribute = new Cached();
    this.cachingAttribute.setCacheProfileId("CACHE_PROFILE");

    this.mockCachingAttributeSourceControl = MockControl
        .createControl(CachingAttributeSource.class);
    this.mockCachingAttributeSource = (CachingAttributeSource) this.mockCachingAttributeSourceControl
        .getMock();

    this.mockMethodInvocationControl = MockControl
        .createControl(MethodInvocation.class);
    this.mockMethodInvocation = (MethodInvocation) this.mockMethodInvocationControl
        .getMock();

    this.cachingInterceptor = new CachingInterceptor();
    this.cachingInterceptor
        .setCacheProviderFacade(this.mockCacheProviderFacade);
    this.cachingInterceptor
        .setCachingAttributeSource(this.mockCachingAttributeSource);

    // This expectation is required for all the Test Cases.
    this.mockMethodInvocation.getMethod();
    this.mockMethodInvocationControl.setReturnValue(this.interceptedMethod);
  }

  /**
   * Sets up {@link #cacheKey}.
   */
  private void setUpCacheKey() {
    this.cacheKey = new FixedValueCacheKey("KEY");
  }

  /**
   * Sets up:
   * <ul>
   * <li><code>{@link #mockCacheKeyGenerator}</code></li>
   * <li><code>{@link #mockCacheKeyGeneratorControl}</code></li>
   * </ul>
   */
  private void setUpMockCacheKeyGenerator() {
    // Create the proxy for the interface 'CacheKeyGenerator'.
    this.mockCacheKeyGeneratorControl = MockControl
        .createControl(CacheKeyGenerator.class);
    this.mockCacheKeyGenerator = (CacheKeyGenerator) this.mockCacheKeyGeneratorControl
        .getMock();
    this.cachingInterceptor.setCacheKeyGenerator(this.mockCacheKeyGenerator);
  }

  /**
   * Creates a new instance of:
   * <ul>
   * <li><code>{@link #mockEntryStoredListener}</code></li>
   * <li><code>{@link #mockEntryStoredListenerControl}</code></li>
   * </ul>
   */
  private void setUpMockEntryStoredListener() {
    this.mockEntryStoredListenerControl = MockControl
        .createControl(EntryStoredListener.class);
    this.mockEntryStoredListener = (EntryStoredListener) this.mockEntryStoredListenerControl
        .getMock();
    this.cachingInterceptor
        .setEntryStoredListener(this.mockEntryStoredListener);
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#afterPropertiesSet()}</code> assigns a
   * new instance of <code>{@link HashCodeCacheKeyGenerator}</code> as the key
   * generator of the interceptor if the interceptor does not have a cache
   * generator already set.
   */
  public void testAfterPropertiesSetWhenCacheKeyGeneratorIsNotSet() {
    this.cachingInterceptor.setCacheKeyGenerator(null);

    // execute the method to test.
    this.cachingInterceptor.afterPropertiesSet();

    CacheKeyGenerator cacheKeyGenerator = this.cachingInterceptor
        .getCacheKeyGenerator();

    assertNotNull("The key generator should not be null", cacheKeyGenerator);
    assertTrue(cacheKeyGenerator instanceof HashCodeCacheKeyGenerator);
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#afterPropertiesSet()}</code> does not
   * change the key generator assigned to the interceptor.
   */
  public void testAfterPropertiesSetWhenCacheKeyGeneratorIsSet() {
    CacheKeyGenerator cacheKeyGenerator = new HashCodeCacheKeyGenerator();
    this.cachingInterceptor = new CachingInterceptor();
    this.cachingInterceptor.setCacheKeyGenerator(cacheKeyGenerator);

    // execute the method to test.
    this.cachingInterceptor.afterPropertiesSet();

    assertSame("<CacheKeyGenerator>", cacheKeyGenerator,
        this.cachingInterceptor.getCacheKeyGenerator());
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#getCachingAttribute(MethodInvocation)}</code>
   * returns the instance of <code>{@link Cached}</code> retrieved from
   * <code>{@link #mockCachingAttributeSource}</code>.
   */
  public void testGetCachingAttribute() throws Exception {
    Object thisObject = "A String!";
    Class targetClass = thisObject.getClass();

    // expectation: get the target object for an invocation.
    this.mockMethodInvocation.getThis();
    this.mockMethodInvocationControl.setReturnValue(thisObject);

    // expectation: get the caching-attribute of the intercepted method.
    this.mockCachingAttributeSource.getCachingAttribute(this.interceptedMethod,
        targetClass);
    this.mockCachingAttributeSourceControl
        .setReturnValue(this.cachingAttribute);

    // set the state of the mock controls to 'replay'.
    this.mockCachingAttributeSourceControl.replay();
    this.mockMethodInvocationControl.replay();

    // execute the method to test.
    Cached returnedCachingAttribute = this.cachingInterceptor
        .getCachingAttribute(this.mockMethodInvocation);

    // verify that the caching-attribute is the same we are expecting.
    assertSame("<Caching-attribute>", this.cachingAttribute,
        returnedCachingAttribute);

    // verify that the expectations of the mock controls were met.
    this.mockCachingAttributeSourceControl.verify();
    this.mockMethodInvocationControl.verify();
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#getCachingAttribute(MethodInvocation)}</code>
   * returns the instance of <code>{@link Cached}</code> retrieved from
   * <code>{@link #mockCachingAttributeSource}</code> when
   * <code>MethodInvocation.getThis()</code> returns <code>null</code>.
   */
  public void testGetCachingAttributeWithMethodInvocationHavingThisObjectEqualToNull()
      throws Exception {

    Object thisObject = null;
    Class targetClass = null;

    // expectation: get the target object for an invocation.
    this.mockMethodInvocation.getThis();
    this.mockMethodInvocationControl.setReturnValue(thisObject);

    // expectation: get the caching-attribute of the intercepted method.
    this.mockCachingAttributeSource.getCachingAttribute(this.interceptedMethod,
        targetClass);
    this.mockCachingAttributeSourceControl
        .setReturnValue(this.cachingAttribute);

    // set the state of the mock controls to 'replay'.
    this.mockCachingAttributeSourceControl.replay();
    this.mockMethodInvocationControl.replay();

    // execute the method to test.
    Cached returnedCachingAttribute = this.cachingInterceptor
        .getCachingAttribute(this.mockMethodInvocation);

    // verify that the caching-attribute is the same we are expecting.
    assertSame("<Caching-attribute>", this.cachingAttribute,
        returnedCachingAttribute);

    // verify that the expectations of the mock controls were met.
    this.mockCachingAttributeSourceControl.verify();
    this.mockMethodInvocationControl.verify();
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#invoke(MethodInvocation)}</code> does not
   * store in the cache the return value of the intercepted method if the
   * intercepted method does not contain any caching-attributes.
   */
  public void testInvokeHavingCachingAttributeEqualToNull() throws Throwable {
    Object thisObject = "A String!";
    Class targetClass = thisObject.getClass();

    // return value expected to be returned when executing the intercepted
    // method.
    Object expectedReturnValue = new Integer(10);

    // expectation: get the target object for an invocation.
    this.mockMethodInvocation.getThis();
    this.mockMethodInvocationControl.setReturnValue(thisObject);

    // expectation: get the caching-attribute for the intercepted method. The
    // returned caching-attribute should be null.
    this.mockCachingAttributeSource.getCachingAttribute(this.interceptedMethod,
        targetClass);
    this.mockCachingAttributeSourceControl.setReturnValue(null);

    // expectation: execute the intercepted method. The return value should not
    // be cached since there is not any caching-attribute.
    this.mockMethodInvocation.proceed();
    this.mockMethodInvocationControl.setReturnValue(expectedReturnValue);

    // set the state of the mock controls to 'replay'.
    this.mockCachingAttributeSourceControl.replay();
    this.mockCacheProviderFacadeControl.replay();
    this.mockMethodInvocationControl.replay();

    // execute the method to test.
    Object actualReturnValue = this.cachingInterceptor
        .invoke(this.mockMethodInvocation);

    assertSame("<Returned Value>", expectedReturnValue, actualReturnValue);

    // verify that the expectations of the mock controls were met.
    this.mockCachingAttributeSourceControl.verify();
    this.mockCacheProviderFacadeControl.verify();
    this.mockMethodInvocationControl.verify();
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#invoke(MethodInvocation)}</code> returns
   * <code>null</code> if the cache already stored the returned value of the
   * intercepted method and the stored value is
   * <code>{@link CachingAspectSupport#NULL_ENTRY}</code>.
   */
  public void testInvokeHavingObjectInCacheEqualToNullEntry() throws Throwable {
    this.setUpCacheKey();
    this.setUpMockCacheKeyGenerator();
    Object thisObject = "A String!";
    Class targetClass = thisObject.getClass();
    Object cachedObject = CachingAspectSupport.NULL_ENTRY;

    // expectation: get the target object for an invocation.
    this.mockMethodInvocation.getThis();
    this.mockMethodInvocationControl.setReturnValue(thisObject);

    // expectation: get the caching-attribute for the intercepted method.
    this.mockCachingAttributeSource.getCachingAttribute(this.interceptedMethod,
        targetClass);
    this.mockCachingAttributeSourceControl
        .setReturnValue(this.cachingAttribute);

    // expectation: generate the key for the object to cache (or already
    // cached).
    this.mockCacheKeyGenerator.generateKey(this.mockMethodInvocation);
    this.mockCacheKeyGeneratorControl.setReturnValue(this.cacheKey);

    // expectation: get the object stored in the cache under the id retrieved
    // from the caching-attribute.
    String cacheProfileId = this.cachingAttribute.getCacheProfileId();
    this.mockCacheProviderFacade.getFromCache(this.cacheKey, cacheProfileId);
    this.mockCacheProviderFacadeControl.setReturnValue(cachedObject);

    // set the state of the mock controls to 'replay'.
    this.mockCachingAttributeSourceControl.replay();
    this.mockCacheKeyGeneratorControl.replay();
    this.mockCacheProviderFacadeControl.replay();
    this.mockMethodInvocationControl.replay();

    // execute the method to test.
    Object actualCachedObject = this.cachingInterceptor
        .invoke(this.mockMethodInvocation);

    assertNull("The cached object should be null", actualCachedObject);

    // verify that the expectations of the mock controls were met.
    this.mockCachingAttributeSourceControl.verify();
    this.mockCacheKeyGeneratorControl.verify();
    this.mockCacheProviderFacadeControl.verify();
    this.mockMethodInvocationControl.verify();
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#invoke(MethodInvocation)}</code>
   * retrieves from the cache the stored return value of the intercepted method
   * and returns it instead of executing the intercepted method.
   */
  public void testInvokeHavingObjectInCacheNotEqualToNull() throws Throwable {
    this.setUpCacheKey();
    this.setUpMockCacheKeyGenerator();
    Object thisObject = "A String!";
    Class targetClass = thisObject.getClass();
    Object expectedCachedObject = new Integer(4225);

    // expectation: get the target object for an invocation.
    this.mockMethodInvocation.getThis();
    this.mockMethodInvocationControl.setReturnValue(thisObject);

    // expectation: get the caching-attribute for the intercepted method.
    this.mockCachingAttributeSource.getCachingAttribute(this.interceptedMethod,
        targetClass);
    this.mockCachingAttributeSourceControl
        .setReturnValue(this.cachingAttribute);

    // expectation: generate the key for the object to cache (or already
    // cached).
    this.mockCacheKeyGenerator.generateKey(this.mockMethodInvocation);
    this.mockCacheKeyGeneratorControl.setReturnValue(this.cacheKey);

    // expectation: get the object stored in the cache under the id retrieved
    // from the caching-attribute.
    String cacheProfileId = this.cachingAttribute.getCacheProfileId();
    this.mockCacheProviderFacade.getFromCache(this.cacheKey, cacheProfileId);
    this.mockCacheProviderFacadeControl.setReturnValue(expectedCachedObject);

    // set the state of the mock controls to 'replay'.
    this.mockCachingAttributeSourceControl.replay();
    this.mockCacheKeyGeneratorControl.replay();
    this.mockCacheProviderFacadeControl.replay();
    this.mockMethodInvocationControl.replay();

    // execute the method to test.
    Object actualCachedObject = this.cachingInterceptor
        .invoke(this.mockMethodInvocation);

    assertSame("<Cached object>", expectedCachedObject, actualCachedObject);

    // verify that the expectations of the mock controls were met.
    this.mockCachingAttributeSourceControl.verify();
    this.mockCacheKeyGeneratorControl.verify();
    this.mockCacheProviderFacadeControl.verify();
    this.mockMethodInvocationControl.verify();
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#invoke(MethodInvocation)}</code> stores
   * in the cache the return value of the intercepted method and notifies the
   * listener that a new object has been saved in the cache.
   */
  public void testInvokeWhenObjectIsNotCachedAndInterceptorHasListener()
      throws Throwable {
    this.setUpCacheKey();
    this.setUpMockCacheKeyGenerator();
    this.setUpMockEntryStoredListener();

    Object thisObject = "A String!";
    Class targetClass = thisObject.getClass();
    Object proceedReturnValue = new Integer(434);

    // expectation: get the target object for an invocation.
    this.mockMethodInvocation.getThis();
    this.mockMethodInvocationControl.setReturnValue(thisObject);

    // expectation: get the caching-attribute for the intercepted method.
    this.mockCachingAttributeSource.getCachingAttribute(this.interceptedMethod,
        targetClass);
    this.mockCachingAttributeSourceControl
        .setReturnValue(this.cachingAttribute);

    // expectation: generate the key for the object to cache (or already
    // cached).
    this.mockCacheKeyGenerator.generateKey(this.mockMethodInvocation);
    this.mockCacheKeyGeneratorControl.setReturnValue(this.cacheKey);

    // expectation: get the object stored in the cache under the id retrieved
    // from the caching-attribute. There should not be any cached object.
    String cacheProfileId = this.cachingAttribute.getCacheProfileId();
    this.mockCacheProviderFacade.getFromCache(this.cacheKey, cacheProfileId);
    this.mockCacheProviderFacadeControl.setReturnValue(null);

    // expectation: since the object is not cached, execute the intercepted
    // method.
    this.mockMethodInvocation.proceed();
    this.mockMethodInvocationControl.setReturnValue(proceedReturnValue);

    // expectation: put in the cache the return value of the intercepted method.
    this.mockCacheProviderFacade.putInCache(this.cacheKey, cacheProfileId,
        proceedReturnValue);

    // expectation: notify the listener that a new entry has been added to the
    // cache.
    this.mockEntryStoredListener.onEntryAdd(this.cacheKey, proceedReturnValue);

    // set the state of the mock controls to 'replay'.
    this.mockCachingAttributeSourceControl.replay();
    this.mockCacheKeyGeneratorControl.replay();
    this.mockCacheProviderFacadeControl.replay();
    this.mockEntryStoredListenerControl.replay();
    this.mockMethodInvocationControl.replay();

    // execute the method to test.
    Object actualCachedObject = this.cachingInterceptor
        .invoke(this.mockMethodInvocation);

    assertSame("<Cached object>", proceedReturnValue, actualCachedObject);

    // verify that the expectations of the mock controls were met.
    this.mockCachingAttributeSourceControl.verify();
    this.mockCacheKeyGeneratorControl.verify();
    this.mockCacheProviderFacadeControl.verify();
    this.mockEntryStoredListenerControl.verify();
    this.mockMethodInvocationControl.verify();
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#invoke(MethodInvocation)}</code> stores
   * in the cache <code>{@link CachingAspectSupport#NULL_ENTRY}</code> if the
   * return value of the intercepted method is <code>null</code>.
   */
  public void testInvokeWhenObjectIsNotCachedAndProceedReturnsNull()
      throws Throwable {

    this.setUpCacheKey();
    this.setUpMockCacheKeyGenerator();

    Object thisObject = "A String!";
    Class targetClass = thisObject.getClass();

    // expectation: get the target object for an invocation.
    this.mockMethodInvocation.getThis();
    this.mockMethodInvocationControl.setReturnValue(thisObject);

    // expectation: get the caching-attribute for the intercepted method.
    this.mockCachingAttributeSource.getCachingAttribute(this.interceptedMethod,
        targetClass);
    this.mockCachingAttributeSourceControl
        .setReturnValue(this.cachingAttribute);

    // expectation: generate the key for the object to cache (or already
    // cached).
    this.mockCacheKeyGenerator.generateKey(this.mockMethodInvocation);
    this.mockCacheKeyGeneratorControl.setReturnValue(this.cacheKey);

    // expectation: get the object stored in the cache under the id retrieved
    // from the caching-attribute. There should not be any cached object.
    String cacheProfileId = this.cachingAttribute.getCacheProfileId();
    this.mockCacheProviderFacade.getFromCache(this.cacheKey, cacheProfileId);
    this.mockCacheProviderFacadeControl.setReturnValue(null);

    // expectation: since the object is not cached, execute the intercepted
    // method.
    this.mockMethodInvocation.proceed();
    this.mockMethodInvocationControl.setReturnValue(null);

    // expectation: put in the cache the return value of the intercepted method.
    this.mockCacheProviderFacade.putInCache(this.cacheKey, cacheProfileId,
        CachingAspectSupport.NULL_ENTRY);

    // set the state of the mock controls to 'replay'.
    this.mockCachingAttributeSourceControl.replay();
    this.mockCacheKeyGeneratorControl.replay();
    this.mockCacheProviderFacadeControl.replay();
    this.mockMethodInvocationControl.replay();

    // execute the method to test.
    Object actualReturnedValue = this.cachingInterceptor
        .invoke(this.mockMethodInvocation);

    assertNull("The return value of the intercepted method should be null",
        actualReturnedValue);

    // verify that the expectations of the mock controls were met.
    this.mockCachingAttributeSourceControl.verify();
    this.mockCacheKeyGeneratorControl.verify();
    this.mockCacheProviderFacadeControl.verify();
    this.mockMethodInvocationControl.verify();
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#invoke(MethodInvocation)}</code> cancels
   * the update being made to the cache when a <code>Throwable</code> is
   * thrown while executing the intercepted method.
   */
  public void testInvokeWhenObjectIsNotCachedAndProceedThrowsThrowable()
      throws Throwable {

    this.setUpCacheKey();
    this.setUpMockCacheKeyGenerator();

    Object thisObject = "A String!";
    Class targetClass = thisObject.getClass();

    // expectation: get the target object for an invocation.
    this.mockMethodInvocation.getThis();
    this.mockMethodInvocationControl.setReturnValue(thisObject);

    // expectation: get the caching-attribute for the intercepted method.
    this.mockCachingAttributeSource.getCachingAttribute(this.interceptedMethod,
        targetClass);
    this.mockCachingAttributeSourceControl
        .setReturnValue(this.cachingAttribute);

    // expectation: generate the key for the object to cache (or already
    // cached).
    this.mockCacheKeyGenerator.generateKey(this.mockMethodInvocation);
    this.mockCacheKeyGeneratorControl.setReturnValue(this.cacheKey);

    // expectation: get the object stored in the cache under the id retrieved
    // from the caching-attribute. There should not be any cached object.
    String cacheProfileId = this.cachingAttribute.getCacheProfileId();
    this.mockCacheProviderFacade.getFromCache(this.cacheKey, cacheProfileId);
    this.mockCacheProviderFacadeControl.setReturnValue(null);

    // expectation: since the object is not cached, execute the intercepted
    // method. It should throw an exception.
    this.mockMethodInvocation.proceed();
    this.mockMethodInvocationControl.setThrowable(new Throwable());

    // expectation: cancel the update to the cache.
    this.mockCacheProviderFacade.cancelCacheUpdate(this.cacheKey);

    // set the state of the mock controls to 'replay'.
    this.mockCachingAttributeSourceControl.replay();
    this.mockCacheKeyGeneratorControl.replay();
    this.mockCacheProviderFacadeControl.replay();
    this.mockMethodInvocationControl.replay();

    // execute the method to test.
    try {
      this.cachingInterceptor.invoke(this.mockMethodInvocation);
      fail("A Throwable should have been thrown");
    } catch (Throwable throwable) {
      // we expect to catch this throwable.
    }

    // verify that the expectations of the mock controls were met.
    this.mockCachingAttributeSourceControl.verify();
    this.mockCacheKeyGeneratorControl.verify();
    this.mockCacheProviderFacadeControl.verify();
    this.mockMethodInvocationControl.verify();
  }

  /**
   * Tests <code>{@link CachingInterceptor#invoke(MethodInvocation)}</code>.
   * Verifies that when
   * <code>{@link CacheProviderFacade#getFromCache(Serializable, String)}</code>
   * throws <code>{@link EntryRetrievalException}</code> no caching is
   * performed and the return value of <code>MethodInvocation.proceed()</code>
   * is returned.
   */
  public void testInvokeWhenThrowingEntryRetrievalException() throws Throwable {
    this.setUpCacheKey();
    this.setUpMockCacheKeyGenerator();

    Object thisObject = "A String!";
    Class targetClass = thisObject.getClass();
    Object proceedReturnValue = new Integer(4239);

    // expectation: get the target object for an invocation.
    this.mockMethodInvocation.getThis();
    this.mockMethodInvocationControl.setReturnValue(thisObject);

    // expectation: get the caching-attribute for the intercepted method.
    this.mockCachingAttributeSource.getCachingAttribute(this.interceptedMethod,
        targetClass);
    this.mockCachingAttributeSourceControl
        .setReturnValue(this.cachingAttribute);

    // expectation: generate the key for the object to cache (or already
    // cached).
    this.mockCacheKeyGenerator.generateKey(this.mockMethodInvocation);
    this.mockCacheKeyGeneratorControl.setReturnValue(this.cacheKey);

    // expectation: get the object stored in the cache under the id retrieved
    // from the caching-attribute. Should throw a EntryRetrievalException.
    String cacheProfileId = this.cachingAttribute.getCacheProfileId();
    this.mockCacheProviderFacade.getFromCache(this.cacheKey, cacheProfileId);
    this.mockCacheProviderFacadeControl
        .setThrowable(new EntryRetrievalException(""));

    // expectation: since we cannot access the cache, execute the intercepted
    // method.
    this.mockMethodInvocation.proceed();
    this.mockMethodInvocationControl.setReturnValue(proceedReturnValue);

    // set the state of the mock controls to 'replay'.
    this.mockCachingAttributeSourceControl.replay();
    this.mockCacheKeyGeneratorControl.replay();
    this.mockCacheProviderFacadeControl.replay();
    this.mockMethodInvocationControl.replay();

    // execute the method to test.
    Object actualCachedObject = this.cachingInterceptor
        .invoke(this.mockMethodInvocation);

    assertSame("<Cached object>", proceedReturnValue, actualCachedObject);

    // verify that the expectations of the mock controls were met.
    this.mockCachingAttributeSourceControl.verify();
    this.mockCacheKeyGeneratorControl.verify();
    this.mockCacheProviderFacadeControl.verify();
    this.mockMethodInvocationControl.verify();
  }
}